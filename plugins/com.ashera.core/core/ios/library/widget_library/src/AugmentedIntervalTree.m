//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-widget_library\widget_library\src\com\ashera\attributedtext\AugmentedIntervalTree.java
//

#include "AttributedString.h"
#include "AugmentedIntervalTree.h"
#include "BulletInterval.h"
#include "IConverter.h"
#include "IFragment.h"
#include "IOSObjectArray.h"
#include "ImageInterval.h"
#include "Interval.h"
#include "J2ObjC_source.h"
#include "PluginInvoker.h"
#include "StyleInterval.h"
#include "UrlInterval.h"
#include "WidgetAttribute.h"
#include "WidgetAttributeMap.h"
#include "WidgetAttributeValue.h"
#include "java/io/PrintStream.h"
#include "java/lang/Float.h"
#include "java/lang/System.h"
#include "java/util/ArrayList.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/Set.h"

@protocol JavaUtilMap;
@protocol JavaUtilSet;


@interface ASAugmentedIntervalTree () {
 @public
  ASInterval *root_;
  NSString *text_;
  id<JavaUtilSet> list_;
  id<ASIFragment> fragment_;
  id<JavaUtilMap> htmlConfig_;
}

- (id)quickConvertWithNSString:(NSString *)name
                  withNSString:(NSString *)value;

- (NSString *)getValueWithNSString:(NSString *)key
                   withJavaUtilMap:(id<JavaUtilMap>)attributes;

- (void)updateStyleInMapWithASWidgetAttributeMap:(ASWidgetAttributeMap *)inlineStyle
                                 withJavaUtilMap:(id<JavaUtilMap>)attributes;

@end

J2OBJC_FIELD_SETTER(ASAugmentedIntervalTree, root_, ASInterval *)
J2OBJC_FIELD_SETTER(ASAugmentedIntervalTree, text_, NSString *)
J2OBJC_FIELD_SETTER(ASAugmentedIntervalTree, list_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(ASAugmentedIntervalTree, fragment_, id<ASIFragment>)
J2OBJC_FIELD_SETTER(ASAugmentedIntervalTree, htmlConfig_, id<JavaUtilMap>)

__attribute__((unused)) static id ASAugmentedIntervalTree_quickConvertWithNSString_withNSString_(ASAugmentedIntervalTree *self, NSString *name, NSString *value);

__attribute__((unused)) static NSString *ASAugmentedIntervalTree_getValueWithNSString_withJavaUtilMap_(ASAugmentedIntervalTree *self, NSString *key, id<JavaUtilMap> attributes);

__attribute__((unused)) static void ASAugmentedIntervalTree_updateStyleInMapWithASWidgetAttributeMap_withJavaUtilMap_(ASAugmentedIntervalTree *self, ASWidgetAttributeMap *inlineStyle, id<JavaUtilMap> attributes);

@implementation ASAugmentedIntervalTree

- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)htmlConfig
                    withASIFragment:(id<ASIFragment>)fragment {
  ASAugmentedIntervalTree_initWithJavaUtilMap_withASIFragment_(self, htmlConfig, fragment);
  return self;
}

- (NSString *)getText {
  return text_;
}

- (void)setTextWithNSString:(NSString *)text {
  JreStrongAssign(&self->text_, text);
}

- (void)insertNodeWithASInterval:(ASInterval *)newNode {
  NSString *key = JreStrcat("ICI", [((ASInterval *) nil_chk(newNode)) getStart], '_', [newNode getEnd]);
  if (![((id<JavaUtilSet>) nil_chk(list_)) containsWithId:key]) {
    [((id<JavaUtilSet>) nil_chk(list_)) addWithId:key];
    if (root_ == nil) {
      JreStrongAssign(&root_, newNode);
      return;
    }
    JreStrongAssign(&self->root_, [self insertNodeWithASInterval:self->root_ withASInterval:newNode]);
  }
}

- (ASInterval *)insertNodeWithASInterval:(ASInterval *)tmp
                          withASInterval:(ASInterval *)newNode {
  if (tmp == nil) {
    tmp = newNode;
    return tmp;
  }
  if ([((ASInterval *) nil_chk(newNode)) getEnd] > [tmp getMax]) {
    [tmp setMaxWithInt:[newNode getEnd]];
  }
  if ([tmp compareToWithId:newNode] <= 0) {
    if ([tmp getRight] == nil) {
      if ([newNode getStart] == [tmp getStart] && [newNode getEnd] >= [tmp getEnd]) {
        [newNode setStartWithInt:[tmp getEnd]];
        [self insertNodeWithASInterval:self->root_ withASInterval:newNode];
      }
      else {
        [tmp setRightWithASInterval:newNode];
      }
    }
    else {
      if ([newNode getStart] == [tmp getStart] && [newNode getEnd] >= [tmp getEnd]) {
        [newNode setStartWithInt:[tmp getEnd]];
      }
      [self insertNodeWithASInterval:[tmp getRight] withASInterval:newNode];
    }
  }
  else {
    if ([tmp getLeft] == nil) {
      if ([newNode getEnd] > [tmp getStart]) {
        jint newNodeEnd = [newNode getEnd];
        [newNode setEndWithInt:[tmp getStart]];
        if (newNodeEnd > [tmp getEnd]) {
          [self insertNodeWithASInterval:self->root_ withASInterval:[newNode makeNodeWithInt:[tmp getEnd] withInt:newNodeEnd withNSObjectArray:[newNode getArgs]]];
        }
      }
      [tmp setLeftWithASInterval:newNode];
    }
    else {
      [self insertNodeWithASInterval:[tmp getLeft] withASInterval:newNode];
    }
  }
  return tmp;
}

- (void)printTree {
  [self printTreeWithASInterval:self->root_];
}

- (void)printTreeWithASInterval:(ASInterval *)tmp {
  if (tmp == nil) {
    return;
  }
  if ([tmp getLeft] != nil) {
    [self printTreeWithASInterval:[tmp getLeft]];
  }
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithId:tmp];
  if ([tmp getRight] != nil) {
    [self printTreeWithASInterval:[tmp getRight]];
  }
}

- (void)intersectIntervalWithASInterval:(ASInterval *)tmp
                         withASInterval:(ASInterval *)i
                       withJavaUtilList:(id<JavaUtilList>)res {
  if (tmp == nil) {
    return;
  }
  if (!(([tmp getStart] > [((ASInterval *) nil_chk(i)) getEnd]) || ([tmp getEnd] < [i getStart]))) {
    if (res == nil) {
      res = create_JavaUtilArrayList_init();
    }
    [res addWithId:tmp];
  }
  if (([tmp getLeft] != nil) && ([((ASInterval *) nil_chk([tmp getLeft])) getMax] >= [i getStart])) {
    [self intersectIntervalWithASInterval:[tmp getLeft] withASInterval:i withJavaUtilList:res];
  }
  [self intersectIntervalWithASInterval:[tmp getRight] withASInterval:i withJavaUtilList:res];
}

- (void)applyWithASAttributedString:(id<ASAttributedString>)spannableString {
  [self applyWithASInterval:self->root_ withASAttributedString:spannableString];
}

- (void)applyWithASInterval:(ASInterval *)tmp
     withASAttributedString:(id<ASAttributedString>)spannableString {
  if (tmp == nil) {
    return;
  }
  if ([tmp getLeft] != nil) {
    [self applyWithASInterval:[tmp getLeft] withASAttributedString:spannableString];
  }
  jint start = [tmp getStart];
  jint end = [tmp getEnd];
  [((id<ASAttributedString>) nil_chk(spannableString)) init__WithInt:start withInt:end];
  jint style = 0;
  jfloat textSize = 0.0f;
  id typeFace = nil;
  if ([tmp isKindOfClass:[ASStyleInterval class]]) {
    id<JavaUtilMap> attributes = JreRetainedLocalValue([self getStyleWithASWidgetAttributeMap:[((ASStyleInterval *) tmp) getStyle]]);
    NSString *verticalAlign = nil;
    id<JavaUtilSet> widgetAttributes = JreRetainedLocalValue([((id<JavaUtilMap>) nil_chk(attributes)) keySet]);
    for (NSString * __strong widgetAttribute in nil_chk(widgetAttributes)) {
      NSString *value = ASAugmentedIntervalTree_getValueWithNSString_withJavaUtilMap_(self, widgetAttribute, attributes);
      if (value != nil) {
        switch (JreIndexOfStr(widgetAttribute, (id[]){ @"color", @"textColor", @"background-color", @"background", @"textAlignment", @"gravity", @"text-align", @"vertical-align", @"font-family", @"fontFamily", @"font-size", @"textSize", @"textStyle", @"font-weight", @"font-style", @"text-decoration", @"line-height", @"lineHeight" }, 18)) {
          case 0:
          case 1:
          {
            id objcolor = ASAugmentedIntervalTree_quickConvertWithNSString_withNSString_(self, @"color", value);
            [spannableString applyColorWithId:objcolor withInt:start withInt:end];
          }
          break;
          case 2:
          case 3:
          {
            id objcolor = ASAugmentedIntervalTree_quickConvertWithNSString_withNSString_(self, @"color", value);
            [spannableString applyBackgroundColorWithId:objcolor withInt:start withInt:end];
          }
          break;
          case 4:
          {
            NSString *textAlign = JreRetainedLocalValue(value);
            NSString *align = @"left";
            switch (JreIndexOfStr(textAlign, (id[]){ @"center", @"textEnd", @"viewEnd", @"textStart", @"viewStart" }, 5)) {
              case 0:
              align = @"center";
              break;
              case 1:
              case 2:
              align = @"right";
              break;
              case 3:
              case 4:
              align = @"left";
              break;
              default:
              break;
            }
            [spannableString applyTextAlignWithNSString:align withInt:start withInt:end];
          }
          break;
          case 5:
          {
            NSString *gravity = JreStrcat("$C", value, '|');
            NSString *align = @"left";
            if ([gravity java_contains:@"center|"] || [gravity java_contains:@"center_horizontal|"]) {
              align = @"center";
            }
            if ([gravity java_contains:@"right|"] || [gravity java_contains:@"end|"]) {
              align = @"right";
            }
            [spannableString applyTextAlignWithNSString:align withInt:start withInt:end];
          }
          break;
          case 6:
          {
            [spannableString applyTextAlignWithNSString:value withInt:start withInt:end];
          }
          break;
          case 7:
          {
            verticalAlign = value;
          }
          break;
          case 8:
          case 9:
          {
            typeFace = ASAugmentedIntervalTree_quickConvertWithNSString_withNSString_(self, @"font", value);
          }
          break;
          case 10:
          case 11:
          {
            textSize = [((JavaLangFloat *) nil_chk((JavaLangFloat *) cast_chk(ASAugmentedIntervalTree_quickConvertWithNSString_withNSString_(self, @"dimensionsp", value), [JavaLangFloat class]))) floatValue];
          }
          break;
          case 12:
          {
            NSString *textStyle = JreStrcat("$C", value, '|');
            if ([textStyle java_contains:@"bold|"]) {
              style |= 1;
            }
            if ([textStyle java_contains:@"italics|"]) {
              style |= 2;
            }
          }
          break;
          case 13:
          {
            jint weight = 0;
            if ([value isEqual:@"bold"]) {
              weight = 2;
            }
            style |= weight;
          }
          break;
          case 14:
          {
            jint fontStyle = 0;
            if ([value isEqual:@"italics"]) {
              fontStyle = 2;
            }
            style |= fontStyle;
          }
          break;
          case 15:
          {
            if ([value isEqual:@"underline"]) {
              [spannableString applyUnderLineWithInt:start withInt:end];
            }
            else if ([value isEqual:@"line-through"]) {
              [spannableString applyStrikeThroughWithInt:start withInt:end];
            }
          }
          break;
          case 16:
          case 17:
          {
            JavaLangFloat *lineHeight = (JavaLangFloat *) cast_chk(ASAugmentedIntervalTree_quickConvertWithNSString_withNSString_(self, @"dimensionfloat", value), [JavaLangFloat class]);
            [spannableString applyLineHeightWithFloat:[((JavaLangFloat *) nil_chk(lineHeight)) floatValue] withInt:start withInt:end];
          }
          break;
          default:
          break;
        }
      }
    }
    if (typeFace != nil || style != 0 || textSize != 0) {
      [spannableString applyFontWithId:typeFace withFloat:textSize withInt:style withInt:start withInt:end];
    }
    if (verticalAlign != nil) {
      [spannableString applyVerticalAlignWithNSString:verticalAlign withInt:start withInt:end];
    }
  }
  if ([tmp isKindOfClass:[ASUrlInterval class]]) {
    [spannableString applyUrlWithNSString:[((ASUrlInterval *) tmp) getHref] withId:[((id<JavaUtilMap>) nil_chk(htmlConfig_)) getWithId:@"textColorLink"] withInt:start withInt:end];
  }
  if ([tmp isKindOfClass:[ASImageInterval class]]) {
    id image = ASAugmentedIntervalTree_quickConvertWithNSString_withNSString_(self, @"drawable", [((ASImageInterval *) tmp) getSrc]);
    [spannableString applyImgWithId:image withInt:start withInt:end];
  }
  if ([tmp isKindOfClass:[ASBulletInterval class]]) {
    ASBulletInterval *bulletInterval = (ASBulletInterval *) tmp;
    [spannableString applyBulletWithInt:[bulletInterval getIndent] withInt:[bulletInterval getBulletSpacing] withInt:start withInt:end];
  }
  if ([tmp getRight] != nil) {
    [self applyWithASInterval:[tmp getRight] withASAttributedString:spannableString];
  }
}

- (id)quickConvertWithNSString:(NSString *)name
                  withNSString:(NSString *)value {
  return ASAugmentedIntervalTree_quickConvertWithNSString_withNSString_(self, name, value);
}

- (NSString *)getValueWithNSString:(NSString *)key
                   withJavaUtilMap:(id<JavaUtilMap>)attributes {
  return ASAugmentedIntervalTree_getValueWithNSString_withJavaUtilMap_(self, key, attributes);
}

- (id<JavaUtilMap>)getStyleWithASWidgetAttributeMap:(ASWidgetAttributeMap *)inlineStyle {
  id<JavaUtilMap> attributes = create_JavaUtilHashMap_init();
  ASAugmentedIntervalTree_updateStyleInMapWithASWidgetAttributeMap_withJavaUtilMap_(self, inlineStyle, attributes);
  return attributes;
}

- (void)updateStyleInMapWithASWidgetAttributeMap:(ASWidgetAttributeMap *)inlineStyle
                                 withJavaUtilMap:(id<JavaUtilMap>)attributes {
  ASAugmentedIntervalTree_updateStyleInMapWithASWidgetAttributeMap_withJavaUtilMap_(self, inlineStyle, attributes);
}

- (void)dealloc {
  RELEASE_(root_);
  RELEASE_(text_);
  RELEASE_(list_);
  RELEASE_(fragment_);
  RELEASE_(htmlConfig_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "LASInterval;", 0x1, 4, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 7, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, 10, -1, -1 },
    { NULL, "V", 0x1, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 13, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x2, 14, 15, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, 16, 17, -1, 18, -1, -1 },
    { NULL, "LJavaUtilMap;", 0x1, 19, 20, -1, 21, -1, -1 },
    { NULL, "V", 0x2, 22, 23, -1, 24, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaUtilMap:withASIFragment:);
  methods[1].selector = @selector(getText);
  methods[2].selector = @selector(setTextWithNSString:);
  methods[3].selector = @selector(insertNodeWithASInterval:);
  methods[4].selector = @selector(insertNodeWithASInterval:withASInterval:);
  methods[5].selector = @selector(printTree);
  methods[6].selector = @selector(printTreeWithASInterval:);
  methods[7].selector = @selector(intersectIntervalWithASInterval:withASInterval:withJavaUtilList:);
  methods[8].selector = @selector(applyWithASAttributedString:);
  methods[9].selector = @selector(applyWithASInterval:withASAttributedString:);
  methods[10].selector = @selector(quickConvertWithNSString:withNSString:);
  methods[11].selector = @selector(getValueWithNSString:withJavaUtilMap:);
  methods[12].selector = @selector(getStyleWithASWidgetAttributeMap:);
  methods[13].selector = @selector(updateStyleInMapWithASWidgetAttributeMap:withJavaUtilMap:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "root_", "LASInterval;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "text_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "list_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x2, -1, -1, 25, -1 },
    { "fragment_", "LASIFragment;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "htmlConfig_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x2, -1, -1, 26, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilMap;LASIFragment;", "(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;Lcom/ashera/core/IFragment;)V", "setText", "LNSString;", "insertNode", "LASInterval;", "LASInterval;LASInterval;", "printTree", "intersectInterval", "LASInterval;LASInterval;LJavaUtilList;", "(Lcom/ashera/attributedtext/Interval;Lcom/ashera/attributedtext/Interval;Ljava/util/List<Lcom/ashera/attributedtext/Interval;>;)V", "apply", "LASAttributedString;", "LASInterval;LASAttributedString;", "quickConvert", "LNSString;LNSString;", "getValue", "LNSString;LJavaUtilMap;", "(Ljava/lang/String;Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)Ljava/lang/String;", "getStyle", "LASWidgetAttributeMap;", "(Lcom/ashera/widget/WidgetAttributeMap;)Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;", "updateStyleInMap", "LASWidgetAttributeMap;LJavaUtilMap;", "(Lcom/ashera/widget/WidgetAttributeMap;Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)V", "Ljava/util/Set<Ljava/lang/String;>;", "Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;" };
  static const J2ObjcClassInfo _ASAugmentedIntervalTree = { "AugmentedIntervalTree", "com.ashera.attributedtext", ptrTable, methods, fields, 7, 0x1, 14, 5, -1, -1, -1, -1, -1 };
  return &_ASAugmentedIntervalTree;
}

@end

void ASAugmentedIntervalTree_initWithJavaUtilMap_withASIFragment_(ASAugmentedIntervalTree *self, id<JavaUtilMap> htmlConfig, id<ASIFragment> fragment) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->list_, new_JavaUtilHashSet_init());
  JreStrongAssign(&self->fragment_, fragment);
  JreStrongAssign(&self->htmlConfig_, htmlConfig);
  if (self->htmlConfig_ == nil) {
    JreStrongAssignAndConsume(&self->htmlConfig_, new_JavaUtilHashMap_initWithInt_(0));
  }
}

ASAugmentedIntervalTree *new_ASAugmentedIntervalTree_initWithJavaUtilMap_withASIFragment_(id<JavaUtilMap> htmlConfig, id<ASIFragment> fragment) {
  J2OBJC_NEW_IMPL(ASAugmentedIntervalTree, initWithJavaUtilMap_withASIFragment_, htmlConfig, fragment)
}

ASAugmentedIntervalTree *create_ASAugmentedIntervalTree_initWithJavaUtilMap_withASIFragment_(id<JavaUtilMap> htmlConfig, id<ASIFragment> fragment) {
  J2OBJC_CREATE_IMPL(ASAugmentedIntervalTree, initWithJavaUtilMap_withASIFragment_, htmlConfig, fragment)
}

id ASAugmentedIntervalTree_quickConvertWithNSString_withNSString_(ASAugmentedIntervalTree *self, NSString *name, NSString *value) {
  id objcolor = ASPluginInvoker_convertFromWithASIConverter_withJavaUtilMap_withId_withASIFragment_(ASPluginInvoker_getConverterWithNSString_(name), nil, value, self->fragment_);
  return objcolor;
}

NSString *ASAugmentedIntervalTree_getValueWithNSString_withJavaUtilMap_(ASAugmentedIntervalTree *self, NSString *key, id<JavaUtilMap> attributes) {
  NSString *os = [((NSString *) nil_chk(ASPluginInvoker_getOS())) lowercaseString];
  if ([((id<JavaUtilMap>) nil_chk(attributes)) containsKeyWithId:JreStrcat("$C$", key, '-', os)]) {
    return [attributes getWithId:JreStrcat("$C$", key, '-', os)];
  }
  return [attributes getWithId:key];
}

void ASAugmentedIntervalTree_updateStyleInMapWithASWidgetAttributeMap_withJavaUtilMap_(ASAugmentedIntervalTree *self, ASWidgetAttributeMap *inlineStyle, id<JavaUtilMap> attributes) {
  ASWidgetAttributeMap *parent = JreRetainedLocalValue([((ASWidgetAttributeMap *) nil_chk(inlineStyle)) getParent]);
  while (parent != nil) {
    ASAugmentedIntervalTree_updateStyleInMapWithASWidgetAttributeMap_withJavaUtilMap_(self, parent, attributes);
    parent = [parent getParent];
  }
  id<JavaUtilSet> keys = JreRetainedLocalValue([inlineStyle keySet]);
  for (ASWidgetAttribute * __strong widgetAttribute in nil_chk(keys)) {
    id<JavaUtilList> values = JreRetainedLocalValue([inlineStyle getWithId:widgetAttribute]);
    for (ASWidgetAttributeValue * __strong widgetAttributeValue in nil_chk(values)) {
      [((id<JavaUtilMap>) nil_chk(attributes)) putWithId:[((ASWidgetAttribute *) nil_chk(widgetAttribute)) getAttributeName] withId:[((ASWidgetAttributeValue *) nil_chk(widgetAttributeValue)) getValue]];
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ASAugmentedIntervalTree)
