//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\motion\utils\StopLogicEngine.java
//

#include "J2ObjC_source.h"
#include "StopLogicEngine.h"
#include "java/lang/Math.h"


@interface ADXStopLogicEngine () {
 @public
  jfloat mStage1Velocity_;
  jfloat mStage2Velocity_;
  jfloat mStage3Velocity_;
  jfloat mStage1Duration_;
  jfloat mStage2Duration_;
  jfloat mStage3Duration_;
  jfloat mStage1EndPosition_;
  jfloat mStage2EndPosition_;
  jfloat mStage3EndPosition_;
  jint mNumberOfStages_;
  NSString *mType_;
  jboolean mBackwards_;
  jfloat mStartPosition_;
  jfloat mLastPosition_;
  jboolean mDone_;
}

- (jfloat)calcYWithFloat:(jfloat)time;

- (void)setupWithFloat:(jfloat)velocity
             withFloat:(jfloat)distance
             withFloat:(jfloat)maxAcceleration
             withFloat:(jfloat)maxVelocity
             withFloat:(jfloat)maxTime;

@end

J2OBJC_FIELD_SETTER(ADXStopLogicEngine, mType_, NSString *)

inline jfloat ADXStopLogicEngine_get_EPSILON(void);
#define ADXStopLogicEngine_EPSILON 1.0E-5f
J2OBJC_STATIC_FIELD_CONSTANT(ADXStopLogicEngine, EPSILON, jfloat)

__attribute__((unused)) static jfloat ADXStopLogicEngine_calcYWithFloat_(ADXStopLogicEngine *self, jfloat time);

__attribute__((unused)) static void ADXStopLogicEngine_setupWithFloat_withFloat_withFloat_withFloat_withFloat_(ADXStopLogicEngine *self, jfloat velocity, jfloat distance, jfloat maxAcceleration, jfloat maxVelocity, jfloat maxTime);

@implementation ADXStopLogicEngine

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXStopLogicEngine_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (NSString *)debugWithNSString:(NSString *)desc
                      withFloat:(jfloat)time {
  NSString *ret = JreStrcat("$$$C", desc, @" ===== ", mType_, 0x000a);
  JreStrAppend(&ret, "$$$F$IC", desc, (mBackwards_ ? @"backwards" : @"forward "), @" time = ", time, @"  stages ", mNumberOfStages_, 0x000a);
  JreStrAppend(&ret, "$$F$F$FC", desc, @" dur ", mStage1Duration_, @" vel ", mStage1Velocity_, @" pos ", mStage1EndPosition_, 0x000a);
  if (mNumberOfStages_ > 1) {
    JreStrAppend(&ret, "$$F$F$FC", desc, @" dur ", mStage2Duration_, @" vel ", mStage2Velocity_, @" pos ", mStage2EndPosition_, 0x000a);
  }
  if (mNumberOfStages_ > 2) {
    JreStrAppend(&ret, "$$F$F$FC", desc, @" dur ", mStage3Duration_, @" vel ", mStage3Velocity_, @" pos ", mStage3EndPosition_, 0x000a);
  }
  if (time <= mStage1Duration_) {
    JreStrAppend(&ret, "$$", desc, @"stage 0\n");
    return ret;
  }
  if (mNumberOfStages_ == 1) {
    JreStrAppend(&ret, "$$", desc, @"end stage 0\n");
    return ret;
  }
  JreMinusAssignFloatF(&time, mStage1Duration_);
  if (time < mStage2Duration_) {
    JreStrAppend(&ret, "$$", desc, @" stage 1\n");
    return ret;
  }
  if (mNumberOfStages_ == 2) {
    JreStrAppend(&ret, "$$", desc, @"end stage 1\n");
    return ret;
  }
  JreMinusAssignFloatF(&time, mStage2Duration_);
  if (time < mStage3Duration_) {
    JreStrAppend(&ret, "$$", desc, @" stage 2\n");
    return ret;
  }
  JreStrAppend(&ret, "$$", desc, @" end stage 2\n");
  return ret;
}

- (jfloat)getVelocityWithFloat:(jfloat)x {
  if (x <= mStage1Duration_) {
    return mStage1Velocity_ + (mStage2Velocity_ - mStage1Velocity_) * x / (mStage1Duration_);
  }
  if (mNumberOfStages_ == 1) {
    return 0;
  }
  JreMinusAssignFloatF(&x, mStage1Duration_);
  if (x < mStage2Duration_) {
    return mStage2Velocity_ + (mStage3Velocity_ - mStage2Velocity_) * x / (mStage2Duration_);
  }
  if (mNumberOfStages_ == 2) {
    return mStage2EndPosition_;
  }
  JreMinusAssignFloatF(&x, mStage2Duration_);
  if (x < mStage3Duration_) {
    return mStage3Velocity_ - mStage3Velocity_ * x / (mStage3Duration_);
  }
  return mStage3EndPosition_;
}

- (jfloat)calcYWithFloat:(jfloat)time {
  return ADXStopLogicEngine_calcYWithFloat_(self, time);
}

- (void)configWithFloat:(jfloat)currentPos
              withFloat:(jfloat)destination
              withFloat:(jfloat)currentVelocity
              withFloat:(jfloat)maxTime
              withFloat:(jfloat)maxAcceleration
              withFloat:(jfloat)maxVelocity {
  mDone_ = false;
  mStartPosition_ = currentPos;
  mBackwards_ = (currentPos > destination);
  if (mBackwards_) {
    ADXStopLogicEngine_setupWithFloat_withFloat_withFloat_withFloat_withFloat_(self, -currentVelocity, currentPos - destination, maxAcceleration, maxVelocity, maxTime);
  }
  else {
    ADXStopLogicEngine_setupWithFloat_withFloat_withFloat_withFloat_withFloat_(self, currentVelocity, destination - currentPos, maxAcceleration, maxVelocity, maxTime);
  }
}

- (jfloat)getInterpolationWithFloat:(jfloat)v {
  jfloat y = ADXStopLogicEngine_calcYWithFloat_(self, v);
  mLastPosition_ = v;
  return (mBackwards_) ? mStartPosition_ - y : mStartPosition_ + y;
}

- (jfloat)getVelocity {
  return (mBackwards_) ? -[self getVelocityWithFloat:mLastPosition_] : [self getVelocityWithFloat:mLastPosition_];
}

- (jboolean)isStopped {
  return [self getVelocity] < ADXStopLogicEngine_EPSILON && JavaLangMath_absWithFloat_(mStage3EndPosition_ - mLastPosition_) < ADXStopLogicEngine_EPSILON;
}

- (void)setupWithFloat:(jfloat)velocity
             withFloat:(jfloat)distance
             withFloat:(jfloat)maxAcceleration
             withFloat:(jfloat)maxVelocity
             withFloat:(jfloat)maxTime {
  ADXStopLogicEngine_setupWithFloat_withFloat_withFloat_withFloat_withFloat_(self, velocity, distance, maxAcceleration, maxVelocity, maxTime);
}

- (void)dealloc {
  RELEASE_(mType_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "F", 0x2, 4, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "F", 0x1, 7, 3, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 8, 9, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(debugWithNSString:withFloat:);
  methods[2].selector = @selector(getVelocityWithFloat:);
  methods[3].selector = @selector(calcYWithFloat:);
  methods[4].selector = @selector(configWithFloat:withFloat:withFloat:withFloat:withFloat:withFloat:);
  methods[5].selector = @selector(getInterpolationWithFloat:);
  methods[6].selector = @selector(getVelocity);
  methods[7].selector = @selector(isStopped);
  methods[8].selector = @selector(setupWithFloat:withFloat:withFloat:withFloat:withFloat:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mStage1Velocity_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStage2Velocity_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStage3Velocity_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStage1Duration_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStage2Duration_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStage3Duration_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStage1EndPosition_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStage2EndPosition_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStage3EndPosition_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mNumberOfStages_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mType_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mBackwards_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStartPosition_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mLastPosition_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDone_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "EPSILON", "F", .constantValue.asFloat = ADXStopLogicEngine_EPSILON, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "debug", "LNSString;F", "getVelocity", "F", "calcY", "config", "FFFFFF", "getInterpolation", "setup", "FFFFF" };
  static const J2ObjcClassInfo _ADXStopLogicEngine = { "StopLogicEngine", "androidx.constraintlayout.core.motion.utils", ptrTable, methods, fields, 7, 0x1, 9, 16, -1, -1, -1, -1, -1 };
  return &_ADXStopLogicEngine;
}

@end

void ADXStopLogicEngine_init(ADXStopLogicEngine *self) {
  NSObject_init(self);
  self->mBackwards_ = false;
  self->mDone_ = false;
}

ADXStopLogicEngine *new_ADXStopLogicEngine_init() {
  J2OBJC_NEW_IMPL(ADXStopLogicEngine, init)
}

ADXStopLogicEngine *create_ADXStopLogicEngine_init() {
  J2OBJC_CREATE_IMPL(ADXStopLogicEngine, init)
}

jfloat ADXStopLogicEngine_calcYWithFloat_(ADXStopLogicEngine *self, jfloat time) {
  self->mDone_ = false;
  if (time <= self->mStage1Duration_) {
    return self->mStage1Velocity_ * time + (self->mStage2Velocity_ - self->mStage1Velocity_) * time * time / (2 * self->mStage1Duration_);
  }
  if (self->mNumberOfStages_ == 1) {
    return self->mStage1EndPosition_;
  }
  JreMinusAssignFloatF(&time, self->mStage1Duration_);
  if (time < self->mStage2Duration_) {
    return self->mStage1EndPosition_ + self->mStage2Velocity_ * time + (self->mStage3Velocity_ - self->mStage2Velocity_) * time * time / (2 * self->mStage2Duration_);
  }
  if (self->mNumberOfStages_ == 2) {
    return self->mStage2EndPosition_;
  }
  JreMinusAssignFloatF(&time, self->mStage2Duration_);
  if (time <= self->mStage3Duration_) {
    return self->mStage2EndPosition_ + self->mStage3Velocity_ * time - self->mStage3Velocity_ * time * time / (2 * self->mStage3Duration_);
  }
  self->mDone_ = true;
  return self->mStage3EndPosition_;
}

void ADXStopLogicEngine_setupWithFloat_withFloat_withFloat_withFloat_withFloat_(ADXStopLogicEngine *self, jfloat velocity, jfloat distance, jfloat maxAcceleration, jfloat maxVelocity, jfloat maxTime) {
  self->mDone_ = false;
  if (velocity == 0) {
    velocity = 0.0001f;
  }
  self->mStage1Velocity_ = velocity;
  jfloat min_time_to_stop = velocity / maxAcceleration;
  jfloat stopDistance = min_time_to_stop * velocity / 2;
  if (velocity < 0) {
    jfloat timeToZeroVelocity = (-velocity) / maxAcceleration;
    jfloat reversDistanceTraveled = timeToZeroVelocity * velocity / 2;
    jfloat totalDistance = distance - reversDistanceTraveled;
    jfloat peak_v = (jfloat) JavaLangMath_sqrtWithDouble_(maxAcceleration * totalDistance);
    if (peak_v < maxVelocity) {
      JreStrongAssign(&self->mType_, @"backward accelerate, decelerate");
      self->mNumberOfStages_ = 2;
      self->mStage1Velocity_ = velocity;
      self->mStage2Velocity_ = peak_v;
      self->mStage3Velocity_ = 0;
      self->mStage1Duration_ = (peak_v - velocity) / maxAcceleration;
      self->mStage2Duration_ = peak_v / maxAcceleration;
      self->mStage1EndPosition_ = (velocity + peak_v) * self->mStage1Duration_ / 2;
      self->mStage2EndPosition_ = distance;
      self->mStage3EndPosition_ = distance;
      return;
    }
    JreStrongAssign(&self->mType_, @"backward accelerate cruse decelerate");
    self->mNumberOfStages_ = 3;
    self->mStage1Velocity_ = velocity;
    self->mStage2Velocity_ = maxVelocity;
    self->mStage3Velocity_ = maxVelocity;
    self->mStage1Duration_ = (maxVelocity - velocity) / maxAcceleration;
    self->mStage3Duration_ = maxVelocity / maxAcceleration;
    jfloat accDist = (velocity + maxVelocity) * self->mStage1Duration_ / 2;
    jfloat decDist = (maxVelocity * self->mStage3Duration_) / 2;
    self->mStage2Duration_ = (distance - accDist - decDist) / maxVelocity;
    self->mStage1EndPosition_ = accDist;
    self->mStage2EndPosition_ = (distance - decDist);
    self->mStage3EndPosition_ = distance;
    return;
  }
  if (stopDistance >= distance) {
    JreStrongAssign(&self->mType_, @"hard stop");
    jfloat time = 2 * distance / velocity;
    self->mNumberOfStages_ = 1;
    self->mStage1Velocity_ = velocity;
    self->mStage2Velocity_ = 0;
    self->mStage1EndPosition_ = distance;
    self->mStage1Duration_ = time;
    return;
  }
  jfloat distance_before_break = distance - stopDistance;
  jfloat cruseTime = distance_before_break / velocity;
  if (cruseTime + min_time_to_stop < maxTime) {
    JreStrongAssign(&self->mType_, @"cruse decelerate");
    self->mNumberOfStages_ = 2;
    self->mStage1Velocity_ = velocity;
    self->mStage2Velocity_ = velocity;
    self->mStage3Velocity_ = 0;
    self->mStage1EndPosition_ = distance_before_break;
    self->mStage2EndPosition_ = distance;
    self->mStage1Duration_ = cruseTime;
    self->mStage2Duration_ = velocity / maxAcceleration;
    return;
  }
  jfloat peak_v = (jfloat) JavaLangMath_sqrtWithDouble_(maxAcceleration * distance + velocity * velocity / 2);
  self->mStage1Duration_ = (peak_v - velocity) / maxAcceleration;
  self->mStage2Duration_ = peak_v / maxAcceleration;
  if (peak_v < maxVelocity) {
    JreStrongAssign(&self->mType_, @"accelerate decelerate");
    self->mNumberOfStages_ = 2;
    self->mStage1Velocity_ = velocity;
    self->mStage2Velocity_ = peak_v;
    self->mStage3Velocity_ = 0;
    self->mStage1Duration_ = (peak_v - velocity) / maxAcceleration;
    self->mStage2Duration_ = peak_v / maxAcceleration;
    self->mStage1EndPosition_ = (velocity + peak_v) * self->mStage1Duration_ / 2;
    self->mStage2EndPosition_ = distance;
    return;
  }
  JreStrongAssign(&self->mType_, @"accelerate cruse decelerate");
  self->mNumberOfStages_ = 3;
  self->mStage1Velocity_ = velocity;
  self->mStage2Velocity_ = maxVelocity;
  self->mStage3Velocity_ = maxVelocity;
  self->mStage1Duration_ = (maxVelocity - velocity) / maxAcceleration;
  self->mStage3Duration_ = maxVelocity / maxAcceleration;
  jfloat accDist = (velocity + maxVelocity) * self->mStage1Duration_ / 2;
  jfloat decDist = (maxVelocity * self->mStage3Duration_) / 2;
  self->mStage2Duration_ = (distance - accDist - decDist) / maxVelocity;
  self->mStage1EndPosition_ = accDist;
  self->mStage2EndPosition_ = (distance - decDist);
  self->mStage3EndPosition_ = distance;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXStopLogicEngine)
