//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroid\src\main\java\com\ashera\view\BaseMeasurableImageView.java
//

#include "BaseMeasurableImageView.h"
#include "Drawable.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "IWidget.h"
#include "IsImage.h"
#include "J2ObjC_source.h"
#include "RectM.h"
#include "View.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"


@interface ASBaseMeasurableImageView () {
 @public
  __unsafe_unretained id<ASIWidget> widget_;
  jboolean mAdjustViewBoundsCompat_;
  jboolean mAdjustViewBounds_;
  id mDrawable_;
  jint mDrawableWidth_;
  jint mDrawableHeight_;
  jint mMaxWidth_;
  jint mMaxHeight_;
  jint mBaseline_;
  jboolean mBaselineAlignBottom_;
  jboolean cropToPadding_;
  jboolean usePaddingForBounds_;
  NSString *scaleType_;
  jint scaleTypeInt_;
  ADDrawable *imageDrawable_;
}

- (void)resolveUri;

- (void)updateDrawable;

- (jint)resolveAdjustedSizeWithInt:(jint)desiredSize
                           withInt:(jint)maxSize
                           withInt:(jint)measureSpec;

@end

J2OBJC_FIELD_SETTER(ASBaseMeasurableImageView, mDrawable_, id)
J2OBJC_FIELD_SETTER(ASBaseMeasurableImageView, scaleType_, NSString *)
J2OBJC_FIELD_SETTER(ASBaseMeasurableImageView, imageDrawable_, ADDrawable *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_FITXY(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_FITXY = @"fitXY";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_FITXY, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_CENTERINSIDE(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_CENTERINSIDE = @"centerInside";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_CENTERINSIDE, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_CENTER(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_CENTER = @"center";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_CENTER, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_CENTERCROP(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_CENTERCROP = @"centerCrop";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_CENTERCROP, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_FITEND(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_FITEND = @"fitEnd";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_FITEND, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_FITSTART(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_FITSTART = @"fitStart";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_FITSTART, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_FITCENTER(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_FITCENTER = @"fitCenter";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_FITCENTER, NSString *)

__attribute__((unused)) static void ASBaseMeasurableImageView_resolveUri(ASBaseMeasurableImageView *self);

__attribute__((unused)) static void ASBaseMeasurableImageView_updateDrawable(ASBaseMeasurableImageView *self);

__attribute__((unused)) static jint ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(ASBaseMeasurableImageView *self, jint desiredSize, jint maxSize, jint measureSpec);

@implementation ASBaseMeasurableImageView

- (jint)getScaleTypeInt {
  return scaleTypeInt_;
}

- (NSString *)getScaleType {
  return scaleType_;
}

- (void)setScaleTypeWithNSString:(NSString *)scaleType
                         withInt:(jint)scaleTypeInt {
  JreStrongAssign(&self->scaleType_, scaleType);
  self->scaleTypeInt_ = scaleTypeInt;
}

- (void)setUsePaddingForBoundsWithBoolean:(jboolean)usePaddingForBounds {
  self->usePaddingForBounds_ = usePaddingForBounds;
}

- (void)setCropToPaddingWithBoolean:(jboolean)objValue {
  self->cropToPadding_ = objValue;
}

- (jboolean)getCropToPadding {
  return cropToPadding_;
}

- (instancetype)initWithASIWidget:(id<ASIWidget>)widget {
  ASBaseMeasurableImageView_initWithASIWidget_(self, widget);
  return self;
}

- (id<ASIWidget>)getWidget {
  return widget_;
}

- (void)onMeasureWithInt:(jint)widthMeasureSpec
                 withInt:(jint)heightMeasureSpec {
  ASBaseMeasurableImageView_resolveUri(self);
  jint w;
  jint h;
  jfloat desiredAspect = 0.0f;
  jboolean resizeWidth = false;
  jboolean resizeHeight = false;
  jint widthSpecMode = ADView_MeasureSpec_getModeWithInt_(widthMeasureSpec);
  jint heightSpecMode = ADView_MeasureSpec_getModeWithInt_(heightMeasureSpec);
  if (mDrawable_ == nil) {
    mDrawableWidth_ = -1;
    mDrawableHeight_ = -1;
    w = h = 0;
  }
  else {
    w = mDrawableWidth_;
    h = mDrawableHeight_;
    if (w <= 0) w = 1;
    if (h <= 0) h = 1;
    if (mAdjustViewBounds_) {
      resizeWidth = (widthSpecMode != ADView_MeasureSpec_EXACTLY);
      resizeHeight = (heightSpecMode != ADView_MeasureSpec_EXACTLY);
      desiredAspect = (jfloat) w / (jfloat) h;
    }
  }
  jint pleft = mPaddingLeft_;
  jint pright = mPaddingRight_;
  jint ptop = mPaddingTop_;
  jint pbottom = mPaddingBottom_;
  jint widthSize;
  jint heightSize;
  if (resizeWidth || resizeHeight) {
    widthSize = ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, w + pleft + pright, mMaxWidth_, widthMeasureSpec);
    heightSize = ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, h + ptop + pbottom, mMaxHeight_, heightMeasureSpec);
    if (desiredAspect != 0.0f) {
      jfloat actualAspect = (jfloat) (widthSize - pleft - pright) / (heightSize - ptop - pbottom);
      if (JavaLangMath_absWithFloat_(actualAspect - desiredAspect) > 0.0000001) {
        jboolean done = false;
        if (resizeWidth) {
          jint newWidth = JreFpToInt((desiredAspect * (heightSize - ptop - pbottom))) + pleft + pright;
          if (!resizeHeight && !mAdjustViewBoundsCompat_) {
            widthSize = ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, newWidth, mMaxWidth_, widthMeasureSpec);
          }
          if (newWidth <= widthSize) {
            widthSize = newWidth;
            done = true;
          }
        }
        if (!done && resizeHeight) {
          jint newHeight = JreFpToInt(((widthSize - pleft - pright) / desiredAspect)) + ptop + pbottom;
          if (!resizeWidth && !mAdjustViewBoundsCompat_) {
            heightSize = ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, newHeight, mMaxHeight_, heightMeasureSpec);
          }
          if (newHeight <= heightSize) {
            heightSize = newHeight;
          }
        }
      }
    }
  }
  else {
    w += pleft + pright;
    h += ptop + pbottom;
    w = JavaLangMath_maxWithInt_withInt_(w, [self getSuggestedMinimumWidth]);
    h = JavaLangMath_maxWithInt_withInt_(h, [self getSuggestedMinimumHeight]);
    widthSize = ADView_resolveSizeAndStateWithInt_withInt_withInt_(w, widthMeasureSpec, 0);
    heightSize = ADView_resolveSizeAndStateWithInt_withInt_withInt_(h, heightMeasureSpec, 0);
  }
  [self setMeasuredDimensionWithInt:widthSize withInt:heightSize];
}

- (void)resolveUri {
  ASBaseMeasurableImageView_resolveUri(self);
}

- (void)updateDrawable {
  ASBaseMeasurableImageView_updateDrawable(self);
}

- (jint)resolveAdjustedSizeWithInt:(jint)desiredSize
                           withInt:(jint)maxSize
                           withInt:(jint)measureSpec {
  return ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, desiredSize, maxSize, measureSpec);
}

- (void)setAdjustViewBoundsWithBoolean:(jboolean)mAdjustViewBounds {
  self->mAdjustViewBounds_ = mAdjustViewBounds;
}

- (jboolean)getAdjustViewBounds {
  return mAdjustViewBounds_;
}

- (jint)getMaxWidth {
  return mMaxWidth_;
}

- (jint)getMaxHeight {
  return mMaxHeight_;
}

- (void)setMaxWidthWithInt:(jint)mMaxWidth {
  self->mMaxWidth_ = mMaxWidth;
}

- (void)setMaxHeightWithInt:(jint)mMaxHeight {
  self->mMaxHeight_ = mMaxHeight;
}

- (jint)getBaseline {
  if (mBaselineAlignBottom_) {
    return [self getMeasuredHeight];
  }
  else {
    return mBaseline_;
  }
}

- (void)setBaselineWithInt:(jint)baseline {
  if (mBaseline_ != baseline) {
    mBaseline_ = baseline;
    [self requestLayout];
  }
}

- (void)setBaselineAlignBottomWithBoolean:(jboolean)aligned {
  if (mBaselineAlignBottom_ != aligned) {
    mBaselineAlignBottom_ = aligned;
    [self requestLayout];
  }
}

- (jboolean)getBaselineAlignBottom {
  return mBaselineAlignBottom_;
}

- (ASRectM *)getCropPaddingClipBounds {
  jint pLeft = 0;
  jint pTop = 0;
  jint pRight = 0;
  jint pBottom = 0;
  if (usePaddingForBounds_) {
    pLeft = [self getPaddingStart];
    pRight = [self getPaddingEnd];
    pTop = [self getPaddingTop];
    pBottom = [self getPaddingBottom];
  }
  jint vwidth = [self getMeasuredWidth] - pLeft - pRight;
  jint vheight = [self getMeasuredHeight] - pTop - pBottom;
  return create_ASRectM_initWithInt_withInt_withInt_withInt_(pLeft, pTop, vwidth, vheight);
}

- (ASRectM *)getImageBounds {
  jint measuredWidth = [self getMeasuredWidth];
  jint measuredHeight = [self getMeasuredHeight];
  return [self getImageBoundsWithInt:measuredWidth withInt:measuredHeight];
}

- (ASRectM *)getImageBoundsWithInt:(jint)measuredWidth
                           withInt:(jint)measuredHeight {
  if (mDrawableWidth_ == 0 && mDrawableHeight_ == 0) return nil;
  jint dwidth = mDrawableWidth_;
  jint dheight = mDrawableHeight_;
  jint pLeft = 0;
  jint pTop = 0;
  jint pRight = 0;
  jint pBottom = 0;
  if (usePaddingForBounds_) {
    pLeft = [self getPaddingStart];
    pRight = [self getPaddingEnd];
    pTop = [self getPaddingTop];
    pBottom = [self getPaddingBottom];
  }
  jfloat dx = 0;
  jfloat dy = 0;
  jint vwidth = measuredWidth - pLeft - pRight;
  jint vheight = measuredHeight - pTop - pBottom;
  jint newHeight = vheight;
  jint newWidth = vwidth;
  switch (JreIndexOfStr(scaleType_, (id[]){ ASBaseMeasurableImageView_SCALETYPE_FITXY, ASBaseMeasurableImageView_SCALETYPE_FITCENTER, ASBaseMeasurableImageView_SCALETYPE_FITSTART, ASBaseMeasurableImageView_SCALETYPE_FITEND, ASBaseMeasurableImageView_SCALETYPE_CENTERCROP, ASBaseMeasurableImageView_SCALETYPE_CENTER, ASBaseMeasurableImageView_SCALETYPE_CENTERINSIDE }, 7)) {
    case 0:
    {
      newWidth = vwidth;
      newHeight = vheight;
      break;
    }
    case 1:
    {
      newWidth = JreIntDiv((dwidth * vheight), dheight);
      newHeight = vheight;
      if (newWidth > vwidth) {
        newWidth = vwidth;
        newHeight = JreIntDiv((dheight * vwidth), dwidth);
      }
      dx = JavaLangMath_absWithInt_(newWidth - vwidth) * 0.5f;
      dy = JavaLangMath_absWithInt_(newHeight - vheight) * 0.5f;
      break;
    }
    case 2:
    {
      newWidth = JreIntDiv((dwidth * vheight), dheight);
      newHeight = vheight;
      if (newWidth > vwidth) {
        newWidth = vwidth;
        newHeight = JreIntDiv((dheight * vwidth), dwidth);
      }
      break;
    }
    case 3:
    {
      newWidth = JreIntDiv((dwidth * vheight), dheight);
      newHeight = vheight;
      if (newWidth > vwidth) {
        newWidth = vwidth;
        newHeight = JreIntDiv((dheight * vwidth), dwidth);
      }
      dx = JavaLangMath_absWithInt_(newWidth - vwidth);
      dy = JavaLangMath_absWithInt_(newHeight - vheight);
    }
    break;
    case 4:
    {
      jfloat scale_;
      if (dwidth * vheight > vwidth * dheight) {
        scale_ = (jfloat) vheight / (jfloat) dheight;
        dx = (vwidth - dwidth * scale_) * 0.5f;
      }
      else {
        scale_ = (jfloat) vwidth / (jfloat) dwidth;
        dy = (vheight - dheight * scale_) * 0.5f;
      }
      newWidth = JreFpToInt((dwidth * scale_));
      newHeight = JreFpToInt((dheight * scale_));
      break;
    }
    case 5:
    {
      dx = JavaLangMath_roundWithFloat_((vwidth - dwidth) * 0.5f);
      dy = JavaLangMath_roundWithFloat_((vheight - dheight) * 0.5f);
      newWidth = dwidth;
      newHeight = dheight;
      break;
    }
    case 6:
    {
      jfloat scale_;
      if (dwidth <= vwidth && dheight <= vheight) {
        scale_ = 1.0f;
      }
      else {
        scale_ = JavaLangMath_minWithFloat_withFloat_((jfloat) vwidth / (jfloat) dwidth, (jfloat) vheight / (jfloat) dheight);
      }
      dx = JavaLangMath_roundWithFloat_((vwidth - dwidth * scale_) * 0.5f);
      dy = JavaLangMath_roundWithFloat_((vheight - dheight * scale_) * 0.5f);
      newWidth = JreFpToInt((dwidth * scale_));
      newHeight = JreFpToInt((dheight * scale_));
      break;
    }
    default:
    break;
  }
  JrePlusAssignFloatF(&dx, pLeft);
  JrePlusAssignFloatF(&dy, pTop);
  return create_ASRectM_initWithInt_withInt_withInt_withInt_(JreFpToInt(dx), JreFpToInt(dy), newWidth, newHeight);
}

- (jboolean)hasDrawables {
  return false;
}

- (ADDrawable *)getImageDrawable {
  return imageDrawable_;
}

- (void)setImageDrawableWithADDrawable:(ADDrawable *)imageDrawable {
  JreStrongAssign(&self->imageDrawable_, imageDrawable);
}

- (void)__javaClone:(ASBaseMeasurableImageView *)original {
  [super __javaClone:original];
  [widget_ release];
}

- (void)dealloc {
  RELEASE_(mDrawable_);
  RELEASE_(scaleType_);
  RELEASE_(imageDrawable_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 5, -1, -1, -1, -1 },
    { NULL, "LASIWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 12, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 14, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 15, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LASRectM;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LASRectM;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LASRectM;", 0x1, 16, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADDrawable;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 17, 18, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(getScaleTypeInt);
  methods[1].selector = @selector(getScaleType);
  methods[2].selector = @selector(setScaleTypeWithNSString:withInt:);
  methods[3].selector = @selector(setUsePaddingForBoundsWithBoolean:);
  methods[4].selector = @selector(setCropToPaddingWithBoolean:);
  methods[5].selector = @selector(getCropToPadding);
  methods[6].selector = @selector(initWithASIWidget:);
  methods[7].selector = @selector(getWidget);
  methods[8].selector = @selector(onMeasureWithInt:withInt:);
  methods[9].selector = @selector(resolveUri);
  methods[10].selector = @selector(updateDrawable);
  methods[11].selector = @selector(resolveAdjustedSizeWithInt:withInt:withInt:);
  methods[12].selector = @selector(setAdjustViewBoundsWithBoolean:);
  methods[13].selector = @selector(getAdjustViewBounds);
  methods[14].selector = @selector(getMaxWidth);
  methods[15].selector = @selector(getMaxHeight);
  methods[16].selector = @selector(setMaxWidthWithInt:);
  methods[17].selector = @selector(setMaxHeightWithInt:);
  methods[18].selector = @selector(getBaseline);
  methods[19].selector = @selector(setBaselineWithInt:);
  methods[20].selector = @selector(setBaselineAlignBottomWithBoolean:);
  methods[21].selector = @selector(getBaselineAlignBottom);
  methods[22].selector = @selector(getCropPaddingClipBounds);
  methods[23].selector = @selector(getImageBounds);
  methods[24].selector = @selector(getImageBoundsWithInt:withInt:);
  methods[25].selector = @selector(hasDrawables);
  methods[26].selector = @selector(getImageDrawable);
  methods[27].selector = @selector(setImageDrawableWithADDrawable:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "widget_", "LASIWidget;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAdjustViewBoundsCompat_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAdjustViewBounds_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDrawable_", "LNSObject;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDrawableWidth_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDrawableHeight_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mMaxWidth_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mMaxHeight_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mBaseline_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mBaselineAlignBottom_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "cropToPadding_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "usePaddingForBounds_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "scaleType_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "scaleTypeInt_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "SCALETYPE_FITXY", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 19, -1, -1 },
    { "SCALETYPE_CENTERINSIDE", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 20, -1, -1 },
    { "SCALETYPE_CENTER", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 21, -1, -1 },
    { "SCALETYPE_CENTERCROP", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 22, -1, -1 },
    { "SCALETYPE_FITEND", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 23, -1, -1 },
    { "SCALETYPE_FITSTART", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 24, -1, -1 },
    { "SCALETYPE_FITCENTER", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 25, -1, -1 },
    { "imageDrawable_", "LADDrawable;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "setScaleType", "LNSString;I", "setUsePaddingForBounds", "Z", "setCropToPadding", "LASIWidget;", "onMeasure", "II", "resolveAdjustedSize", "III", "setAdjustViewBounds", "setMaxWidth", "I", "setMaxHeight", "setBaseline", "setBaselineAlignBottom", "getImageBounds", "setImageDrawable", "LADDrawable;", &ASBaseMeasurableImageView_SCALETYPE_FITXY, &ASBaseMeasurableImageView_SCALETYPE_CENTERINSIDE, &ASBaseMeasurableImageView_SCALETYPE_CENTER, &ASBaseMeasurableImageView_SCALETYPE_CENTERCROP, &ASBaseMeasurableImageView_SCALETYPE_FITEND, &ASBaseMeasurableImageView_SCALETYPE_FITSTART, &ASBaseMeasurableImageView_SCALETYPE_FITCENTER };
  static const J2ObjcClassInfo _ASBaseMeasurableImageView = { "BaseMeasurableImageView", "com.ashera.view", ptrTable, methods, fields, 7, 0x401, 28, 22, -1, -1, -1, -1, -1 };
  return &_ASBaseMeasurableImageView;
}

@end

void ASBaseMeasurableImageView_initWithASIWidget_(ASBaseMeasurableImageView *self, id<ASIWidget> widget) {
  ADView_init(self);
  self->mAdjustViewBounds_ = false;
  self->mMaxWidth_ = JavaLangInteger_MAX_VALUE;
  self->mMaxHeight_ = JavaLangInteger_MAX_VALUE;
  self->mBaseline_ = -1;
  self->mBaselineAlignBottom_ = false;
  self->usePaddingForBounds_ = true;
  JreStrongAssign(&self->scaleType_, ASBaseMeasurableImageView_SCALETYPE_FITCENTER);
  self->widget_ = widget;
}

void ASBaseMeasurableImageView_resolveUri(ASBaseMeasurableImageView *self) {
  ASBaseMeasurableImageView_updateDrawable(self);
}

void ASBaseMeasurableImageView_updateDrawable(ASBaseMeasurableImageView *self) {
  id<ASIsImage> image = (id<ASIsImage>) cast_check(self->widget_, ASIsImage_class_());
  IOSIntArray *dimension = [((id<ASIsImage>) nil_chk(image)) getImageDimension];
  self->mDrawableWidth_ = (jint) IOSIntArray_Get(nil_chk(dimension), 0);
  self->mDrawableHeight_ = (jint) IOSIntArray_Get(dimension, 1);
  JreStrongAssign(&self->mDrawable_, [image getImage]);
}

jint ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(ASBaseMeasurableImageView *self, jint desiredSize, jint maxSize, jint measureSpec) {
  jint result = desiredSize;
  jint specMode = ADView_MeasureSpec_getModeWithInt_(measureSpec);
  jint specSize = ADView_MeasureSpec_getSizeWithInt_(measureSpec);
  switch (specMode) {
    case ADView_MeasureSpec_UNSPECIFIED:
    result = JavaLangMath_minWithInt_withInt_(desiredSize, maxSize);
    break;
    case ADView_MeasureSpec_AT_MOST:
    result = JavaLangMath_minWithInt_withInt_(JavaLangMath_minWithInt_withInt_(desiredSize, specSize), maxSize);
    break;
    case ADView_MeasureSpec_EXACTLY:
    result = specSize;
    break;
  }
  return result;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ASBaseMeasurableImageView)
