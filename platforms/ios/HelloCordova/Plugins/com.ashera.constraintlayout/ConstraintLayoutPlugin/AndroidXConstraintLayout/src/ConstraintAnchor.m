//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\widgets\ConstraintAnchor.java
//

#include "Cache.h"
#include "ConstraintAnchor.h"
#include "ConstraintWidget.h"
#include "CoreGuideline.h"
#include "Grouping.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "SolverVariable.h"
#include "WidgetGroup.h"
#include "java/lang/AssertionError.h"
#include "java/lang/Enum.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/util/ArrayList.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"

@class JavaUtilHashSet;


@interface ADXConstraintAnchor () {
 @public
  JavaUtilHashSet *mDependents_;
  jint mFinalValue_;
  jboolean mHasFinalValue_;
}

/*!
 @brief Recursive with check for loop
 @param target
 @param checked set of things already checked
 @return true if it is connected to me
 */
- (jboolean)isConnectionToMeWithADXConstraintWidget:(ADXConstraintWidget *)target
                                withJavaUtilHashSet:(JavaUtilHashSet *)checked;

@end

J2OBJC_FIELD_SETTER(ADXConstraintAnchor, mDependents_, JavaUtilHashSet *)

inline jboolean ADXConstraintAnchor_get_ALLOW_BINARY(void);
#define ADXConstraintAnchor_ALLOW_BINARY false
J2OBJC_STATIC_FIELD_CONSTANT(ADXConstraintAnchor, ALLOW_BINARY, jboolean)

inline jint ADXConstraintAnchor_get_UNSET_GONE_MARGIN(void);
#define ADXConstraintAnchor_UNSET_GONE_MARGIN ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(ADXConstraintAnchor, UNSET_GONE_MARGIN, jint)

__attribute__((unused)) static jboolean ADXConstraintAnchor_isConnectionToMeWithADXConstraintWidget_withJavaUtilHashSet_(ADXConstraintAnchor *self, ADXConstraintWidget *target, JavaUtilHashSet *checked);

__attribute__((unused)) static ADXConstraintAnchor *ADXConstraintAnchor_getOpposite(ADXConstraintAnchor *self);

__attribute__((unused)) static void ADXConstraintAnchor_Type_initWithNSString_withInt_(ADXConstraintAnchor_Type *self, NSString *__name, jint __ordinal);

@implementation ADXConstraintAnchor

- (void)findDependentsWithInt:(jint)orientation
        withJavaUtilArrayList:(JavaUtilArrayList *)list
           withADXWidgetGroup:(ADXWidgetGroup *)group {
  if (mDependents_ != nil) {
    for (ADXConstraintAnchor * __strong anchor in mDependents_) {
      ADXGrouping_findDependentsWithADXConstraintWidget_withInt_withJavaUtilArrayList_withADXWidgetGroup_(((ADXConstraintAnchor *) nil_chk(anchor))->mOwner_, orientation, list, group);
    }
  }
}

- (JavaUtilHashSet *)getDependents {
  return mDependents_;
}

- (jboolean)hasDependents {
  if (mDependents_ == nil) {
    return false;
  }
  return [mDependents_ size] > 0;
}

- (jboolean)hasCenteredDependents {
  if (mDependents_ == nil) {
    return false;
  }
  for (ADXConstraintAnchor * __strong anchor in mDependents_) {
    ADXConstraintAnchor *opposite = ADXConstraintAnchor_getOpposite(nil_chk(anchor));
    if ([((ADXConstraintAnchor *) nil_chk(opposite)) isConnected]) {
      return true;
    }
  }
  return false;
}

- (void)setFinalValueWithInt:(jint)finalValue {
  self->mFinalValue_ = finalValue;
  self->mHasFinalValue_ = true;
}

- (jint)getFinalValue {
  if (!mHasFinalValue_) {
    return 0;
  }
  return mFinalValue_;
}

- (void)resetFinalResolution {
  mHasFinalValue_ = false;
  mFinalValue_ = 0;
}

- (jboolean)hasFinalValue {
  return mHasFinalValue_;
}

- (void)copyFromWithADXConstraintAnchor:(ADXConstraintAnchor *)source
                    withJavaUtilHashMap:(JavaUtilHashMap *)map {
  if (mTarget_ != nil) {
    if (mTarget_->mDependents_ != nil) {
      [mTarget_->mDependents_ removeWithId:self];
    }
  }
  if (((ADXConstraintAnchor *) nil_chk(source))->mTarget_ != nil) {
    ADXConstraintAnchor_Type *type = JreRetainedLocalValue([source->mTarget_ getType]);
    ADXConstraintWidget *owner = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(map)) getWithId:((ADXConstraintAnchor *) nil_chk(source->mTarget_))->mOwner_]);
    mTarget_ = [((ADXConstraintWidget *) nil_chk(owner)) getAnchorWithADXConstraintAnchor_Type:type];
  }
  else {
    mTarget_ = nil;
  }
  if (mTarget_ != nil) {
    if (mTarget_->mDependents_ == nil) {
      JreStrongAssignAndConsume(&mTarget_->mDependents_, new_JavaUtilHashSet_init());
    }
    [((ADXConstraintAnchor *) nil_chk(mTarget_))->mDependents_ addWithId:self];
  }
  mMargin_ = source->mMargin_;
  mGoneMargin_ = source->mGoneMargin_;
}

- (instancetype)initWithADXConstraintWidget:(ADXConstraintWidget *)owner
               withADXConstraintAnchor_Type:(ADXConstraintAnchor_Type *)type {
  ADXConstraintAnchor_initWithADXConstraintWidget_withADXConstraintAnchor_Type_(self, owner, type);
  return self;
}

- (ADXSolverVariable *)getSolverVariable {
  return mSolverVariable_;
}

- (void)resetSolverVariableWithADXCache:(ADXCache *)cache {
  if (mSolverVariable_ == nil) {
    JreStrongAssignAndConsume(&mSolverVariable_, new_ADXSolverVariable_initWithADXSolverVariable_Type_withNSString_(JreLoadEnum(ADXSolverVariable_Type, UNRESTRICTED), nil));
  }
  else {
    [mSolverVariable_ reset];
  }
}

- (ADXConstraintWidget *)getOwner {
  return mOwner_;
}

- (ADXConstraintAnchor_Type *)getType {
  return mType_;
}

- (jint)getMargin {
  if ([((ADXConstraintWidget *) nil_chk(mOwner_)) getVisibility] == ADXConstraintWidget_GONE) {
    return 0;
  }
  if (mGoneMargin_ != ADXConstraintAnchor_UNSET_GONE_MARGIN && mTarget_ != nil && [mTarget_->mOwner_ getVisibility] == ADXConstraintWidget_GONE) {
    return mGoneMargin_;
  }
  return mMargin_;
}

- (ADXConstraintAnchor *)getTarget {
  return mTarget_;
}

- (void)reset {
  if (mTarget_ != nil && mTarget_->mDependents_ != nil) {
    [mTarget_->mDependents_ removeWithId:self];
    if ([((JavaUtilHashSet *) nil_chk(((ADXConstraintAnchor *) nil_chk(mTarget_))->mDependents_)) size] == 0) {
      JreStrongAssign(&((ADXConstraintAnchor *) nil_chk(mTarget_))->mDependents_, nil);
    }
  }
  JreStrongAssign(&mDependents_, nil);
  mTarget_ = nil;
  mMargin_ = 0;
  mGoneMargin_ = ADXConstraintAnchor_UNSET_GONE_MARGIN;
  mHasFinalValue_ = false;
  mFinalValue_ = 0;
}

- (jboolean)connectWithADXConstraintAnchor:(ADXConstraintAnchor *)toAnchor
                                   withInt:(jint)margin
                                   withInt:(jint)goneMargin
                               withBoolean:(jboolean)forceConnection {
  if (toAnchor == nil) {
    [self reset];
    return true;
  }
  if (!forceConnection && ![self isValidConnectionWithADXConstraintAnchor:toAnchor]) {
    return false;
  }
  mTarget_ = toAnchor;
  if (mTarget_->mDependents_ == nil) {
    JreStrongAssignAndConsume(&mTarget_->mDependents_, new_JavaUtilHashSet_init());
  }
  if (((ADXConstraintAnchor *) nil_chk(mTarget_))->mDependents_ != nil) {
    [mTarget_->mDependents_ addWithId:self];
  }
  mMargin_ = margin;
  mGoneMargin_ = goneMargin;
  return true;
}

- (jboolean)connectWithADXConstraintAnchor:(ADXConstraintAnchor *)toAnchor
                                   withInt:(jint)margin {
  return [self connectWithADXConstraintAnchor:toAnchor withInt:margin withInt:ADXConstraintAnchor_UNSET_GONE_MARGIN withBoolean:false];
}

- (jboolean)isConnected {
  return mTarget_ != nil;
}

- (jboolean)isValidConnectionWithADXConstraintAnchor:(ADXConstraintAnchor *)anchor {
  if (anchor == nil) {
    return false;
  }
  ADXConstraintAnchor_Type *target = JreRetainedLocalValue([anchor getType]);
  if (target == mType_) {
    if (mType_ == JreLoadEnum(ADXConstraintAnchor_Type, BASELINE) && (![((ADXConstraintWidget *) nil_chk([anchor getOwner])) hasBaseline] || ![((ADXConstraintWidget *) nil_chk([self getOwner])) hasBaseline])) {
      return false;
    }
    return true;
  }
  switch ([mType_ ordinal]) {
    case ADXConstraintAnchor_Type_Enum_CENTER:
    {
      return target != JreLoadEnum(ADXConstraintAnchor_Type, BASELINE) && target != JreLoadEnum(ADXConstraintAnchor_Type, CENTER_X) && target != JreLoadEnum(ADXConstraintAnchor_Type, CENTER_Y);
    }
    case ADXConstraintAnchor_Type_Enum_LEFT:
    case ADXConstraintAnchor_Type_Enum_RIGHT:
    {
      jboolean isCompatible = target == JreLoadEnum(ADXConstraintAnchor_Type, LEFT) || target == JreLoadEnum(ADXConstraintAnchor_Type, RIGHT);
      if ([[anchor getOwner] isKindOfClass:[ADXCoreGuideline class]]) {
        isCompatible = (isCompatible || target == JreLoadEnum(ADXConstraintAnchor_Type, CENTER_X));
      }
      return isCompatible;
    }
    case ADXConstraintAnchor_Type_Enum_TOP:
    case ADXConstraintAnchor_Type_Enum_BOTTOM:
    {
      jboolean isCompatible = target == JreLoadEnum(ADXConstraintAnchor_Type, TOP) || target == JreLoadEnum(ADXConstraintAnchor_Type, BOTTOM);
      if ([[anchor getOwner] isKindOfClass:[ADXCoreGuideline class]]) {
        isCompatible = (isCompatible || target == JreLoadEnum(ADXConstraintAnchor_Type, CENTER_Y));
      }
      return isCompatible;
    }
    case ADXConstraintAnchor_Type_Enum_BASELINE:
    {
      if (target == JreLoadEnum(ADXConstraintAnchor_Type, LEFT) || target == JreLoadEnum(ADXConstraintAnchor_Type, RIGHT)) {
        return false;
      }
      return true;
    }
    case ADXConstraintAnchor_Type_Enum_CENTER_X:
    case ADXConstraintAnchor_Type_Enum_CENTER_Y:
    case ADXConstraintAnchor_Type_Enum_NONE:
    return false;
  }
  @throw create_JavaLangAssertionError_initWithId_([((ADXConstraintAnchor_Type *) nil_chk(mType_)) name]);
}

- (jboolean)isSideAnchor {
  switch ([mType_ ordinal]) {
    case ADXConstraintAnchor_Type_Enum_LEFT:
    case ADXConstraintAnchor_Type_Enum_RIGHT:
    case ADXConstraintAnchor_Type_Enum_TOP:
    case ADXConstraintAnchor_Type_Enum_BOTTOM:
    return true;
    case ADXConstraintAnchor_Type_Enum_BASELINE:
    case ADXConstraintAnchor_Type_Enum_CENTER:
    case ADXConstraintAnchor_Type_Enum_CENTER_X:
    case ADXConstraintAnchor_Type_Enum_CENTER_Y:
    case ADXConstraintAnchor_Type_Enum_NONE:
    return false;
  }
  @throw create_JavaLangAssertionError_initWithId_([((ADXConstraintAnchor_Type *) nil_chk(mType_)) name]);
}

- (jboolean)isSimilarDimensionConnectionWithADXConstraintAnchor:(ADXConstraintAnchor *)anchor {
  ADXConstraintAnchor_Type *target = JreRetainedLocalValue([((ADXConstraintAnchor *) nil_chk(anchor)) getType]);
  if (target == mType_) {
    return true;
  }
  switch ([mType_ ordinal]) {
    case ADXConstraintAnchor_Type_Enum_CENTER:
    {
      return target != JreLoadEnum(ADXConstraintAnchor_Type, BASELINE);
    }
    case ADXConstraintAnchor_Type_Enum_LEFT:
    case ADXConstraintAnchor_Type_Enum_RIGHT:
    case ADXConstraintAnchor_Type_Enum_CENTER_X:
    {
      return target == JreLoadEnum(ADXConstraintAnchor_Type, LEFT) || target == JreLoadEnum(ADXConstraintAnchor_Type, RIGHT) || target == JreLoadEnum(ADXConstraintAnchor_Type, CENTER_X);
    }
    case ADXConstraintAnchor_Type_Enum_TOP:
    case ADXConstraintAnchor_Type_Enum_BOTTOM:
    case ADXConstraintAnchor_Type_Enum_CENTER_Y:
    case ADXConstraintAnchor_Type_Enum_BASELINE:
    {
      return target == JreLoadEnum(ADXConstraintAnchor_Type, TOP) || target == JreLoadEnum(ADXConstraintAnchor_Type, BOTTOM) || target == JreLoadEnum(ADXConstraintAnchor_Type, CENTER_Y) || target == JreLoadEnum(ADXConstraintAnchor_Type, BASELINE);
    }
    case ADXConstraintAnchor_Type_Enum_NONE:
    return false;
  }
  @throw create_JavaLangAssertionError_initWithId_([((ADXConstraintAnchor_Type *) nil_chk(mType_)) name]);
}

- (void)setMarginWithInt:(jint)margin {
  if ([self isConnected]) {
    mMargin_ = margin;
  }
}

- (void)setGoneMarginWithInt:(jint)margin {
  if ([self isConnected]) {
    mGoneMargin_ = margin;
  }
}

- (jboolean)isVerticalAnchor {
  switch ([mType_ ordinal]) {
    case ADXConstraintAnchor_Type_Enum_LEFT:
    case ADXConstraintAnchor_Type_Enum_RIGHT:
    case ADXConstraintAnchor_Type_Enum_CENTER:
    case ADXConstraintAnchor_Type_Enum_CENTER_X:
    return false;
    case ADXConstraintAnchor_Type_Enum_CENTER_Y:
    case ADXConstraintAnchor_Type_Enum_TOP:
    case ADXConstraintAnchor_Type_Enum_BOTTOM:
    case ADXConstraintAnchor_Type_Enum_BASELINE:
    case ADXConstraintAnchor_Type_Enum_NONE:
    return true;
  }
  @throw create_JavaLangAssertionError_initWithId_([((ADXConstraintAnchor_Type *) nil_chk(mType_)) name]);
}

- (NSString *)description {
  return JreStrcat("$C$", [((ADXConstraintWidget *) nil_chk(mOwner_)) getDebugName], ':', [((ADXConstraintAnchor_Type *) nil_chk(mType_)) description]);
}

- (jboolean)isConnectionAllowedWithADXConstraintWidget:(ADXConstraintWidget *)target
                               withADXConstraintAnchor:(ADXConstraintAnchor *)anchor {
  return [self isConnectionAllowedWithADXConstraintWidget:target];
}

- (jboolean)isConnectionAllowedWithADXConstraintWidget:(ADXConstraintWidget *)target {
  JavaUtilHashSet *checked = create_JavaUtilHashSet_init();
  if (ADXConstraintAnchor_isConnectionToMeWithADXConstraintWidget_withJavaUtilHashSet_(self, target, checked)) {
    return false;
  }
  ADXConstraintWidget *parent = JreRetainedLocalValue([((ADXConstraintWidget *) nil_chk([self getOwner])) getParent]);
  if (parent == target) {
    return true;
  }
  if ([((ADXConstraintWidget *) nil_chk(target)) getParent] == parent) {
    return true;
  }
  return false;
}

- (jboolean)isConnectionToMeWithADXConstraintWidget:(ADXConstraintWidget *)target
                                withJavaUtilHashSet:(JavaUtilHashSet *)checked {
  return ADXConstraintAnchor_isConnectionToMeWithADXConstraintWidget_withJavaUtilHashSet_(self, target, checked);
}

- (ADXConstraintAnchor *)getOpposite {
  return ADXConstraintAnchor_getOpposite(self);
}

- (void)__javaClone:(ADXConstraintAnchor *)original {
  [super __javaClone:original];
  [mOwner_ release];
  [mTarget_ release];
}

- (void)dealloc {
  RELEASE_(mDependents_);
  RELEASE_(mType_);
  RELEASE_(mSolverVariable_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x1, 0, 1, -1, 2, -1, -1 },
    { NULL, "LJavaUtilHashSet;", 0x1, -1, -1, -1, 3, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, 8, -1, -1 },
    { NULL, NULL, 0x1, -1, 9, -1, -1, -1, -1 },
    { NULL, "LADXSolverVariable;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "LADXConstraintWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintAnchor_Type;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintAnchor;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 12, 13, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 12, 14, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 16, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 17, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 18, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 19, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 20, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 21, 22, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 21, 23, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 24, 25, -1, 26, -1, -1 },
    { NULL, "LADXConstraintAnchor;", 0x11, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(findDependentsWithInt:withJavaUtilArrayList:withADXWidgetGroup:);
  methods[1].selector = @selector(getDependents);
  methods[2].selector = @selector(hasDependents);
  methods[3].selector = @selector(hasCenteredDependents);
  methods[4].selector = @selector(setFinalValueWithInt:);
  methods[5].selector = @selector(getFinalValue);
  methods[6].selector = @selector(resetFinalResolution);
  methods[7].selector = @selector(hasFinalValue);
  methods[8].selector = @selector(copyFromWithADXConstraintAnchor:withJavaUtilHashMap:);
  methods[9].selector = @selector(initWithADXConstraintWidget:withADXConstraintAnchor_Type:);
  methods[10].selector = @selector(getSolverVariable);
  methods[11].selector = @selector(resetSolverVariableWithADXCache:);
  methods[12].selector = @selector(getOwner);
  methods[13].selector = @selector(getType);
  methods[14].selector = @selector(getMargin);
  methods[15].selector = @selector(getTarget);
  methods[16].selector = @selector(reset);
  methods[17].selector = @selector(connectWithADXConstraintAnchor:withInt:withInt:withBoolean:);
  methods[18].selector = @selector(connectWithADXConstraintAnchor:withInt:);
  methods[19].selector = @selector(isConnected);
  methods[20].selector = @selector(isValidConnectionWithADXConstraintAnchor:);
  methods[21].selector = @selector(isSideAnchor);
  methods[22].selector = @selector(isSimilarDimensionConnectionWithADXConstraintAnchor:);
  methods[23].selector = @selector(setMarginWithInt:);
  methods[24].selector = @selector(setGoneMarginWithInt:);
  methods[25].selector = @selector(isVerticalAnchor);
  methods[26].selector = @selector(description);
  methods[27].selector = @selector(isConnectionAllowedWithADXConstraintWidget:withADXConstraintAnchor:);
  methods[28].selector = @selector(isConnectionAllowedWithADXConstraintWidget:);
  methods[29].selector = @selector(isConnectionToMeWithADXConstraintWidget:withJavaUtilHashSet:);
  methods[30].selector = @selector(getOpposite);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "ALLOW_BINARY", "Z", .constantValue.asBOOL = ADXConstraintAnchor_ALLOW_BINARY, 0x1a, -1, -1, -1, -1 },
    { "mDependents_", "LJavaUtilHashSet;", .constantValue.asLong = 0, 0x2, -1, -1, 27, -1 },
    { "mFinalValue_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mHasFinalValue_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "UNSET_GONE_MARGIN", "I", .constantValue.asInt = ADXConstraintAnchor_UNSET_GONE_MARGIN, 0x1a, -1, -1, -1, -1 },
    { "mOwner_", "LADXConstraintWidget;", .constantValue.asLong = 0, 0x11, -1, -1, -1, -1 },
    { "mType_", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x11, -1, -1, -1, -1 },
    { "mTarget_", "LADXConstraintAnchor;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mMargin_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mGoneMargin_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mSolverVariable_", "LADXSolverVariable;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "findDependents", "ILJavaUtilArrayList;LADXWidgetGroup;", "(ILjava/util/ArrayList<Landroidx/constraintlayout/core/widgets/analyzer/WidgetGroup;>;Landroidx/constraintlayout/core/widgets/analyzer/WidgetGroup;)V", "()Ljava/util/HashSet<Landroidx/constraintlayout/core/widgets/ConstraintAnchor;>;", "setFinalValue", "I", "copyFrom", "LADXConstraintAnchor;LJavaUtilHashMap;", "(Landroidx/constraintlayout/core/widgets/ConstraintAnchor;Ljava/util/HashMap<Landroidx/constraintlayout/core/widgets/ConstraintWidget;Landroidx/constraintlayout/core/widgets/ConstraintWidget;>;)V", "LADXConstraintWidget;LADXConstraintAnchor_Type;", "resetSolverVariable", "LADXCache;", "connect", "LADXConstraintAnchor;IIZ", "LADXConstraintAnchor;I", "isValidConnection", "LADXConstraintAnchor;", "isSimilarDimensionConnection", "setMargin", "setGoneMargin", "toString", "isConnectionAllowed", "LADXConstraintWidget;LADXConstraintAnchor;", "LADXConstraintWidget;", "isConnectionToMe", "LADXConstraintWidget;LJavaUtilHashSet;", "(Landroidx/constraintlayout/core/widgets/ConstraintWidget;Ljava/util/HashSet<Landroidx/constraintlayout/core/widgets/ConstraintWidget;>;)Z", "Ljava/util/HashSet<Landroidx/constraintlayout/core/widgets/ConstraintAnchor;>;", "LADXConstraintAnchor_Type;" };
  static const J2ObjcClassInfo _ADXConstraintAnchor = { "ConstraintAnchor", "androidx.constraintlayout.core.widgets", ptrTable, methods, fields, 7, 0x1, 31, 11, -1, 28, -1, -1, -1 };
  return &_ADXConstraintAnchor;
}

@end

void ADXConstraintAnchor_initWithADXConstraintWidget_withADXConstraintAnchor_Type_(ADXConstraintAnchor *self, ADXConstraintWidget *owner, ADXConstraintAnchor_Type *type) {
  NSObject_init(self);
  JreStrongAssign(&self->mDependents_, nil);
  self->mMargin_ = 0;
  self->mGoneMargin_ = ADXConstraintAnchor_UNSET_GONE_MARGIN;
  self->mOwner_ = owner;
  JreStrongAssign(&self->mType_, type);
}

ADXConstraintAnchor *new_ADXConstraintAnchor_initWithADXConstraintWidget_withADXConstraintAnchor_Type_(ADXConstraintWidget *owner, ADXConstraintAnchor_Type *type) {
  J2OBJC_NEW_IMPL(ADXConstraintAnchor, initWithADXConstraintWidget_withADXConstraintAnchor_Type_, owner, type)
}

ADXConstraintAnchor *create_ADXConstraintAnchor_initWithADXConstraintWidget_withADXConstraintAnchor_Type_(ADXConstraintWidget *owner, ADXConstraintAnchor_Type *type) {
  J2OBJC_CREATE_IMPL(ADXConstraintAnchor, initWithADXConstraintWidget_withADXConstraintAnchor_Type_, owner, type)
}

jboolean ADXConstraintAnchor_isConnectionToMeWithADXConstraintWidget_withJavaUtilHashSet_(ADXConstraintAnchor *self, ADXConstraintWidget *target, JavaUtilHashSet *checked) {
  if ([((JavaUtilHashSet *) nil_chk(checked)) containsWithId:target]) {
    return false;
  }
  [checked addWithId:target];
  if (target == [self getOwner]) {
    return true;
  }
  JavaUtilArrayList *targetAnchors = JreRetainedLocalValue([((ADXConstraintWidget *) nil_chk(target)) getAnchors]);
  for (jint i = 0, targetAnchorsSize = [((JavaUtilArrayList *) nil_chk(targetAnchors)) size]; i < targetAnchorsSize; i++) {
    ADXConstraintAnchor *anchor = JreRetainedLocalValue([targetAnchors getWithInt:i]);
    if ([((ADXConstraintAnchor *) nil_chk(anchor)) isSimilarDimensionConnectionWithADXConstraintAnchor:self] && [anchor isConnected]) {
      if (ADXConstraintAnchor_isConnectionToMeWithADXConstraintWidget_withJavaUtilHashSet_(self, [((ADXConstraintAnchor *) nil_chk([anchor getTarget])) getOwner], checked)) {
        return true;
      }
    }
  }
  return false;
}

ADXConstraintAnchor *ADXConstraintAnchor_getOpposite(ADXConstraintAnchor *self) {
  switch ([self->mType_ ordinal]) {
    case ADXConstraintAnchor_Type_Enum_LEFT:
    {
      return ((ADXConstraintWidget *) nil_chk(self->mOwner_))->mRight_;
    }
    case ADXConstraintAnchor_Type_Enum_RIGHT:
    {
      return ((ADXConstraintWidget *) nil_chk(self->mOwner_))->mLeft_;
    }
    case ADXConstraintAnchor_Type_Enum_TOP:
    {
      return ((ADXConstraintWidget *) nil_chk(self->mOwner_))->mBottom_;
    }
    case ADXConstraintAnchor_Type_Enum_BOTTOM:
    {
      return ((ADXConstraintWidget *) nil_chk(self->mOwner_))->mTop_;
    }
    case ADXConstraintAnchor_Type_Enum_BASELINE:
    case ADXConstraintAnchor_Type_Enum_CENTER:
    case ADXConstraintAnchor_Type_Enum_CENTER_X:
    case ADXConstraintAnchor_Type_Enum_CENTER_Y:
    case ADXConstraintAnchor_Type_Enum_NONE:
    return nil;
  }
  @throw create_JavaLangAssertionError_initWithId_([((ADXConstraintAnchor_Type *) nil_chk(self->mType_)) name]);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXConstraintAnchor)

J2OBJC_INITIALIZED_DEFN(ADXConstraintAnchor_Type)

ADXConstraintAnchor_Type *ADXConstraintAnchor_Type_values_[9];

@implementation ADXConstraintAnchor_Type

+ (IOSObjectArray *)values {
  return ADXConstraintAnchor_Type_values();
}

+ (ADXConstraintAnchor_Type *)valueOfWithNSString:(NSString *)name {
  return ADXConstraintAnchor_Type_valueOfWithNSString_(name);
}

- (ADXConstraintAnchor_Type_Enum)toNSEnum {
  return (ADXConstraintAnchor_Type_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[LADXConstraintAnchor_Type;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintAnchor_Type;", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(values);
  methods[1].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NONE", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x4019, -1, 2, -1, -1 },
    { "LEFT", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "TOP", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
    { "RIGHT", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x4019, -1, 5, -1, -1 },
    { "BOTTOM", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x4019, -1, 6, -1, -1 },
    { "BASELINE", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x4019, -1, 7, -1, -1 },
    { "CENTER", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x4019, -1, 8, -1, -1 },
    { "CENTER_X", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x4019, -1, 9, -1, -1 },
    { "CENTER_Y", "LADXConstraintAnchor_Type;", .constantValue.asLong = 0, 0x4019, -1, 10, -1, -1 },
  };
  static const void *ptrTable[] = { "valueOf", "LNSString;", &JreEnum(ADXConstraintAnchor_Type, NONE), &JreEnum(ADXConstraintAnchor_Type, LEFT), &JreEnum(ADXConstraintAnchor_Type, TOP), &JreEnum(ADXConstraintAnchor_Type, RIGHT), &JreEnum(ADXConstraintAnchor_Type, BOTTOM), &JreEnum(ADXConstraintAnchor_Type, BASELINE), &JreEnum(ADXConstraintAnchor_Type, CENTER), &JreEnum(ADXConstraintAnchor_Type, CENTER_X), &JreEnum(ADXConstraintAnchor_Type, CENTER_Y), "LADXConstraintAnchor;", "Ljava/lang/Enum<Landroidx/constraintlayout/core/widgets/ConstraintAnchor$Type;>;" };
  static const J2ObjcClassInfo _ADXConstraintAnchor_Type = { "Type", "androidx.constraintlayout.core.widgets", ptrTable, methods, fields, 7, 0x4019, 2, 9, 11, -1, -1, 12, -1 };
  return &_ADXConstraintAnchor_Type;
}

+ (void)initialize {
  if (self == [ADXConstraintAnchor_Type class]) {
    size_t objSize = class_getInstanceSize(self);
    size_t allocSize = 9 * objSize;
    uintptr_t ptr = (uintptr_t)calloc(allocSize, 1);
    id e;
    for (jint i = 0; i < 9; i++) {
      ((void)(ADXConstraintAnchor_Type_values_[i] = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
      ADXConstraintAnchor_Type_initWithNSString_withInt_(e, JreEnumConstantName(ADXConstraintAnchor_Type_class_(), i), i);
    }
    J2OBJC_SET_INITIALIZED(ADXConstraintAnchor_Type)
  }
}

@end

void ADXConstraintAnchor_Type_initWithNSString_withInt_(ADXConstraintAnchor_Type *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}

IOSObjectArray *ADXConstraintAnchor_Type_values() {
  ADXConstraintAnchor_Type_initialize();
  return [IOSObjectArray arrayWithObjects:ADXConstraintAnchor_Type_values_ count:9 type:ADXConstraintAnchor_Type_class_()];
}

ADXConstraintAnchor_Type *ADXConstraintAnchor_Type_valueOfWithNSString_(NSString *name) {
  ADXConstraintAnchor_Type_initialize();
  for (int i = 0; i < 9; i++) {
    ADXConstraintAnchor_Type *e = ADXConstraintAnchor_Type_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

ADXConstraintAnchor_Type *ADXConstraintAnchor_Type_fromOrdinal(NSUInteger ordinal) {
  ADXConstraintAnchor_Type_initialize();
  if (ordinal >= 9) {
    return nil;
  }
  return ADXConstraintAnchor_Type_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXConstraintAnchor_Type)
