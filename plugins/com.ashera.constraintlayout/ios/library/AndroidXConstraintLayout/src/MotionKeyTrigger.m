//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\motion\key\MotionKeyTrigger.java
//

#include "CustomVariable.h"
#include "FloatRect.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "MotionKey.h"
#include "MotionKeyTrigger.h"
#include "MotionWidget.h"
#include "TypedValues.h"
#include "java/lang/Float.h"
#include "java/lang/Integer.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Locale.h"
#include "java/util/Set.h"


@interface ADXMotionKeyTrigger () {
 @public
  jint mCurveFit_;
  NSString *mCross_;
  jint mTriggerReceiver_;
  NSString *mNegativeCross_;
  NSString *mPositiveCross_;
  jint mTriggerID_;
  jint mTriggerCollisionId_;
  jboolean mFireCrossReset_;
  jboolean mFireNegativeReset_;
  jboolean mFirePositiveReset_;
  jfloat mFireThreshold_;
  jfloat mFireLastPos_;
  jboolean mPostLayout_;
}

- (void)fireCustomWithNSString:(NSString *)str
           withADXMotionWidget:(ADXMotionWidget *)widget;

@end

J2OBJC_FIELD_SETTER(ADXMotionKeyTrigger, mCross_, NSString *)
J2OBJC_FIELD_SETTER(ADXMotionKeyTrigger, mNegativeCross_, NSString *)
J2OBJC_FIELD_SETTER(ADXMotionKeyTrigger, mPositiveCross_, NSString *)

inline NSString *ADXMotionKeyTrigger_get_TAG(void);
static NSString *ADXMotionKeyTrigger_TAG = @"KeyTrigger";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADXMotionKeyTrigger, TAG, NSString *)

__attribute__((unused)) static void ADXMotionKeyTrigger_fireCustomWithNSString_withADXMotionWidget_(ADXMotionKeyTrigger *self, NSString *str, ADXMotionWidget *widget);

NSString *ADXMotionKeyTrigger_VIEW_TRANSITION_ON_CROSS = @"viewTransitionOnCross";
NSString *ADXMotionKeyTrigger_VIEW_TRANSITION_ON_POSITIVE_CROSS = @"viewTransitionOnPositiveCross";
NSString *ADXMotionKeyTrigger_VIEW_TRANSITION_ON_NEGATIVE_CROSS = @"viewTransitionOnNegativeCross";
NSString *ADXMotionKeyTrigger_POST_LAYOUT = @"postLayout";
NSString *ADXMotionKeyTrigger_TRIGGER_SLACK = @"triggerSlack";
NSString *ADXMotionKeyTrigger_TRIGGER_COLLISION_VIEW = @"triggerCollisionView";
NSString *ADXMotionKeyTrigger_TRIGGER_COLLISION_ID = @"triggerCollisionId";
NSString *ADXMotionKeyTrigger_TRIGGER_ID = @"triggerID";
NSString *ADXMotionKeyTrigger_POSITIVE_CROSS = @"positiveCross";
NSString *ADXMotionKeyTrigger_NEGATIVE_CROSS = @"negativeCross";
NSString *ADXMotionKeyTrigger_TRIGGER_RECEIVER = @"triggerReceiver";
NSString *ADXMotionKeyTrigger_CROSS = @"CROSS";

@implementation ADXMotionKeyTrigger

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXMotionKeyTrigger_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)getAttributeNamesWithJavaUtilHashSet:(JavaUtilHashSet *)attributes {
}

- (void)addValuesWithJavaUtilHashMap:(JavaUtilHashMap *)splines {
}

- (jint)getIdWithNSString:(NSString *)name {
  switch (JreIndexOfStr(name, (id[]){ ADXMotionKeyTrigger_VIEW_TRANSITION_ON_CROSS, ADXMotionKeyTrigger_VIEW_TRANSITION_ON_POSITIVE_CROSS, ADXMotionKeyTrigger_VIEW_TRANSITION_ON_NEGATIVE_CROSS, ADXMotionKeyTrigger_POST_LAYOUT, ADXMotionKeyTrigger_TRIGGER_SLACK, ADXMotionKeyTrigger_TRIGGER_COLLISION_VIEW, ADXMotionKeyTrigger_TRIGGER_COLLISION_ID, ADXMotionKeyTrigger_TRIGGER_ID, ADXMotionKeyTrigger_POSITIVE_CROSS, ADXMotionKeyTrigger_NEGATIVE_CROSS, ADXMotionKeyTrigger_TRIGGER_RECEIVER }, 11)) {
    case 0:
    return ADXMotionKeyTrigger_TYPE_VIEW_TRANSITION_ON_CROSS;
    case 1:
    return ADXMotionKeyTrigger_TYPE_VIEW_TRANSITION_ON_POSITIVE_CROSS;
    case 2:
    return ADXMotionKeyTrigger_TYPE_VIEW_TRANSITION_ON_NEGATIVE_CROSS;
    case 3:
    return ADXMotionKeyTrigger_TYPE_POST_LAYOUT;
    case 4:
    return ADXMotionKeyTrigger_TYPE_TRIGGER_SLACK;
    case 5:
    return ADXMotionKeyTrigger_TYPE_TRIGGER_COLLISION_VIEW;
    case 6:
    return ADXMotionKeyTrigger_TYPE_TRIGGER_COLLISION_ID;
    case 7:
    return ADXMotionKeyTrigger_TYPE_TRIGGER_ID;
    case 8:
    return ADXMotionKeyTrigger_TYPE_POSITIVE_CROSS;
    case 9:
    return ADXMotionKeyTrigger_TYPE_NEGATIVE_CROSS;
    case 10:
    return ADXMotionKeyTrigger_TYPE_TRIGGER_RECEIVER;
  }
  return -1;
}

- (ADXMotionKeyTrigger *)copy__WithADXMotionKey:(ADXMotionKey *)src {
  [super copy__WithADXMotionKey:src];
  ADXMotionKeyTrigger *k = (ADXMotionKeyTrigger *) cast_chk(src, [ADXMotionKeyTrigger class]);
  mCurveFit_ = ((ADXMotionKeyTrigger *) nil_chk(k))->mCurveFit_;
  JreStrongAssign(&mCross_, k->mCross_);
  mTriggerReceiver_ = k->mTriggerReceiver_;
  JreStrongAssign(&mNegativeCross_, k->mNegativeCross_);
  JreStrongAssign(&mPositiveCross_, k->mPositiveCross_);
  mTriggerID_ = k->mTriggerID_;
  mTriggerCollisionId_ = k->mTriggerCollisionId_;
  mTriggerSlack_ = k->mTriggerSlack_;
  mFireCrossReset_ = k->mFireCrossReset_;
  mFireNegativeReset_ = k->mFireNegativeReset_;
  mFirePositiveReset_ = k->mFirePositiveReset_;
  mFireThreshold_ = k->mFireThreshold_;
  mFireLastPos_ = k->mFireLastPos_;
  mPostLayout_ = k->mPostLayout_;
  JreStrongAssign(&mCollisionRect_, k->mCollisionRect_);
  JreStrongAssign(&mTargetRect_, k->mTargetRect_);
  JreStrongAssign(&mMethodHashMap_, k->mMethodHashMap_);
  return self;
}

- (ADXMotionKey *)java_clone {
  return [create_ADXMotionKeyTrigger_init() copy__WithADXMotionKey:self];
}

- (void)fireCustomWithNSString:(NSString *)str
           withADXMotionWidget:(ADXMotionWidget *)widget {
  ADXMotionKeyTrigger_fireCustomWithNSString_withADXMotionWidget_(self, str, widget);
}

- (void)conditionallyFireWithFloat:(jfloat)position
               withADXMotionWidget:(ADXMotionWidget *)child {
}

- (jboolean)setValueWithInt:(jint)type
                    withInt:(jint)value {
  switch (type) {
    case ADXTypedValues_Trigger_TYPE_TRIGGER_RECEIVER:
    mTriggerReceiver_ = value;
    break;
    case ADXTypedValues_Trigger_TYPE_TRIGGER_ID:
    mTriggerID_ = [self toIntWithId:JavaLangInteger_valueOfWithInt_(value)];
    break;
    case ADXTypedValues_Trigger_TYPE_TRIGGER_COLLISION_ID:
    mTriggerCollisionId_ = value;
    break;
    case ADXTypedValues_Trigger_TYPE_VIEW_TRANSITION_ON_NEGATIVE_CROSS:
    mViewTransitionOnNegativeCross_ = value;
    break;
    case ADXTypedValues_Trigger_TYPE_VIEW_TRANSITION_ON_POSITIVE_CROSS:
    mViewTransitionOnPositiveCross_ = value;
    break;
    case ADXTypedValues_Trigger_TYPE_VIEW_TRANSITION_ON_CROSS:
    mViewTransitionOnCross_ = value;
    break;
    default:
    return [super setValueWithInt:type withInt:value];
  }
  return true;
}

- (jboolean)setValueWithInt:(jint)type
                  withFloat:(jfloat)value {
  switch (type) {
    case ADXTypedValues_Trigger_TYPE_TRIGGER_SLACK:
    mTriggerSlack_ = value;
    break;
    default:
    return [super setValueWithInt:type withFloat:value];
  }
  return true;
}

- (jboolean)setValueWithInt:(jint)type
               withNSString:(NSString *)value {
  switch (type) {
    case ADXTypedValues_Trigger_TYPE_CROSS:
    JreStrongAssign(&mCross_, value);
    break;
    case ADXTypedValues_Trigger_TYPE_NEGATIVE_CROSS:
    JreStrongAssign(&mNegativeCross_, value);
    break;
    case ADXTypedValues_Trigger_TYPE_POSITIVE_CROSS:
    JreStrongAssign(&mPositiveCross_, value);
    break;
    default:
    return [super setValueWithInt:type withNSString:value];
  }
  return true;
}

- (jboolean)setValueWithInt:(jint)type
                withBoolean:(jboolean)value {
  switch (type) {
    case ADXTypedValues_Trigger_TYPE_POST_LAYOUT:
    mPostLayout_ = value;
    break;
    default:
    return [super setValueWithInt:type withBoolean:value];
  }
  return true;
}

- (void)dealloc {
  RELEASE_(mCross_);
  RELEASE_(mNegativeCross_);
  RELEASE_(mPositiveCross_);
  RELEASE_(mCollisionRect_);
  RELEASE_(mTargetRect_);
  RELEASE_(mMethodHashMap_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, 2, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, 5, -1, -1 },
    { NULL, "I", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "LADXMotionKeyTrigger;", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "LADXMotionKey;", 0x1, 10, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 14, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 16, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 17, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 18, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 19, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(getAttributeNamesWithJavaUtilHashSet:);
  methods[2].selector = @selector(addValuesWithJavaUtilHashMap:);
  methods[3].selector = @selector(getIdWithNSString:);
  methods[4].selector = @selector(copy__WithADXMotionKey:);
  methods[5].selector = @selector(java_clone);
  methods[6].selector = @selector(fireCustomWithNSString:withADXMotionWidget:);
  methods[7].selector = @selector(conditionallyFireWithFloat:withADXMotionWidget:);
  methods[8].selector = @selector(setValueWithInt:withInt:);
  methods[9].selector = @selector(setValueWithInt:withFloat:);
  methods[10].selector = @selector(setValueWithInt:withNSString:);
  methods[11].selector = @selector(setValueWithInt:withBoolean:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 20, -1, -1 },
    { "VIEW_TRANSITION_ON_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 21, -1, -1 },
    { "VIEW_TRANSITION_ON_POSITIVE_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 22, -1, -1 },
    { "VIEW_TRANSITION_ON_NEGATIVE_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 23, -1, -1 },
    { "POST_LAYOUT", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 24, -1, -1 },
    { "TRIGGER_SLACK", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 25, -1, -1 },
    { "TRIGGER_COLLISION_VIEW", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 26, -1, -1 },
    { "TRIGGER_COLLISION_ID", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 27, -1, -1 },
    { "TRIGGER_ID", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 28, -1, -1 },
    { "POSITIVE_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 29, -1, -1 },
    { "NEGATIVE_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 30, -1, -1 },
    { "TRIGGER_RECEIVER", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 31, -1, -1 },
    { "CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 32, -1, -1 },
    { "mCurveFit_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mCross_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTriggerReceiver_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mNegativeCross_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPositiveCross_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTriggerID_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTriggerCollisionId_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTriggerSlack_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mFireCrossReset_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mFireNegativeReset_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mFirePositiveReset_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mFireThreshold_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mFireLastPos_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPostLayout_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mViewTransitionOnNegativeCross_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mViewTransitionOnPositiveCross_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mViewTransitionOnCross_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "TYPE_VIEW_TRANSITION_ON_CROSS", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_VIEW_TRANSITION_ON_CROSS, 0x19, -1, -1, -1, -1 },
    { "TYPE_VIEW_TRANSITION_ON_POSITIVE_CROSS", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_VIEW_TRANSITION_ON_POSITIVE_CROSS, 0x19, -1, -1, -1, -1 },
    { "TYPE_VIEW_TRANSITION_ON_NEGATIVE_CROSS", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_VIEW_TRANSITION_ON_NEGATIVE_CROSS, 0x19, -1, -1, -1, -1 },
    { "TYPE_POST_LAYOUT", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_POST_LAYOUT, 0x19, -1, -1, -1, -1 },
    { "TYPE_TRIGGER_SLACK", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_TRIGGER_SLACK, 0x19, -1, -1, -1, -1 },
    { "TYPE_TRIGGER_COLLISION_VIEW", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_TRIGGER_COLLISION_VIEW, 0x19, -1, -1, -1, -1 },
    { "TYPE_TRIGGER_COLLISION_ID", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_TRIGGER_COLLISION_ID, 0x19, -1, -1, -1, -1 },
    { "TYPE_TRIGGER_ID", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_TRIGGER_ID, 0x19, -1, -1, -1, -1 },
    { "TYPE_POSITIVE_CROSS", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_POSITIVE_CROSS, 0x19, -1, -1, -1, -1 },
    { "TYPE_NEGATIVE_CROSS", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_NEGATIVE_CROSS, 0x19, -1, -1, -1, -1 },
    { "TYPE_TRIGGER_RECEIVER", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_TRIGGER_RECEIVER, 0x19, -1, -1, -1, -1 },
    { "TYPE_CROSS", "I", .constantValue.asInt = ADXMotionKeyTrigger_TYPE_CROSS, 0x19, -1, -1, -1, -1 },
    { "mCollisionRect_", "LADXFloatRect;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTargetRect_", "LADXFloatRect;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mMethodHashMap_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x0, -1, -1, 33, -1 },
    { "KEY_TYPE", "I", .constantValue.asInt = ADXMotionKeyTrigger_KEY_TYPE, 0x19, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "getAttributeNames", "LJavaUtilHashSet;", "(Ljava/util/HashSet<Ljava/lang/String;>;)V", "addValues", "LJavaUtilHashMap;", "(Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/core/motion/utils/SplineSet;>;)V", "getId", "LNSString;", "copy", "LADXMotionKey;", "clone", "fireCustom", "LNSString;LADXMotionWidget;", "conditionallyFire", "FLADXMotionWidget;", "setValue", "II", "IF", "ILNSString;", "IZ", &ADXMotionKeyTrigger_TAG, &ADXMotionKeyTrigger_VIEW_TRANSITION_ON_CROSS, &ADXMotionKeyTrigger_VIEW_TRANSITION_ON_POSITIVE_CROSS, &ADXMotionKeyTrigger_VIEW_TRANSITION_ON_NEGATIVE_CROSS, &ADXMotionKeyTrigger_POST_LAYOUT, &ADXMotionKeyTrigger_TRIGGER_SLACK, &ADXMotionKeyTrigger_TRIGGER_COLLISION_VIEW, &ADXMotionKeyTrigger_TRIGGER_COLLISION_ID, &ADXMotionKeyTrigger_TRIGGER_ID, &ADXMotionKeyTrigger_POSITIVE_CROSS, &ADXMotionKeyTrigger_NEGATIVE_CROSS, &ADXMotionKeyTrigger_TRIGGER_RECEIVER, &ADXMotionKeyTrigger_CROSS, "Ljava/util/HashMap<Ljava/lang/String;Ljava/lang/reflect/Method;>;" };
  static const J2ObjcClassInfo _ADXMotionKeyTrigger = { "MotionKeyTrigger", "androidx.constraintlayout.core.motion.key", ptrTable, methods, fields, 7, 0x1, 12, 46, -1, -1, -1, -1, -1 };
  return &_ADXMotionKeyTrigger;
}

@end

void ADXMotionKeyTrigger_init(ADXMotionKeyTrigger *self) {
  ADXMotionKey_init(self);
  self->mCurveFit_ = -1;
  JreStrongAssign(&self->mCross_, nil);
  self->mTriggerReceiver_ = JreLoadStatic(ADXMotionKey, UNSET);
  JreStrongAssign(&self->mNegativeCross_, nil);
  JreStrongAssign(&self->mPositiveCross_, nil);
  self->mTriggerID_ = JreLoadStatic(ADXMotionKey, UNSET);
  self->mTriggerCollisionId_ = JreLoadStatic(ADXMotionKey, UNSET);
  self->mTriggerSlack_ = .1f;
  self->mFireCrossReset_ = true;
  self->mFireNegativeReset_ = true;
  self->mFirePositiveReset_ = true;
  self->mFireThreshold_ = JavaLangFloat_NaN;
  self->mPostLayout_ = false;
  self->mViewTransitionOnNegativeCross_ = JreLoadStatic(ADXMotionKey, UNSET);
  self->mViewTransitionOnPositiveCross_ = JreLoadStatic(ADXMotionKey, UNSET);
  self->mViewTransitionOnCross_ = JreLoadStatic(ADXMotionKey, UNSET);
  JreStrongAssignAndConsume(&self->mCollisionRect_, new_ADXFloatRect_init());
  JreStrongAssignAndConsume(&self->mTargetRect_, new_ADXFloatRect_init());
  JreStrongAssignAndConsume(&self->mMethodHashMap_, new_JavaUtilHashMap_init());
  {
    self->mType_ = ADXMotionKeyTrigger_KEY_TYPE;
    JreStrongAssignAndConsume(&self->mCustom_, new_JavaUtilHashMap_init());
  }
}

ADXMotionKeyTrigger *new_ADXMotionKeyTrigger_init() {
  J2OBJC_NEW_IMPL(ADXMotionKeyTrigger, init)
}

ADXMotionKeyTrigger *create_ADXMotionKeyTrigger_init() {
  J2OBJC_CREATE_IMPL(ADXMotionKeyTrigger, init)
}

void ADXMotionKeyTrigger_fireCustomWithNSString_withADXMotionWidget_(ADXMotionKeyTrigger *self, NSString *str, ADXMotionWidget *widget) {
  jboolean callAll = [((NSString *) nil_chk(str)) java_length] == 1;
  if (!callAll) {
    str = [((NSString *) nil_chk([str java_substring:1])) java_lowercaseStringWithJRELocale:JreLoadStatic(JavaUtilLocale, ROOT)];
  }
  for (NSString * __strong name in nil_chk([((JavaUtilHashMap *) nil_chk(self->mCustom_)) keySet])) {
    NSString *lowerCase = [((NSString *) nil_chk(name)) java_lowercaseStringWithJRELocale:JreLoadStatic(JavaUtilLocale, ROOT)];
    if (callAll || [((NSString *) nil_chk(lowerCase)) java_matches:str]) {
      ADXCustomVariable *custom = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(self->mCustom_)) getWithId:name]);
      if (custom != nil) {
        [custom applyToWidgetWithADXMotionWidget:widget];
      }
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXMotionKeyTrigger)
