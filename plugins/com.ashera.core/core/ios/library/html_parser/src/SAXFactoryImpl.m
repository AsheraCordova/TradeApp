//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-widget_library\html_parser\src\repackaged\org\ccil\cowan\tagsoup\jaxp\SAXFactoryImpl.java
//

#include "J2ObjC_source.h"
#include "SAXFactoryImpl.h"
#include "SAXParserImpl.h"
#include "java/lang/Boolean.h"
#include "java/util/HashMap.h"
#include "java/util/LinkedHashMap.h"
#include "javax/xml/parsers/ParserConfigurationException.h"
#include "javax/xml/parsers/SAXParser.h"
#include "javax/xml/parsers/SAXParserFactory.h"
#include "org/xml/sax/SAXException.h"

@class JavaUtilHashMap;


@interface TSSAXFactoryImpl () {
 @public
  /*!
   @brief The easiest way to test validity of features to set is to use
  a prototype object.Currently this is actually not a real prototype,
  in the sense that the configuration is actually passed separately
  (as opposed to instantiating new readers from this prototype), but
  this could be changed in future, if TagSoup parser object allowed
  cloning.
   */
  TSSAXParserImpl *prototypeParser_;
  /*!
   @brief This Map contains explicitly set features that can be succesfully
  set for XMLReader instances.Temporary storage is needed due to
  JAXP design: multiple readers can be instantiated from a single
  factory, and settings can be changed between instantiations.
   <p>
  Note that we wouldn't need this map if we could create instances
  directly using the prototype instance.
   */
  JavaUtilHashMap *features_;
}

- (TSSAXParserImpl *)getPrototype;

@end

J2OBJC_FIELD_SETTER(TSSAXFactoryImpl, prototypeParser_, TSSAXParserImpl *)
J2OBJC_FIELD_SETTER(TSSAXFactoryImpl, features_, JavaUtilHashMap *)

__attribute__((unused)) static TSSAXParserImpl *TSSAXFactoryImpl_getPrototype(TSSAXFactoryImpl *self);

@implementation TSSAXFactoryImpl

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  TSSAXFactoryImpl_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (JavaxXmlParsersSAXParser *)newSAXParser {
  @try {
    return TSSAXParserImpl_newInstanceWithJavaUtilMap_(features_);
  }
  @catch (OrgXmlSaxSAXException *se) {
    @throw create_JavaxXmlParsersParserConfigurationException_initWithNSString_([se getMessage]);
  }
}

- (void)setFeatureWithNSString:(NSString *)name
                   withBoolean:(jboolean)value {
  [((TSSAXParserImpl *) nil_chk(TSSAXFactoryImpl_getPrototype(self))) setFeatureWithNSString:name withBoolean:value];
  if (features_ == nil) {
    JreStrongAssignAndConsume(&features_, new_JavaUtilLinkedHashMap_init());
  }
  [features_ putWithId:name withId:value ? JreLoadStatic(JavaLangBoolean, TRUE) : JreLoadStatic(JavaLangBoolean, FALSE)];
}

- (jboolean)getFeatureWithNSString:(NSString *)name {
  return [((TSSAXParserImpl *) nil_chk(TSSAXFactoryImpl_getPrototype(self))) getFeatureWithNSString:name];
}

- (TSSAXParserImpl *)getPrototype {
  return TSSAXFactoryImpl_getPrototype(self);
}

- (void)dealloc {
  RELEASE_(prototypeParser_);
  RELEASE_(features_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaxXmlParsersSAXParser;", 0x1, -1, -1, 0, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, 4, 5, 3, -1, -1, -1 },
    { NULL, "LTSSAXParserImpl;", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(newSAXParser);
  methods[2].selector = @selector(setFeatureWithNSString:withBoolean:);
  methods[3].selector = @selector(getFeatureWithNSString:);
  methods[4].selector = @selector(getPrototype);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "prototypeParser_", "LTSSAXParserImpl;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "features_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaxXmlParsersParserConfigurationException;", "setFeature", "LNSString;Z", "LJavaxXmlParsersParserConfigurationException;LOrgXmlSaxSAXNotRecognizedException;LOrgXmlSaxSAXNotSupportedException;", "getFeature", "LNSString;" };
  static const J2ObjcClassInfo _TSSAXFactoryImpl = { "SAXFactoryImpl", "repackaged.org.ccil.cowan.tagsoup.jaxp", ptrTable, methods, fields, 7, 0x1, 5, 2, -1, -1, -1, -1, -1 };
  return &_TSSAXFactoryImpl;
}

@end

void TSSAXFactoryImpl_init(TSSAXFactoryImpl *self) {
  JavaxXmlParsersSAXParserFactory_init(self);
  JreStrongAssign(&self->prototypeParser_, nil);
  JreStrongAssign(&self->features_, nil);
}

TSSAXFactoryImpl *new_TSSAXFactoryImpl_init() {
  J2OBJC_NEW_IMPL(TSSAXFactoryImpl, init)
}

TSSAXFactoryImpl *create_TSSAXFactoryImpl_init() {
  J2OBJC_CREATE_IMPL(TSSAXFactoryImpl, init)
}

TSSAXParserImpl *TSSAXFactoryImpl_getPrototype(TSSAXFactoryImpl *self) {
  if (self->prototypeParser_ == nil) {
    JreStrongAssignAndConsume(&self->prototypeParser_, new_TSSAXParserImpl_init());
  }
  return self->prototypeParser_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(TSSAXFactoryImpl)
