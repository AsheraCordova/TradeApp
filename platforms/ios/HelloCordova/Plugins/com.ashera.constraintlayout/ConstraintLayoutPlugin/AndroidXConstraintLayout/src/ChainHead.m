//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\widgets\ChainHead.java
//

#include "ChainHead.h"
#include "ConstraintAnchor.h"
#include "ConstraintWidget.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/util/ArrayList.h"


@interface ADXChainHead () {
 @public
  jint mOrientation_;
  jboolean mIsRtl_;
  jboolean mDefined_;
}

/*!
 @brief Returns true if the widget should be part of the match equality rules in the chain
 @param widget the widget to test
 @param orientation current orientation, HORIZONTAL or VERTICAL
 */
+ (jboolean)isMatchConstraintEqualityCandidateWithADXConstraintWidget:(ADXConstraintWidget *)widget
                                                              withInt:(jint)orientation;

- (void)defineChainProperties;

@end

__attribute__((unused)) static jboolean ADXChainHead_isMatchConstraintEqualityCandidateWithADXConstraintWidget_withInt_(ADXConstraintWidget *widget, jint orientation);

__attribute__((unused)) static void ADXChainHead_defineChainProperties(ADXChainHead *self);

@implementation ADXChainHead

- (instancetype)initWithADXConstraintWidget:(ADXConstraintWidget *)first
                                    withInt:(jint)orientation
                                withBoolean:(jboolean)isRtl {
  ADXChainHead_initWithADXConstraintWidget_withInt_withBoolean_(self, first, orientation, isRtl);
  return self;
}

+ (jboolean)isMatchConstraintEqualityCandidateWithADXConstraintWidget:(ADXConstraintWidget *)widget
                                                              withInt:(jint)orientation {
  return ADXChainHead_isMatchConstraintEqualityCandidateWithADXConstraintWidget_withInt_(widget, orientation);
}

- (void)defineChainProperties {
  ADXChainHead_defineChainProperties(self);
}

- (ADXConstraintWidget *)getFirst {
  return mFirst_;
}

- (ADXConstraintWidget *)getFirstVisibleWidget {
  return mFirstVisibleWidget_;
}

- (ADXConstraintWidget *)getLast {
  return mLast_;
}

- (ADXConstraintWidget *)getLastVisibleWidget {
  return mLastVisibleWidget_;
}

- (ADXConstraintWidget *)getHead {
  return mHead_;
}

- (ADXConstraintWidget *)getFirstMatchConstraintWidget {
  return mFirstMatchConstraintWidget_;
}

- (ADXConstraintWidget *)getLastMatchConstraintWidget {
  return mLastMatchConstraintWidget_;
}

- (jfloat)getTotalWeight {
  return mTotalWeight_;
}

- (void)define {
  if (!mDefined_) {
    ADXChainHead_defineChainProperties(self);
  }
  mDefined_ = true;
}

- (void)dealloc {
  RELEASE_(mFirst_);
  RELEASE_(mFirstVisibleWidget_);
  RELEASE_(mLast_);
  RELEASE_(mLastVisibleWidget_);
  RELEASE_(mHead_);
  RELEASE_(mFirstMatchConstraintWidget_);
  RELEASE_(mLastMatchConstraintWidget_);
  RELEASE_(mWeightedMatchConstraintsWidgets_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0xa, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXConstraintWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADXConstraintWidget:withInt:withBoolean:);
  methods[1].selector = @selector(isMatchConstraintEqualityCandidateWithADXConstraintWidget:withInt:);
  methods[2].selector = @selector(defineChainProperties);
  methods[3].selector = @selector(getFirst);
  methods[4].selector = @selector(getFirstVisibleWidget);
  methods[5].selector = @selector(getLast);
  methods[6].selector = @selector(getLastVisibleWidget);
  methods[7].selector = @selector(getHead);
  methods[8].selector = @selector(getFirstMatchConstraintWidget);
  methods[9].selector = @selector(getLastMatchConstraintWidget);
  methods[10].selector = @selector(getTotalWeight);
  methods[11].selector = @selector(define);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mFirst_", "LADXConstraintWidget;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mFirstVisibleWidget_", "LADXConstraintWidget;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mLast_", "LADXConstraintWidget;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mLastVisibleWidget_", "LADXConstraintWidget;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mHead_", "LADXConstraintWidget;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mFirstMatchConstraintWidget_", "LADXConstraintWidget;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mLastMatchConstraintWidget_", "LADXConstraintWidget;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mWeightedMatchConstraintsWidgets_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x4, -1, -1, 3, -1 },
    { "mWidgetsCount_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mWidgetsMatchCount_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mTotalWeight_", "F", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mVisibleWidgets_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTotalSize_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTotalMargins_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mOptimizable_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mOrientation_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mIsRtl_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mHasUndefinedWeights_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mHasDefinedWeights_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mHasComplexMatchWeights_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mHasRatio_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mDefined_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADXConstraintWidget;IZ", "isMatchConstraintEqualityCandidate", "LADXConstraintWidget;I", "Ljava/util/ArrayList<Landroidx/constraintlayout/core/widgets/ConstraintWidget;>;" };
  static const J2ObjcClassInfo _ADXChainHead = { "ChainHead", "androidx.constraintlayout.core.widgets", ptrTable, methods, fields, 7, 0x1, 12, 22, -1, -1, -1, -1, -1 };
  return &_ADXChainHead;
}

@end

void ADXChainHead_initWithADXConstraintWidget_withInt_withBoolean_(ADXChainHead *self, ADXConstraintWidget *first, jint orientation, jboolean isRtl) {
  NSObject_init(self);
  self->mTotalWeight_ = 0.0f;
  self->mIsRtl_ = false;
  JreStrongAssign(&self->mFirst_, first);
  self->mOrientation_ = orientation;
  self->mIsRtl_ = isRtl;
}

ADXChainHead *new_ADXChainHead_initWithADXConstraintWidget_withInt_withBoolean_(ADXConstraintWidget *first, jint orientation, jboolean isRtl) {
  J2OBJC_NEW_IMPL(ADXChainHead, initWithADXConstraintWidget_withInt_withBoolean_, first, orientation, isRtl)
}

ADXChainHead *create_ADXChainHead_initWithADXConstraintWidget_withInt_withBoolean_(ADXConstraintWidget *first, jint orientation, jboolean isRtl) {
  J2OBJC_CREATE_IMPL(ADXChainHead, initWithADXConstraintWidget_withInt_withBoolean_, first, orientation, isRtl)
}

jboolean ADXChainHead_isMatchConstraintEqualityCandidateWithADXConstraintWidget_withInt_(ADXConstraintWidget *widget, jint orientation) {
  ADXChainHead_initialize();
  return [((ADXConstraintWidget *) nil_chk(widget)) getVisibility] != ADXConstraintWidget_GONE && IOSObjectArray_Get(nil_chk(widget->mListDimensionBehaviors_), orientation) == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && (IOSIntArray_Get(nil_chk(widget->mResolvedMatchConstraintDefault_), orientation) == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD || IOSIntArray_Get(widget->mResolvedMatchConstraintDefault_, orientation) == ADXConstraintWidget_MATCH_CONSTRAINT_RATIO);
}

void ADXChainHead_defineChainProperties(ADXChainHead *self) {
  jint offset = self->mOrientation_ * 2;
  ADXConstraintWidget *lastVisited = JreRetainedLocalValue(self->mFirst_);
  self->mOptimizable_ = true;
  ADXConstraintWidget *widget = JreRetainedLocalValue(self->mFirst_);
  ADXConstraintWidget *next = JreRetainedLocalValue(self->mFirst_);
  jboolean done = false;
  while (!done) {
    self->mWidgetsCount_++;
    IOSObjectArray_Set(nil_chk(((ADXConstraintWidget *) nil_chk(widget))->mNextChainWidget_), self->mOrientation_, nil);
    IOSObjectArray_Set(nil_chk(widget->mListNextMatchConstraintsWidget_), self->mOrientation_, nil);
    if ([widget getVisibility] != ADXConstraintWidget_GONE) {
      self->mVisibleWidgets_++;
      if ([widget getDimensionBehaviourWithInt:self->mOrientation_] != JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT)) {
        self->mTotalSize_ += [widget getLengthWithInt:self->mOrientation_];
      }
      self->mTotalSize_ += [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset))) getMargin];
      self->mTotalSize_ += [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset + 1))) getMargin];
      self->mTotalMargins_ += [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset))) getMargin];
      self->mTotalMargins_ += [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset + 1))) getMargin];
      if (self->mFirstVisibleWidget_ == nil) {
        JreStrongAssign(&self->mFirstVisibleWidget_, widget);
      }
      JreStrongAssign(&self->mLastVisibleWidget_, widget);
      if (IOSObjectArray_Get(nil_chk(widget->mListDimensionBehaviors_), self->mOrientation_) == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT)) {
        if (IOSIntArray_Get(nil_chk(widget->mResolvedMatchConstraintDefault_), self->mOrientation_) == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD || IOSIntArray_Get(widget->mResolvedMatchConstraintDefault_, self->mOrientation_) == ADXConstraintWidget_MATCH_CONSTRAINT_RATIO || IOSIntArray_Get(widget->mResolvedMatchConstraintDefault_, self->mOrientation_) == ADXConstraintWidget_MATCH_CONSTRAINT_PERCENT) {
          self->mWidgetsMatchCount_++;
          jfloat weight = IOSFloatArray_Get(nil_chk(widget->mWeight_), self->mOrientation_);
          if (weight > 0) {
            JrePlusAssignFloatF(&self->mTotalWeight_, IOSFloatArray_Get(widget->mWeight_, self->mOrientation_));
          }
          if (ADXChainHead_isMatchConstraintEqualityCandidateWithADXConstraintWidget_withInt_(widget, self->mOrientation_)) {
            if (weight < 0) {
              self->mHasUndefinedWeights_ = true;
            }
            else {
              self->mHasDefinedWeights_ = true;
            }
            if (self->mWeightedMatchConstraintsWidgets_ == nil) {
              JreStrongAssignAndConsume(&self->mWeightedMatchConstraintsWidgets_, new_JavaUtilArrayList_init());
            }
            [self->mWeightedMatchConstraintsWidgets_ addWithId:widget];
          }
          if (self->mFirstMatchConstraintWidget_ == nil) {
            JreStrongAssign(&self->mFirstMatchConstraintWidget_, widget);
          }
          if (self->mLastMatchConstraintWidget_ != nil) {
            IOSObjectArray_Set(nil_chk(self->mLastMatchConstraintWidget_->mListNextMatchConstraintsWidget_), self->mOrientation_, widget);
          }
          JreStrongAssign(&self->mLastMatchConstraintWidget_, widget);
        }
        if (self->mOrientation_ == ADXConstraintWidget_HORIZONTAL) {
          if (widget->mMatchConstraintDefaultWidth_ != ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD) {
            self->mOptimizable_ = false;
          }
          else if (widget->mMatchConstraintMinWidth_ != 0 || widget->mMatchConstraintMaxWidth_ != 0) {
            self->mOptimizable_ = false;
          }
        }
        else {
          if (widget->mMatchConstraintDefaultHeight_ != ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD) {
            self->mOptimizable_ = false;
          }
          else if (widget->mMatchConstraintMinHeight_ != 0 || widget->mMatchConstraintMaxHeight_ != 0) {
            self->mOptimizable_ = false;
          }
        }
        if (widget->mDimensionRatio_ != 0.0f) {
          self->mOptimizable_ = false;
          self->mHasRatio_ = true;
        }
      }
    }
    if (lastVisited != widget) {
      IOSObjectArray_Set(nil_chk(((ADXConstraintWidget *) nil_chk(lastVisited))->mNextChainWidget_), self->mOrientation_, widget);
    }
    lastVisited = widget;
    ADXConstraintAnchor *nextAnchor = JreRetainedLocalValue(((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset + 1)))->mTarget_);
    if (nextAnchor != nil) {
      next = nextAnchor->mOwner_;
      if (((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(((ADXConstraintWidget *) nil_chk(next))->mListAnchors_, offset)))->mTarget_ == nil || ((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(next->mListAnchors_, offset)))->mTarget_->mOwner_ != widget) {
        next = nil;
      }
    }
    else {
      next = nil;
    }
    if (next != nil) {
      widget = next;
    }
    else {
      done = true;
    }
  }
  if (self->mFirstVisibleWidget_ != nil) {
    self->mTotalSize_ -= [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(self->mFirstVisibleWidget_->mListAnchors_), offset))) getMargin];
  }
  if (self->mLastVisibleWidget_ != nil) {
    self->mTotalSize_ -= [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(self->mLastVisibleWidget_->mListAnchors_), offset + 1))) getMargin];
  }
  JreStrongAssign(&self->mLast_, widget);
  if (self->mOrientation_ == ADXConstraintWidget_HORIZONTAL && self->mIsRtl_) {
    JreStrongAssign(&self->mHead_, self->mLast_);
  }
  else {
    JreStrongAssign(&self->mHead_, self->mFirst_);
  }
  self->mHasComplexMatchWeights_ = (self->mHasDefinedWeights_ && self->mHasUndefinedWeights_);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXChainHead)
