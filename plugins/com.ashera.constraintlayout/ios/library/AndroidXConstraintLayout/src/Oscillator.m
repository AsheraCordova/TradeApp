//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\motion\utils\Oscillator.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "MonotonicCurveFit.h"
#include "Oscillator.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"


@interface ADXOscillator () {
 @public
  jboolean mNormalized_;
}

@end

NSString *ADXOscillator_TAG = @"Oscillator";

@implementation ADXOscillator

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXOscillator_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (NSString *)description {
  return JreStrcat("$$$$", @"pos =", JavaUtilArrays_toStringWithDoubleArray_(mPosition_), @" period=", JavaUtilArrays_toStringWithFloatArray_(mPeriod_));
}

- (void)setTypeWithInt:(jint)type
          withNSString:(NSString *)customType {
  mType_ = type;
  JreStrongAssign(&mCustomType_, customType);
  if (mCustomType_ != nil) {
    JreStrongAssign(&mCustomCurve_, ADXMonotonicCurveFit_buildWaveWithNSString_(customType));
  }
}

- (void)addPointWithDouble:(jdouble)position
                 withFloat:(jfloat)period {
  jint len = ((IOSFloatArray *) nil_chk(mPeriod_))->size_ + 1;
  jint j = JavaUtilArrays_binarySearchWithDoubleArray_withDouble_(mPosition_, position);
  if (j < 0) {
    j = -j - 1;
  }
  JreStrongAssign(&mPosition_, JavaUtilArrays_copyOfWithDoubleArray_withInt_(mPosition_, len));
  JreStrongAssign(&mPeriod_, JavaUtilArrays_copyOfWithFloatArray_withInt_(mPeriod_, len));
  JreStrongAssignAndConsume(&mArea_, [IOSDoubleArray newArrayWithLength:len]);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mPosition_, j, mPosition_, j + 1, len - j - 1);
  *IOSDoubleArray_GetRef(nil_chk(mPosition_), j) = position;
  *IOSFloatArray_GetRef(nil_chk(mPeriod_), j) = period;
  mNormalized_ = false;
}

- (void)normalize {
  jdouble totalArea = 0;
  jdouble totalCount = 0;
  for (jint i = 0; i < ((IOSFloatArray *) nil_chk(mPeriod_))->size_; i++) {
    JrePlusAssignDoubleD(&totalCount, IOSFloatArray_Get(mPeriod_, i));
  }
  for (jint i = 1; i < mPeriod_->size_; i++) {
    jfloat h = (IOSFloatArray_Get(mPeriod_, i - 1) + IOSFloatArray_Get(mPeriod_, i)) / 2;
    jdouble w = IOSDoubleArray_Get(nil_chk(mPosition_), i) - IOSDoubleArray_Get(mPosition_, i - 1);
    totalArea = totalArea + w * h;
  }
  for (jint i = 0; i < mPeriod_->size_; i++) {
    JreTimesAssignFloatD(IOSFloatArray_GetRef(mPeriod_, i), totalCount / totalArea);
  }
  *IOSDoubleArray_GetRef(nil_chk(mArea_), 0) = 0;
  for (jint i = 1; i < mPeriod_->size_; i++) {
    jfloat h = (IOSFloatArray_Get(mPeriod_, i - 1) + IOSFloatArray_Get(mPeriod_, i)) / 2;
    jdouble w = IOSDoubleArray_Get(nil_chk(mPosition_), i) - IOSDoubleArray_Get(mPosition_, i - 1);
    *IOSDoubleArray_GetRef(mArea_, i) = IOSDoubleArray_Get(mArea_, i - 1) + w * h;
  }
  mNormalized_ = true;
}

- (jdouble)getPWithDouble:(jdouble)time {
  if (time < 0) {
    time = 0;
  }
  else if (time > 1) {
    time = 1;
  }
  jint index = JavaUtilArrays_binarySearchWithDoubleArray_withDouble_(mPosition_, time);
  jdouble p = 0;
  if (index > 0) {
    p = 1;
  }
  else if (index != 0) {
    index = -index - 1;
    jdouble t = time;
    jdouble m = (IOSFloatArray_Get(nil_chk(mPeriod_), index) - IOSFloatArray_Get(mPeriod_, index - 1)) / (IOSDoubleArray_Get(nil_chk(mPosition_), index) - IOSDoubleArray_Get(mPosition_, index - 1));
    p = IOSDoubleArray_Get(nil_chk(mArea_), index - 1) + (IOSFloatArray_Get(mPeriod_, index - 1) - m * IOSDoubleArray_Get(mPosition_, index - 1)) * (t - IOSDoubleArray_Get(mPosition_, index - 1)) + m * (t * t - IOSDoubleArray_Get(mPosition_, index - 1) * IOSDoubleArray_Get(mPosition_, index - 1)) / 2;
  }
  return p;
}

- (jdouble)getValueWithDouble:(jdouble)time
                   withDouble:(jdouble)phase {
  jdouble angle = phase + [self getPWithDouble:time];
  {
    jdouble x;
    switch (mType_) {
      default:
      case ADXOscillator_SIN_WAVE:
      return JavaLangMath_sinWithDouble_(PI2_ * (angle));
      case ADXOscillator_SQUARE_WAVE:
      return JavaLangMath_signumWithDouble_(0.5 - fmod(angle, 1));
      case ADXOscillator_TRIANGLE_WAVE:
      return 1 - JavaLangMath_absWithDouble_(fmod(((angle) * 4 + 1), 4) - 2);
      case ADXOscillator_SAW_WAVE:
      return (fmod((angle * 2 + 1), 2)) - 1;
      case ADXOscillator_REVERSE_SAW_WAVE:
      return (1 - (fmod((angle * 2 + 1), 2)));
      case ADXOscillator_COS_WAVE:
      return JavaLangMath_cosWithDouble_(PI2_ * (phase + angle));
      case ADXOscillator_BOUNCE:
      x = 1 - JavaLangMath_absWithDouble_(fmod(((angle) * 4), 4) - 2);
      return 1 - x * x;
      case ADXOscillator_CUSTOM:
      return [((ADXMonotonicCurveFit *) nil_chk(mCustomCurve_)) getPosWithDouble:fmod(angle, 1) withInt:0];
    }
  }
}

- (jdouble)getDPWithDouble:(jdouble)time {
  if (time <= 0) {
    time = 0.00001;
  }
  else if (time >= 1) {
    time = .999999;
  }
  jint index = JavaUtilArrays_binarySearchWithDoubleArray_withDouble_(mPosition_, time);
  jdouble p = 0;
  if (index > 0) {
    return 0;
  }
  if (index != 0) {
    index = -index - 1;
    jdouble t = time;
    jdouble m = (IOSFloatArray_Get(nil_chk(mPeriod_), index) - IOSFloatArray_Get(mPeriod_, index - 1)) / (IOSDoubleArray_Get(nil_chk(mPosition_), index) - IOSDoubleArray_Get(mPosition_, index - 1));
    p = m * t + (IOSFloatArray_Get(mPeriod_, index - 1) - m * IOSDoubleArray_Get(mPosition_, index - 1));
  }
  return p;
}

- (jdouble)getSlopeWithDouble:(jdouble)time
                   withDouble:(jdouble)phase
                   withDouble:(jdouble)dphase {
  jdouble angle = phase + [self getPWithDouble:time];
  jdouble dangle_dtime = [self getDPWithDouble:time] + dphase;
  switch (mType_) {
    default:
    case ADXOscillator_SIN_WAVE:
    return PI2_ * dangle_dtime * JavaLangMath_cosWithDouble_(PI2_ * angle);
    case ADXOscillator_SQUARE_WAVE:
    return 0;
    case ADXOscillator_TRIANGLE_WAVE:
    return 4 * dangle_dtime * JavaLangMath_signumWithDouble_(fmod(((angle) * 4 + 3), 4) - 2);
    case ADXOscillator_SAW_WAVE:
    return dangle_dtime * 2;
    case ADXOscillator_REVERSE_SAW_WAVE:
    return -dangle_dtime * 2;
    case ADXOscillator_COS_WAVE:
    return -PI2_ * dangle_dtime * JavaLangMath_sinWithDouble_(PI2_ * angle);
    case ADXOscillator_BOUNCE:
    return 4 * dangle_dtime * (fmod(((angle) * 4 + 2), 4) - 2);
    case ADXOscillator_CUSTOM:
    return [((ADXMonotonicCurveFit *) nil_chk(mCustomCurve_)) getSlopeWithDouble:fmod(angle, 1) withInt:0];
  }
}

- (void)dealloc {
  RELEASE_(mPeriod_);
  RELEASE_(mPosition_);
  RELEASE_(mArea_);
  RELEASE_(mCustomType_);
  RELEASE_(mCustomCurve_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 0, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "D", 0x0, 5, 6, -1, -1, -1, -1 },
    { NULL, "D", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "D", 0x0, 9, 6, -1, -1, -1, -1 },
    { NULL, "D", 0x1, 10, 11, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(description);
  methods[2].selector = @selector(setTypeWithInt:withNSString:);
  methods[3].selector = @selector(addPointWithDouble:withFloat:);
  methods[4].selector = @selector(normalize);
  methods[5].selector = @selector(getPWithDouble:);
  methods[6].selector = @selector(getValueWithDouble:withDouble:);
  methods[7].selector = @selector(getDPWithDouble:);
  methods[8].selector = @selector(getSlopeWithDouble:withDouble:withDouble:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x9, -1, 12, -1, -1 },
    { "mPeriod_", "[F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mPosition_", "[D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mArea_", "[D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "SIN_WAVE", "I", .constantValue.asInt = ADXOscillator_SIN_WAVE, 0x19, -1, -1, -1, -1 },
    { "SQUARE_WAVE", "I", .constantValue.asInt = ADXOscillator_SQUARE_WAVE, 0x19, -1, -1, -1, -1 },
    { "TRIANGLE_WAVE", "I", .constantValue.asInt = ADXOscillator_TRIANGLE_WAVE, 0x19, -1, -1, -1, -1 },
    { "SAW_WAVE", "I", .constantValue.asInt = ADXOscillator_SAW_WAVE, 0x19, -1, -1, -1, -1 },
    { "REVERSE_SAW_WAVE", "I", .constantValue.asInt = ADXOscillator_REVERSE_SAW_WAVE, 0x19, -1, -1, -1, -1 },
    { "COS_WAVE", "I", .constantValue.asInt = ADXOscillator_COS_WAVE, 0x19, -1, -1, -1, -1 },
    { "BOUNCE", "I", .constantValue.asInt = ADXOscillator_BOUNCE, 0x19, -1, -1, -1, -1 },
    { "CUSTOM", "I", .constantValue.asInt = ADXOscillator_CUSTOM, 0x19, -1, -1, -1, -1 },
    { "mCustomType_", "LNSString;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCustomCurve_", "LADXMonotonicCurveFit;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mType_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "PI2_", "D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mNormalized_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "toString", "setType", "ILNSString;", "addPoint", "DF", "getP", "D", "getValue", "DD", "getDP", "getSlope", "DDD", &ADXOscillator_TAG };
  static const J2ObjcClassInfo _ADXOscillator = { "Oscillator", "androidx.constraintlayout.core.motion.utils", ptrTable, methods, fields, 7, 0x1, 9, 17, -1, -1, -1, -1, -1 };
  return &_ADXOscillator;
}

@end

void ADXOscillator_init(ADXOscillator *self) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->mPeriod_, [IOSFloatArray newArrayWithFloats:(jfloat[]){  } count:0]);
  JreStrongAssignAndConsume(&self->mPosition_, [IOSDoubleArray newArrayWithDoubles:(jdouble[]){  } count:0]);
  self->PI2_ = JavaLangMath_PI * 2;
  self->mNormalized_ = false;
}

ADXOscillator *new_ADXOscillator_init() {
  J2OBJC_NEW_IMPL(ADXOscillator, init)
}

ADXOscillator *create_ADXOscillator_init() {
  J2OBJC_CREATE_IMPL(ADXOscillator, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXOscillator)
