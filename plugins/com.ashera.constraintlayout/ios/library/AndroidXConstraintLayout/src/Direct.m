//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\widgets\analyzer\Direct.java
//

#include "BasicMeasure.h"
#include "ChainHead.h"
#include "ConstraintAnchor.h"
#include "ConstraintWidget.h"
#include "ConstraintWidgetContainer.h"
#include "CoreBarrier.h"
#include "CoreGuideline.h"
#include "Direct.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "LinearSystem.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/HashSet.h"


@interface ADXDirect ()

/*!
 @brief Ask the barrier if it's resolved, and if so do a solving pass
 @param level
 @param barrier
 @param measurer
 @param isRtl
 */
+ (void)solveBarrierWithInt:(jint)level
         withADXCoreBarrier:(ADXCoreBarrier *)barrier
withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                    withInt:(jint)orientation
                withBoolean:(jboolean)isRtl;

/*!
 @brief Does an horizontal solving pass for the given widget.This will walk through the widget's
  horizontal dependencies and if they can be resolved directly, do so.
 @param level
 @param layout the widget we want to solve the dependencies
 @param measurer the measurer object to measure the widgets.
 @param isRtl
 */
+ (void)horizontalSolvingPassWithInt:(jint)level
             withADXConstraintWidget:(ADXConstraintWidget *)layout
        withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                         withBoolean:(jboolean)isRtl;

/*!
 @brief Does an vertical solving pass for the given widget.This will walk through the widget's
  vertical dependencies and if they can be resolved directly, do so.
 @param level
 @param layout the widget we want to solve the dependencies
 @param measurer the measurer object to measure the widgets.
 */
+ (void)verticalSolvingPassWithInt:(jint)level
           withADXConstraintWidget:(ADXConstraintWidget *)layout
      withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer;

/*!
 @brief Solve horizontal centering constraints
 @param level
 @param measurer
 @param widget
 @param isRtl
 */
+ (void)solveHorizontalCenterConstraintsWithInt:(jint)level
                   withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                        withADXConstraintWidget:(ADXConstraintWidget *)widget
                                    withBoolean:(jboolean)isRtl;

/*!
 @brief Solve vertical centering constraints
 @param level
 @param measurer
 @param widget
 */
+ (void)solveVerticalCenterConstraintsWithInt:(jint)level
                 withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                      withADXConstraintWidget:(ADXConstraintWidget *)widget;

/*!
 @brief Solve horizontal match constraints
 @param level
 @param measurer
 @param widget
 @param isRtl
 */
+ (void)solveHorizontalMatchConstraintWithInt:(jint)level
                      withADXConstraintWidget:(ADXConstraintWidget *)layout
                 withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                      withADXConstraintWidget:(ADXConstraintWidget *)widget
                                  withBoolean:(jboolean)isRtl;

/*!
 @brief Solve vertical match constraints
 @param level
 @param measurer
 @param widget
 */
+ (void)solveVerticalMatchConstraintWithInt:(jint)level
                    withADXConstraintWidget:(ADXConstraintWidget *)layout
               withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                    withADXConstraintWidget:(ADXConstraintWidget *)widget;

/*!
 @brief Returns true if the dimensions of the given widget are computable directly
 @param level
 @param layout the widget to check
 @return true if both dimensions are knowable by a single measure pass
 */
+ (jboolean)canMeasureWithInt:(jint)level
      withADXConstraintWidget:(ADXConstraintWidget *)layout;

@end

inline jboolean ADXDirect_get_DEBUG(void);
#define ADXDirect_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADXDirect, DEBUG, jboolean)

inline jboolean ADXDirect_get_APPLY_MATCH_PARENT(void);
#define ADXDirect_APPLY_MATCH_PARENT false
J2OBJC_STATIC_FIELD_CONSTANT(ADXDirect, APPLY_MATCH_PARENT, jboolean)

inline ADXBasicMeasure_Measure *ADXDirect_get_measure(void);
inline ADXBasicMeasure_Measure *ADXDirect_set_measure(ADXBasicMeasure_Measure *value);
static ADXBasicMeasure_Measure *ADXDirect_measure;
J2OBJC_STATIC_FIELD_OBJ(ADXDirect, measure, ADXBasicMeasure_Measure *)

inline jboolean ADXDirect_get_EARLY_TERMINATION(void);
#define ADXDirect_EARLY_TERMINATION true
J2OBJC_STATIC_FIELD_CONSTANT(ADXDirect, EARLY_TERMINATION, jboolean)

inline jint ADXDirect_get_hcount(void);
inline jint ADXDirect_set_hcount(jint value);
inline jint *ADXDirect_getRef_hcount(void);
static jint ADXDirect_hcount = 0;
J2OBJC_STATIC_FIELD_PRIMITIVE(ADXDirect, hcount, jint)

inline jint ADXDirect_get_vcount(void);
inline jint ADXDirect_set_vcount(jint value);
inline jint *ADXDirect_getRef_vcount(void);
static jint ADXDirect_vcount = 0;
J2OBJC_STATIC_FIELD_PRIMITIVE(ADXDirect, vcount, jint)

__attribute__((unused)) static void ADXDirect_solveBarrierWithInt_withADXCoreBarrier_withADXBasicMeasure_Measurer_withInt_withBoolean_(jint level, ADXCoreBarrier *barrier, id<ADXBasicMeasure_Measurer> measurer, jint orientation, jboolean isRtl);

__attribute__((unused)) static void ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(jint level, ADXConstraintWidget *layout, id<ADXBasicMeasure_Measurer> measurer, jboolean isRtl);

__attribute__((unused)) static void ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(jint level, ADXConstraintWidget *layout, id<ADXBasicMeasure_Measurer> measurer);

__attribute__((unused)) static void ADXDirect_solveHorizontalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(jint level, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget, jboolean isRtl);

__attribute__((unused)) static void ADXDirect_solveVerticalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_(jint level, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget);

__attribute__((unused)) static void ADXDirect_solveHorizontalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(jint level, ADXConstraintWidget *layout, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget, jboolean isRtl);

__attribute__((unused)) static void ADXDirect_solveVerticalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_(jint level, ADXConstraintWidget *layout, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget);

__attribute__((unused)) static jboolean ADXDirect_canMeasureWithInt_withADXConstraintWidget_(jint level, ADXConstraintWidget *layout);

J2OBJC_INITIALIZED_DEFN(ADXDirect)

@implementation ADXDirect

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXDirect_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (void)solvingPassWithADXConstraintWidgetContainer:(ADXConstraintWidgetContainer *)layout
                       withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer {
  ADXDirect_solvingPassWithADXConstraintWidgetContainer_withADXBasicMeasure_Measurer_(layout, measurer);
}

+ (void)solveBarrierWithInt:(jint)level
         withADXCoreBarrier:(ADXCoreBarrier *)barrier
withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                    withInt:(jint)orientation
                withBoolean:(jboolean)isRtl {
  ADXDirect_solveBarrierWithInt_withADXCoreBarrier_withADXBasicMeasure_Measurer_withInt_withBoolean_(level, barrier, measurer, orientation, isRtl);
}

+ (NSString *)lsWithInt:(jint)level {
  return ADXDirect_lsWithInt_(level);
}

+ (void)horizontalSolvingPassWithInt:(jint)level
             withADXConstraintWidget:(ADXConstraintWidget *)layout
        withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                         withBoolean:(jboolean)isRtl {
  ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level, layout, measurer, isRtl);
}

+ (void)verticalSolvingPassWithInt:(jint)level
           withADXConstraintWidget:(ADXConstraintWidget *)layout
      withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer {
  ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level, layout, measurer);
}

+ (void)solveHorizontalCenterConstraintsWithInt:(jint)level
                   withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                        withADXConstraintWidget:(ADXConstraintWidget *)widget
                                    withBoolean:(jboolean)isRtl {
  ADXDirect_solveHorizontalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(level, measurer, widget, isRtl);
}

+ (void)solveVerticalCenterConstraintsWithInt:(jint)level
                 withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                      withADXConstraintWidget:(ADXConstraintWidget *)widget {
  ADXDirect_solveVerticalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_(level, measurer, widget);
}

+ (void)solveHorizontalMatchConstraintWithInt:(jint)level
                      withADXConstraintWidget:(ADXConstraintWidget *)layout
                 withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                      withADXConstraintWidget:(ADXConstraintWidget *)widget
                                  withBoolean:(jboolean)isRtl {
  ADXDirect_solveHorizontalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(level, layout, measurer, widget, isRtl);
}

+ (void)solveVerticalMatchConstraintWithInt:(jint)level
                    withADXConstraintWidget:(ADXConstraintWidget *)layout
               withADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                    withADXConstraintWidget:(ADXConstraintWidget *)widget {
  ADXDirect_solveVerticalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_(level, layout, measurer, widget);
}

+ (jboolean)canMeasureWithInt:(jint)level
      withADXConstraintWidget:(ADXConstraintWidget *)layout {
  return ADXDirect_canMeasureWithInt_withADXConstraintWidget_(level, layout);
}

+ (jboolean)solveChainWithADXConstraintWidgetContainer:(ADXConstraintWidgetContainer *)container
                                   withADXLinearSystem:(ADXLinearSystem *)system
                                               withInt:(jint)orientation
                                               withInt:(jint)offset
                                      withADXChainHead:(ADXChainHead *)chainHead
                                           withBoolean:(jboolean)isChainSpread
                                           withBoolean:(jboolean)isChainSpreadInside
                                           withBoolean:(jboolean)isChainPacked {
  return ADXDirect_solveChainWithADXConstraintWidgetContainer_withADXLinearSystem_withInt_withInt_withADXChainHead_withBoolean_withBoolean_withBoolean_(container, system, orientation, offset, chainHead, isChainSpread, isChainSpreadInside, isChainPacked);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 2, 3, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 12, 13, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 14, 15, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 16, 17, -1, -1, -1, -1 },
    { NULL, "Z", 0xa, 18, 19, -1, -1, -1, -1 },
    { NULL, "Z", 0x9, 20, 21, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(solvingPassWithADXConstraintWidgetContainer:withADXBasicMeasure_Measurer:);
  methods[2].selector = @selector(solveBarrierWithInt:withADXCoreBarrier:withADXBasicMeasure_Measurer:withInt:withBoolean:);
  methods[3].selector = @selector(lsWithInt:);
  methods[4].selector = @selector(horizontalSolvingPassWithInt:withADXConstraintWidget:withADXBasicMeasure_Measurer:withBoolean:);
  methods[5].selector = @selector(verticalSolvingPassWithInt:withADXConstraintWidget:withADXBasicMeasure_Measurer:);
  methods[6].selector = @selector(solveHorizontalCenterConstraintsWithInt:withADXBasicMeasure_Measurer:withADXConstraintWidget:withBoolean:);
  methods[7].selector = @selector(solveVerticalCenterConstraintsWithInt:withADXBasicMeasure_Measurer:withADXConstraintWidget:);
  methods[8].selector = @selector(solveHorizontalMatchConstraintWithInt:withADXConstraintWidget:withADXBasicMeasure_Measurer:withADXConstraintWidget:withBoolean:);
  methods[9].selector = @selector(solveVerticalMatchConstraintWithInt:withADXConstraintWidget:withADXBasicMeasure_Measurer:withADXConstraintWidget:);
  methods[10].selector = @selector(canMeasureWithInt:withADXConstraintWidget:);
  methods[11].selector = @selector(solveChainWithADXConstraintWidgetContainer:withADXLinearSystem:withInt:withInt:withADXChainHead:withBoolean:withBoolean:withBoolean:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEBUG", "Z", .constantValue.asBOOL = ADXDirect_DEBUG, 0x1a, -1, -1, -1, -1 },
    { "APPLY_MATCH_PARENT", "Z", .constantValue.asBOOL = ADXDirect_APPLY_MATCH_PARENT, 0x1a, -1, -1, -1, -1 },
    { "measure", "LADXBasicMeasure_Measure;", .constantValue.asLong = 0, 0xa, -1, 22, -1, -1 },
    { "EARLY_TERMINATION", "Z", .constantValue.asBOOL = ADXDirect_EARLY_TERMINATION, 0x1a, -1, -1, -1, -1 },
    { "hcount", "I", .constantValue.asLong = 0, 0xa, -1, 23, -1, -1 },
    { "vcount", "I", .constantValue.asLong = 0, 0xa, -1, 24, -1, -1 },
  };
  static const void *ptrTable[] = { "solvingPass", "LADXConstraintWidgetContainer;LADXBasicMeasure_Measurer;", "solveBarrier", "ILADXCoreBarrier;LADXBasicMeasure_Measurer;IZ", "ls", "I", "horizontalSolvingPass", "ILADXConstraintWidget;LADXBasicMeasure_Measurer;Z", "verticalSolvingPass", "ILADXConstraintWidget;LADXBasicMeasure_Measurer;", "solveHorizontalCenterConstraints", "ILADXBasicMeasure_Measurer;LADXConstraintWidget;Z", "solveVerticalCenterConstraints", "ILADXBasicMeasure_Measurer;LADXConstraintWidget;", "solveHorizontalMatchConstraint", "ILADXConstraintWidget;LADXBasicMeasure_Measurer;LADXConstraintWidget;Z", "solveVerticalMatchConstraint", "ILADXConstraintWidget;LADXBasicMeasure_Measurer;LADXConstraintWidget;", "canMeasure", "ILADXConstraintWidget;", "solveChain", "LADXConstraintWidgetContainer;LADXLinearSystem;IILADXChainHead;ZZZ", &ADXDirect_measure, &ADXDirect_hcount, &ADXDirect_vcount };
  static const J2ObjcClassInfo _ADXDirect = { "Direct", "androidx.constraintlayout.core.widgets.analyzer", ptrTable, methods, fields, 7, 0x1, 12, 6, -1, -1, -1, -1, -1 };
  return &_ADXDirect;
}

+ (void)initialize {
  if (self == [ADXDirect class]) {
    JreStrongAssignAndConsume(&ADXDirect_measure, new_ADXBasicMeasure_Measure_init());
    J2OBJC_SET_INITIALIZED(ADXDirect)
  }
}

@end

void ADXDirect_init(ADXDirect *self) {
  NSObject_init(self);
}

ADXDirect *new_ADXDirect_init() {
  J2OBJC_NEW_IMPL(ADXDirect, init)
}

ADXDirect *create_ADXDirect_init() {
  J2OBJC_CREATE_IMPL(ADXDirect, init)
}

void ADXDirect_solvingPassWithADXConstraintWidgetContainer_withADXBasicMeasure_Measurer_(ADXConstraintWidgetContainer *layout, id<ADXBasicMeasure_Measurer> measurer) {
  ADXDirect_initialize();
  ADXConstraintWidget_DimensionBehaviour *horizontal = JreRetainedLocalValue([((ADXConstraintWidgetContainer *) nil_chk(layout)) getHorizontalDimensionBehaviour]);
  ADXConstraintWidget_DimensionBehaviour *vertical = JreRetainedLocalValue([layout getVerticalDimensionBehaviour]);
  ADXDirect_hcount = 0;
  ADXDirect_vcount = 0;
  jlong time = 0;
  [layout resetFinalResolution];
  JavaUtilArrayList *children = JreRetainedLocalValue([layout getChildren]);
  jint count = [((JavaUtilArrayList *) nil_chk(children)) size];
  for (jint i = 0; i < count; i++) {
    ADXConstraintWidget *child = JreRetainedLocalValue([children getWithInt:i]);
    [((ADXConstraintWidget *) nil_chk(child)) resetFinalResolution];
  }
  jboolean isRtl = [layout isRtl];
  if (horizontal == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, FIXED)) {
    [layout setFinalHorizontalWithInt:0 withInt:[layout getWidth]];
  }
  else {
    [layout setFinalLeftWithInt:0];
  }
  jboolean hasGuideline = false;
  jboolean hasBarrier = false;
  for (jint i = 0; i < count; i++) {
    ADXConstraintWidget *child = JreRetainedLocalValue([children getWithInt:i]);
    if ([child isKindOfClass:[ADXCoreGuideline class]]) {
      ADXCoreGuideline *guideline = (ADXCoreGuideline *) child;
      if ([((ADXCoreGuideline *) nil_chk(guideline)) getOrientation] == ADXCoreGuideline_VERTICAL) {
        if ([guideline getRelativeBegin] != -1) {
          [guideline setFinalValueWithInt:[guideline getRelativeBegin]];
        }
        else if ([guideline getRelativeEnd] != -1 && [layout isResolvedHorizontally]) {
          [guideline setFinalValueWithInt:[layout getWidth] - [guideline getRelativeEnd]];
        }
        else if ([layout isResolvedHorizontally]) {
          jint position = JreFpToInt((0.5f + [guideline getRelativePercent] * [layout getWidth]));
          [guideline setFinalValueWithInt:position];
        }
        hasGuideline = true;
      }
    }
    else if ([child isKindOfClass:[ADXCoreBarrier class]]) {
      ADXCoreBarrier *barrier = (ADXCoreBarrier *) child;
      if ([((ADXCoreBarrier *) nil_chk(barrier)) getOrientation] == ADXConstraintWidget_HORIZONTAL) {
        hasBarrier = true;
      }
    }
  }
  if (hasGuideline) {
    for (jint i = 0; i < count; i++) {
      ADXConstraintWidget *child = JreRetainedLocalValue([children getWithInt:i]);
      if ([child isKindOfClass:[ADXCoreGuideline class]]) {
        ADXCoreGuideline *guideline = (ADXCoreGuideline *) child;
        if ([((ADXCoreGuideline *) nil_chk(guideline)) getOrientation] == ADXCoreGuideline_VERTICAL) {
          ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(0, guideline, measurer, isRtl);
        }
      }
    }
  }
  ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(0, layout, measurer, isRtl);
  if (hasBarrier) {
    for (jint i = 0; i < count; i++) {
      ADXConstraintWidget *child = JreRetainedLocalValue([children getWithInt:i]);
      if ([child isKindOfClass:[ADXCoreBarrier class]]) {
        ADXCoreBarrier *barrier = (ADXCoreBarrier *) child;
        if ([((ADXCoreBarrier *) nil_chk(barrier)) getOrientation] == ADXConstraintWidget_HORIZONTAL) {
          ADXDirect_solveBarrierWithInt_withADXCoreBarrier_withADXBasicMeasure_Measurer_withInt_withBoolean_(0, barrier, measurer, ADXConstraintWidget_HORIZONTAL, isRtl);
        }
      }
    }
  }
  if (vertical == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, FIXED)) {
    [layout setFinalVerticalWithInt:0 withInt:[layout getHeight]];
  }
  else {
    [layout setFinalTopWithInt:0];
  }
  hasGuideline = false;
  hasBarrier = false;
  for (jint i = 0; i < count; i++) {
    ADXConstraintWidget *child = JreRetainedLocalValue([children getWithInt:i]);
    if ([child isKindOfClass:[ADXCoreGuideline class]]) {
      ADXCoreGuideline *guideline = (ADXCoreGuideline *) child;
      if ([((ADXCoreGuideline *) nil_chk(guideline)) getOrientation] == ADXCoreGuideline_HORIZONTAL) {
        if ([guideline getRelativeBegin] != -1) {
          [guideline setFinalValueWithInt:[guideline getRelativeBegin]];
        }
        else if ([guideline getRelativeEnd] != -1 && [layout isResolvedVertically]) {
          [guideline setFinalValueWithInt:[layout getHeight] - [guideline getRelativeEnd]];
        }
        else if ([layout isResolvedVertically]) {
          jint position = JreFpToInt((0.5f + [guideline getRelativePercent] * [layout getHeight]));
          [guideline setFinalValueWithInt:position];
        }
        hasGuideline = true;
      }
    }
    else if ([child isKindOfClass:[ADXCoreBarrier class]]) {
      ADXCoreBarrier *barrier = (ADXCoreBarrier *) child;
      if ([((ADXCoreBarrier *) nil_chk(barrier)) getOrientation] == ADXConstraintWidget_VERTICAL) {
        hasBarrier = true;
      }
    }
  }
  if (hasGuideline) {
    for (jint i = 0; i < count; i++) {
      ADXConstraintWidget *child = JreRetainedLocalValue([children getWithInt:i]);
      if ([child isKindOfClass:[ADXCoreGuideline class]]) {
        ADXCoreGuideline *guideline = (ADXCoreGuideline *) child;
        if ([((ADXCoreGuideline *) nil_chk(guideline)) getOrientation] == ADXCoreGuideline_HORIZONTAL) {
          ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(1, guideline, measurer);
        }
      }
    }
  }
  ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(0, layout, measurer);
  if (hasBarrier) {
    for (jint i = 0; i < count; i++) {
      ADXConstraintWidget *child = JreRetainedLocalValue([children getWithInt:i]);
      if ([child isKindOfClass:[ADXCoreBarrier class]]) {
        ADXCoreBarrier *barrier = (ADXCoreBarrier *) child;
        if ([((ADXCoreBarrier *) nil_chk(barrier)) getOrientation] == ADXConstraintWidget_VERTICAL) {
          ADXDirect_solveBarrierWithInt_withADXCoreBarrier_withADXBasicMeasure_Measurer_withInt_withBoolean_(0, barrier, measurer, ADXConstraintWidget_VERTICAL, isRtl);
        }
      }
    }
  }
  for (jint i = 0; i < count; i++) {
    ADXConstraintWidget *child = JreRetainedLocalValue([children getWithInt:i]);
    if ([((ADXConstraintWidget *) nil_chk(child)) isMeasureRequested] && ADXDirect_canMeasureWithInt_withADXConstraintWidget_(0, child)) {
      ADXConstraintWidgetContainer_measureWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXBasicMeasure_Measure_withInt_(0, child, measurer, ADXDirect_measure, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
      if ([child isKindOfClass:[ADXCoreGuideline class]]) {
        if ([((ADXCoreGuideline *) child) getOrientation] == ADXCoreGuideline_HORIZONTAL) {
          ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(0, child, measurer);
        }
        else {
          ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(0, child, measurer, isRtl);
        }
      }
      else {
        ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(0, child, measurer, isRtl);
        ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(0, child, measurer);
      }
    }
  }
}

void ADXDirect_solveBarrierWithInt_withADXCoreBarrier_withADXBasicMeasure_Measurer_withInt_withBoolean_(jint level, ADXCoreBarrier *barrier, id<ADXBasicMeasure_Measurer> measurer, jint orientation, jboolean isRtl) {
  ADXDirect_initialize();
  if ([((ADXCoreBarrier *) nil_chk(barrier)) allSolved]) {
    if (orientation == ADXConstraintWidget_HORIZONTAL) {
      ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, barrier, measurer, isRtl);
    }
    else {
      ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, barrier, measurer);
    }
  }
}

NSString *ADXDirect_lsWithInt_(jint level) {
  ADXDirect_initialize();
  JavaLangStringBuilder *builder = create_JavaLangStringBuilder_init();
  for (jint i = 0; i < level; i++) {
    [builder appendWithNSString:@"  "];
  }
  [builder appendWithNSString:JreStrcat("$I$", @"+-(", level, @") ")];
  return [builder description];
}

void ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(jint level, ADXConstraintWidget *layout, id<ADXBasicMeasure_Measurer> measurer, jboolean isRtl) {
  ADXDirect_initialize();
  if ([((ADXConstraintWidget *) nil_chk(layout)) isHorizontalSolvingPassDone]) {
    return;
  }
  ADXDirect_hcount++;
  if (!([layout isKindOfClass:[ADXConstraintWidgetContainer class]]) && [layout isMeasureRequested] && ADXDirect_canMeasureWithInt_withADXConstraintWidget_(level + 1, layout)) {
    ADXBasicMeasure_Measure *measure = create_ADXBasicMeasure_Measure_init();
    ADXConstraintWidgetContainer_measureWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXBasicMeasure_Measure_withInt_(level + 1, layout, measurer, measure, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
  }
  ADXConstraintAnchor *left = JreRetainedLocalValue([layout getAnchorWithADXConstraintAnchor_Type:JreLoadEnum(ADXConstraintAnchor_Type, LEFT)]);
  ADXConstraintAnchor *right = JreRetainedLocalValue([layout getAnchorWithADXConstraintAnchor_Type:JreLoadEnum(ADXConstraintAnchor_Type, RIGHT)]);
  jint l = [((ADXConstraintAnchor *) nil_chk(left)) getFinalValue];
  jint r = [((ADXConstraintAnchor *) nil_chk(right)) getFinalValue];
  if ([left getDependents] != nil && [left hasFinalValue]) {
    for (ADXConstraintAnchor * __strong first in nil_chk([left getDependents])) {
      ADXConstraintWidget *widget = JreRetainedLocalValue(((ADXConstraintAnchor *) nil_chk(first))->mOwner_);
      jint x1 = 0;
      jint x2 = 0;
      jboolean canMeasure = ADXDirect_canMeasureWithInt_withADXConstraintWidget_(level + 1, widget);
      if ([((ADXConstraintWidget *) nil_chk(widget)) isMeasureRequested] && canMeasure) {
        ADXBasicMeasure_Measure *measure = create_ADXBasicMeasure_Measure_init();
        ADXConstraintWidgetContainer_measureWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXBasicMeasure_Measure_withInt_(level + 1, widget, measurer, measure, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
      }
      if ([widget getHorizontalDimensionBehaviour] != JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) || canMeasure) {
        if ([widget isMeasureRequested]) {
          continue;
        }
        if (first == widget->mLeft_ && ((ADXConstraintAnchor *) nil_chk(widget->mRight_))->mTarget_ == nil) {
          x1 = l + [((ADXConstraintAnchor *) nil_chk(widget->mLeft_)) getMargin];
          x2 = x1 + [widget getWidth];
          [widget setFinalHorizontalWithInt:x1 withInt:x2];
          ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, widget, measurer, isRtl);
        }
        else if (first == widget->mRight_ && ((ADXConstraintAnchor *) nil_chk(widget->mLeft_))->mTarget_ == nil) {
          x2 = l - [((ADXConstraintAnchor *) nil_chk(widget->mRight_)) getMargin];
          x1 = x2 - [widget getWidth];
          [widget setFinalHorizontalWithInt:x1 withInt:x2];
          ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, widget, measurer, isRtl);
        }
        else if (first == widget->mLeft_ && ((ADXConstraintAnchor *) nil_chk(widget->mRight_))->mTarget_ != nil && [widget->mRight_->mTarget_ hasFinalValue] && ![widget isInHorizontalChain]) {
          ADXDirect_solveHorizontalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(level + 1, measurer, widget, isRtl);
        }
      }
      else if ([widget getHorizontalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && widget->mMatchConstraintMaxWidth_ >= 0 && widget->mMatchConstraintMinWidth_ >= 0 && ([widget getVisibility] == ADXConstraintWidget_GONE || ((widget->mMatchConstraintDefaultWidth_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD) && [widget getDimensionRatio] == 0)) && ![widget isInHorizontalChain] && ![widget isInVirtualLayout]) {
        jboolean bothConnected = (first == widget->mLeft_ && ((ADXConstraintAnchor *) nil_chk(widget->mRight_))->mTarget_ != nil && [widget->mRight_->mTarget_ hasFinalValue]) || (first == widget->mRight_ && ((ADXConstraintAnchor *) nil_chk(widget->mLeft_))->mTarget_ != nil && [widget->mLeft_->mTarget_ hasFinalValue]);
        if (bothConnected && ![widget isInHorizontalChain]) {
          ADXDirect_solveHorizontalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(level + 1, layout, measurer, widget, isRtl);
        }
      }
    }
  }
  if ([layout isKindOfClass:[ADXCoreGuideline class]]) {
    return;
  }
  if ([right getDependents] != nil && [right hasFinalValue]) {
    for (ADXConstraintAnchor * __strong first in nil_chk([right getDependents])) {
      ADXConstraintWidget *widget = JreRetainedLocalValue(((ADXConstraintAnchor *) nil_chk(first))->mOwner_);
      jboolean canMeasure = ADXDirect_canMeasureWithInt_withADXConstraintWidget_(level + 1, widget);
      if ([((ADXConstraintWidget *) nil_chk(widget)) isMeasureRequested] && canMeasure) {
        ADXBasicMeasure_Measure *measure = create_ADXBasicMeasure_Measure_init();
        ADXConstraintWidgetContainer_measureWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXBasicMeasure_Measure_withInt_(level + 1, widget, measurer, measure, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
      }
      jint x1 = 0;
      jint x2 = 0;
      jboolean bothConnected = (first == widget->mLeft_ && ((ADXConstraintAnchor *) nil_chk(widget->mRight_))->mTarget_ != nil && [widget->mRight_->mTarget_ hasFinalValue]) || (first == widget->mRight_ && ((ADXConstraintAnchor *) nil_chk(widget->mLeft_))->mTarget_ != nil && [widget->mLeft_->mTarget_ hasFinalValue]);
      if ([widget getHorizontalDimensionBehaviour] != JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) || canMeasure) {
        if ([widget isMeasureRequested]) {
          continue;
        }
        if (first == widget->mLeft_ && ((ADXConstraintAnchor *) nil_chk(widget->mRight_))->mTarget_ == nil) {
          x1 = r + [((ADXConstraintAnchor *) nil_chk(widget->mLeft_)) getMargin];
          x2 = x1 + [widget getWidth];
          [widget setFinalHorizontalWithInt:x1 withInt:x2];
          ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, widget, measurer, isRtl);
        }
        else if (first == widget->mRight_ && ((ADXConstraintAnchor *) nil_chk(widget->mLeft_))->mTarget_ == nil) {
          x2 = r - [((ADXConstraintAnchor *) nil_chk(widget->mRight_)) getMargin];
          x1 = x2 - [widget getWidth];
          [widget setFinalHorizontalWithInt:x1 withInt:x2];
          ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, widget, measurer, isRtl);
        }
        else if (bothConnected && ![widget isInHorizontalChain]) {
          ADXDirect_solveHorizontalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(level + 1, measurer, widget, isRtl);
        }
      }
      else if ([widget getHorizontalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && widget->mMatchConstraintMaxWidth_ >= 0 && widget->mMatchConstraintMinWidth_ >= 0 && ([widget getVisibility] == ADXConstraintWidget_GONE || ((widget->mMatchConstraintDefaultWidth_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD) && [widget getDimensionRatio] == 0)) && ![widget isInHorizontalChain] && ![widget isInVirtualLayout]) {
        if (bothConnected && ![widget isInHorizontalChain]) {
          ADXDirect_solveHorizontalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(level + 1, layout, measurer, widget, isRtl);
        }
      }
    }
  }
  [layout markHorizontalSolvingPassDone];
}

void ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(jint level, ADXConstraintWidget *layout, id<ADXBasicMeasure_Measurer> measurer) {
  ADXDirect_initialize();
  if ([((ADXConstraintWidget *) nil_chk(layout)) isVerticalSolvingPassDone]) {
    return;
  }
  ADXDirect_vcount++;
  if (!([layout isKindOfClass:[ADXConstraintWidgetContainer class]]) && [layout isMeasureRequested] && ADXDirect_canMeasureWithInt_withADXConstraintWidget_(level + 1, layout)) {
    ADXBasicMeasure_Measure *measure = create_ADXBasicMeasure_Measure_init();
    ADXConstraintWidgetContainer_measureWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXBasicMeasure_Measure_withInt_(level + 1, layout, measurer, measure, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
  }
  ADXConstraintAnchor *top = JreRetainedLocalValue([layout getAnchorWithADXConstraintAnchor_Type:JreLoadEnum(ADXConstraintAnchor_Type, TOP)]);
  ADXConstraintAnchor *bottom = JreRetainedLocalValue([layout getAnchorWithADXConstraintAnchor_Type:JreLoadEnum(ADXConstraintAnchor_Type, BOTTOM)]);
  jint t = [((ADXConstraintAnchor *) nil_chk(top)) getFinalValue];
  jint b = [((ADXConstraintAnchor *) nil_chk(bottom)) getFinalValue];
  if ([top getDependents] != nil && [top hasFinalValue]) {
    for (ADXConstraintAnchor * __strong first in nil_chk([top getDependents])) {
      ADXConstraintWidget *widget = JreRetainedLocalValue(((ADXConstraintAnchor *) nil_chk(first))->mOwner_);
      jint y1 = 0;
      jint y2 = 0;
      jboolean canMeasure = ADXDirect_canMeasureWithInt_withADXConstraintWidget_(level + 1, widget);
      if ([((ADXConstraintWidget *) nil_chk(widget)) isMeasureRequested] && canMeasure) {
        ADXBasicMeasure_Measure *measure = create_ADXBasicMeasure_Measure_init();
        ADXConstraintWidgetContainer_measureWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXBasicMeasure_Measure_withInt_(level + 1, widget, measurer, measure, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
      }
      if ([widget getVerticalDimensionBehaviour] != JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) || canMeasure) {
        if ([widget isMeasureRequested]) {
          continue;
        }
        if (first == widget->mTop_ && ((ADXConstraintAnchor *) nil_chk(widget->mBottom_))->mTarget_ == nil) {
          y1 = t + [((ADXConstraintAnchor *) nil_chk(widget->mTop_)) getMargin];
          y2 = y1 + [widget getHeight];
          [widget setFinalVerticalWithInt:y1 withInt:y2];
          ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, widget, measurer);
        }
        else if (first == widget->mBottom_ && ((ADXConstraintAnchor *) nil_chk(widget->mBottom_))->mTarget_ == nil) {
          y2 = t - [((ADXConstraintAnchor *) nil_chk(widget->mBottom_)) getMargin];
          y1 = y2 - [widget getHeight];
          [widget setFinalVerticalWithInt:y1 withInt:y2];
          ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, widget, measurer);
        }
        else if (first == widget->mTop_ && ((ADXConstraintAnchor *) nil_chk(widget->mBottom_))->mTarget_ != nil && [widget->mBottom_->mTarget_ hasFinalValue]) {
          ADXDirect_solveVerticalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_(level + 1, measurer, widget);
        }
      }
      else if ([widget getVerticalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && widget->mMatchConstraintMaxHeight_ >= 0 && widget->mMatchConstraintMinHeight_ >= 0 && ([widget getVisibility] == ADXConstraintWidget_GONE || ((widget->mMatchConstraintDefaultHeight_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD) && [widget getDimensionRatio] == 0)) && ![widget isInVerticalChain] && ![widget isInVirtualLayout]) {
        jboolean bothConnected = (first == widget->mTop_ && ((ADXConstraintAnchor *) nil_chk(widget->mBottom_))->mTarget_ != nil && [widget->mBottom_->mTarget_ hasFinalValue]) || (first == widget->mBottom_ && ((ADXConstraintAnchor *) nil_chk(widget->mTop_))->mTarget_ != nil && [widget->mTop_->mTarget_ hasFinalValue]);
        if (bothConnected && ![widget isInVerticalChain]) {
          ADXDirect_solveVerticalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_(level + 1, layout, measurer, widget);
        }
      }
    }
  }
  if ([layout isKindOfClass:[ADXCoreGuideline class]]) {
    return;
  }
  if ([bottom getDependents] != nil && [bottom hasFinalValue]) {
    for (ADXConstraintAnchor * __strong first in nil_chk([bottom getDependents])) {
      ADXConstraintWidget *widget = JreRetainedLocalValue(((ADXConstraintAnchor *) nil_chk(first))->mOwner_);
      jboolean canMeasure = ADXDirect_canMeasureWithInt_withADXConstraintWidget_(level + 1, widget);
      if ([((ADXConstraintWidget *) nil_chk(widget)) isMeasureRequested] && canMeasure) {
        ADXBasicMeasure_Measure *measure = create_ADXBasicMeasure_Measure_init();
        ADXConstraintWidgetContainer_measureWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXBasicMeasure_Measure_withInt_(level + 1, widget, measurer, measure, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
      }
      jint y1 = 0;
      jint y2 = 0;
      jboolean bothConnected = (first == widget->mTop_ && ((ADXConstraintAnchor *) nil_chk(widget->mBottom_))->mTarget_ != nil && [widget->mBottom_->mTarget_ hasFinalValue]) || (first == widget->mBottom_ && ((ADXConstraintAnchor *) nil_chk(widget->mTop_))->mTarget_ != nil && [widget->mTop_->mTarget_ hasFinalValue]);
      if ([widget getVerticalDimensionBehaviour] != JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) || canMeasure) {
        if ([widget isMeasureRequested]) {
          continue;
        }
        if (first == widget->mTop_ && ((ADXConstraintAnchor *) nil_chk(widget->mBottom_))->mTarget_ == nil) {
          y1 = b + [((ADXConstraintAnchor *) nil_chk(widget->mTop_)) getMargin];
          y2 = y1 + [widget getHeight];
          [widget setFinalVerticalWithInt:y1 withInt:y2];
          ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, widget, measurer);
        }
        else if (first == widget->mBottom_ && ((ADXConstraintAnchor *) nil_chk(widget->mTop_))->mTarget_ == nil) {
          y2 = b - [((ADXConstraintAnchor *) nil_chk(widget->mBottom_)) getMargin];
          y1 = y2 - [widget getHeight];
          [widget setFinalVerticalWithInt:y1 withInt:y2];
          ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, widget, measurer);
        }
        else if (bothConnected && ![widget isInVerticalChain]) {
          ADXDirect_solveVerticalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_(level + 1, measurer, widget);
        }
      }
      else if ([widget getVerticalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && widget->mMatchConstraintMaxHeight_ >= 0 && widget->mMatchConstraintMinHeight_ >= 0 && ([widget getVisibility] == ADXConstraintWidget_GONE || ((widget->mMatchConstraintDefaultHeight_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD) && [widget getDimensionRatio] == 0)) && ![widget isInVerticalChain] && ![widget isInVirtualLayout]) {
        if (bothConnected && ![widget isInVerticalChain]) {
          ADXDirect_solveVerticalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_(level + 1, layout, measurer, widget);
        }
      }
    }
  }
  ADXConstraintAnchor *baseline = JreRetainedLocalValue([layout getAnchorWithADXConstraintAnchor_Type:JreLoadEnum(ADXConstraintAnchor_Type, BASELINE)]);
  if ([((ADXConstraintAnchor *) nil_chk(baseline)) getDependents] != nil && [baseline hasFinalValue]) {
    jint baselineValue = [baseline getFinalValue];
    for (ADXConstraintAnchor * __strong first in nil_chk([baseline getDependents])) {
      ADXConstraintWidget *widget = JreRetainedLocalValue(((ADXConstraintAnchor *) nil_chk(first))->mOwner_);
      jboolean canMeasure = ADXDirect_canMeasureWithInt_withADXConstraintWidget_(level + 1, widget);
      if ([((ADXConstraintWidget *) nil_chk(widget)) isMeasureRequested] && canMeasure) {
        ADXBasicMeasure_Measure *measure = create_ADXBasicMeasure_Measure_init();
        ADXConstraintWidgetContainer_measureWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXBasicMeasure_Measure_withInt_(level + 1, widget, measurer, measure, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
      }
      if ([widget getVerticalDimensionBehaviour] != JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) || canMeasure) {
        if ([widget isMeasureRequested]) {
          continue;
        }
        if (first == widget->mBaseline_) {
          [widget setFinalBaselineWithInt:baselineValue + [first getMargin]];
          ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, widget, measurer);
        }
      }
    }
  }
  [layout markVerticalSolvingPassDone];
}

void ADXDirect_solveHorizontalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(jint level, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget, jboolean isRtl) {
  ADXDirect_initialize();
  jint x1;
  jint x2;
  jfloat bias = [((ADXConstraintWidget *) nil_chk(widget)) getHorizontalBiasPercent];
  jint start = [((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(widget->mLeft_))->mTarget_)) getFinalValue];
  jint end = [((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(widget->mRight_))->mTarget_)) getFinalValue];
  jint s1 = start + [((ADXConstraintAnchor *) nil_chk(widget->mLeft_)) getMargin];
  jint s2 = end - [((ADXConstraintAnchor *) nil_chk(widget->mRight_)) getMargin];
  if (start == end) {
    bias = 0.5f;
    s1 = start;
    s2 = end;
  }
  jint width = [widget getWidth];
  jint distance = s2 - s1 - width;
  if (s1 > s2) {
    distance = s1 - s2 - width;
  }
  jint d1;
  if (distance > 0) {
    d1 = JreFpToInt((0.5f + bias * distance));
  }
  else {
    d1 = JreFpToInt((bias * distance));
  }
  x1 = s1 + d1;
  x2 = x1 + width;
  if (s1 > s2) {
    x1 = s1 + d1;
    x2 = x1 - width;
  }
  [widget setFinalHorizontalWithInt:x1 withInt:x2];
  ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, widget, measurer, isRtl);
}

void ADXDirect_solveVerticalCenterConstraintsWithInt_withADXBasicMeasure_Measurer_withADXConstraintWidget_(jint level, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget) {
  ADXDirect_initialize();
  jint y1;
  jint y2;
  jfloat bias = [((ADXConstraintWidget *) nil_chk(widget)) getVerticalBiasPercent];
  jint start = [((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(widget->mTop_))->mTarget_)) getFinalValue];
  jint end = [((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(widget->mBottom_))->mTarget_)) getFinalValue];
  jint s1 = start + [((ADXConstraintAnchor *) nil_chk(widget->mTop_)) getMargin];
  jint s2 = end - [((ADXConstraintAnchor *) nil_chk(widget->mBottom_)) getMargin];
  if (start == end) {
    bias = 0.5f;
    s1 = start;
    s2 = end;
  }
  jint height = [widget getHeight];
  jint distance = s2 - s1 - height;
  if (s1 > s2) {
    distance = s1 - s2 - height;
  }
  jint d1;
  if (distance > 0) {
    d1 = JreFpToInt((0.5f + bias * distance));
  }
  else {
    d1 = JreFpToInt((bias * distance));
  }
  y1 = s1 + d1;
  y2 = y1 + height;
  if (s1 > s2) {
    y1 = s1 - d1;
    y2 = y1 - height;
  }
  [widget setFinalVerticalWithInt:y1 withInt:y2];
  ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, widget, measurer);
}

void ADXDirect_solveHorizontalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_withBoolean_(jint level, ADXConstraintWidget *layout, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget, jboolean isRtl) {
  ADXDirect_initialize();
  jint x1;
  jint x2;
  jfloat bias = [((ADXConstraintWidget *) nil_chk(widget)) getHorizontalBiasPercent];
  jint s1 = [((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(widget->mLeft_))->mTarget_)) getFinalValue] + [((ADXConstraintAnchor *) nil_chk(widget->mLeft_)) getMargin];
  jint s2 = [((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(widget->mRight_))->mTarget_)) getFinalValue] - [((ADXConstraintAnchor *) nil_chk(widget->mRight_)) getMargin];
  if (s2 >= s1) {
    jint width = [widget getWidth];
    if ([widget getVisibility] != ADXConstraintWidget_GONE) {
      if (widget->mMatchConstraintDefaultWidth_ == ADXConstraintWidget_MATCH_CONSTRAINT_PERCENT) {
        jint parentWidth = 0;
        if ([layout isKindOfClass:[ADXConstraintWidgetContainer class]]) {
          parentWidth = [((ADXConstraintWidget *) nil_chk(layout)) getWidth];
        }
        else {
          parentWidth = [((ADXConstraintWidget *) nil_chk([((ADXConstraintWidget *) nil_chk(layout)) getParent])) getWidth];
        }
        width = JreFpToInt((0.5f * [widget getHorizontalBiasPercent] * parentWidth));
      }
      else if (widget->mMatchConstraintDefaultWidth_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD) {
        width = s2 - s1;
      }
      width = JavaLangMath_maxWithInt_withInt_(widget->mMatchConstraintMinWidth_, width);
      if (widget->mMatchConstraintMaxWidth_ > 0) {
        width = JavaLangMath_minWithInt_withInt_(widget->mMatchConstraintMaxWidth_, width);
      }
    }
    jint distance = s2 - s1 - width;
    jint d1 = JreFpToInt((0.5f + bias * distance));
    x1 = s1 + d1;
    x2 = x1 + width;
    [widget setFinalHorizontalWithInt:x1 withInt:x2];
    ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, widget, measurer, isRtl);
  }
}

void ADXDirect_solveVerticalMatchConstraintWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXConstraintWidget_(jint level, ADXConstraintWidget *layout, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget) {
  ADXDirect_initialize();
  jint y1;
  jint y2;
  jfloat bias = [((ADXConstraintWidget *) nil_chk(widget)) getVerticalBiasPercent];
  jint s1 = [((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(widget->mTop_))->mTarget_)) getFinalValue] + [((ADXConstraintAnchor *) nil_chk(widget->mTop_)) getMargin];
  jint s2 = [((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(widget->mBottom_))->mTarget_)) getFinalValue] - [((ADXConstraintAnchor *) nil_chk(widget->mBottom_)) getMargin];
  if (s2 >= s1) {
    jint height = [widget getHeight];
    if ([widget getVisibility] != ADXConstraintWidget_GONE) {
      if (widget->mMatchConstraintDefaultHeight_ == ADXConstraintWidget_MATCH_CONSTRAINT_PERCENT) {
        jint parentHeight = 0;
        if ([layout isKindOfClass:[ADXConstraintWidgetContainer class]]) {
          parentHeight = [((ADXConstraintWidget *) nil_chk(layout)) getHeight];
        }
        else {
          parentHeight = [((ADXConstraintWidget *) nil_chk([((ADXConstraintWidget *) nil_chk(layout)) getParent])) getHeight];
        }
        height = JreFpToInt((0.5f * bias * parentHeight));
      }
      else if (widget->mMatchConstraintDefaultHeight_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD) {
        height = s2 - s1;
      }
      height = JavaLangMath_maxWithInt_withInt_(widget->mMatchConstraintMinHeight_, height);
      if (widget->mMatchConstraintMaxHeight_ > 0) {
        height = JavaLangMath_minWithInt_withInt_(widget->mMatchConstraintMaxHeight_, height);
      }
    }
    jint distance = s2 - s1 - height;
    jint d1 = JreFpToInt((0.5f + bias * distance));
    y1 = s1 + d1;
    y2 = y1 + height;
    [widget setFinalVerticalWithInt:y1 withInt:y2];
    ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, widget, measurer);
  }
}

jboolean ADXDirect_canMeasureWithInt_withADXConstraintWidget_(jint level, ADXConstraintWidget *layout) {
  ADXDirect_initialize();
  ADXConstraintWidget_DimensionBehaviour *horizontalBehaviour = JreRetainedLocalValue([((ADXConstraintWidget *) nil_chk(layout)) getHorizontalDimensionBehaviour]);
  ADXConstraintWidget_DimensionBehaviour *verticalBehaviour = JreRetainedLocalValue([layout getVerticalDimensionBehaviour]);
  ADXConstraintWidgetContainer *parent = [layout getParent] != nil ? (ADXConstraintWidgetContainer *) cast_chk([layout getParent], [ADXConstraintWidgetContainer class]) : nil;
  jboolean isParentHorizontalFixed = parent != nil && [parent getHorizontalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, FIXED);
  jboolean isParentVerticalFixed = parent != nil && [parent getVerticalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, FIXED);
  jboolean isHorizontalFixed = horizontalBehaviour == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, FIXED) || [layout isResolvedHorizontally] || horizontalBehaviour == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, WRAP_CONTENT) || (horizontalBehaviour == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && layout->mMatchConstraintDefaultWidth_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD && layout->mDimensionRatio_ == 0 && [layout hasDanglingDimensionWithInt:ADXConstraintWidget_HORIZONTAL]) || (horizontalBehaviour == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && layout->mMatchConstraintDefaultWidth_ == ADXConstraintWidget_MATCH_CONSTRAINT_WRAP && [layout hasResolvedTargetsWithInt:ADXConstraintWidget_HORIZONTAL withInt:[layout getWidth]]);
  jboolean isVerticalFixed = verticalBehaviour == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, FIXED) || [layout isResolvedVertically] || verticalBehaviour == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, WRAP_CONTENT) || (verticalBehaviour == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && layout->mMatchConstraintDefaultHeight_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD && layout->mDimensionRatio_ == 0 && [layout hasDanglingDimensionWithInt:ADXConstraintWidget_VERTICAL]) || (horizontalBehaviour == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && layout->mMatchConstraintDefaultHeight_ == ADXConstraintWidget_MATCH_CONSTRAINT_WRAP && [layout hasResolvedTargetsWithInt:ADXConstraintWidget_VERTICAL withInt:[layout getHeight]]);
  if (layout->mDimensionRatio_ > 0 && (isHorizontalFixed || isVerticalFixed)) {
    return true;
  }
  return isHorizontalFixed && isVerticalFixed;
}

jboolean ADXDirect_solveChainWithADXConstraintWidgetContainer_withADXLinearSystem_withInt_withInt_withADXChainHead_withBoolean_withBoolean_withBoolean_(ADXConstraintWidgetContainer *container, ADXLinearSystem *system, jint orientation, jint offset, ADXChainHead *chainHead, jboolean isChainSpread, jboolean isChainSpreadInside, jboolean isChainPacked) {
  ADXDirect_initialize();
  if (isChainPacked) {
    return false;
  }
  if (orientation == ADXConstraintWidget_HORIZONTAL) {
    if (![((ADXConstraintWidgetContainer *) nil_chk(container)) isResolvedHorizontally]) {
      return false;
    }
  }
  else {
    if (![((ADXConstraintWidgetContainer *) nil_chk(container)) isResolvedVertically]) {
      return false;
    }
  }
  jint level = 0;
  jboolean isRtl = [container isRtl];
  ADXConstraintWidget *first = JreRetainedLocalValue([((ADXChainHead *) nil_chk(chainHead)) getFirst]);
  ADXConstraintWidget *last = JreRetainedLocalValue([chainHead getLast]);
  ADXConstraintWidget *firstVisibleWidget = JreRetainedLocalValue([chainHead getFirstVisibleWidget]);
  ADXConstraintWidget *lastVisibleWidget = JreRetainedLocalValue([chainHead getLastVisibleWidget]);
  ADXConstraintWidget *head = JreRetainedLocalValue([chainHead getHead]);
  ADXConstraintWidget *widget = JreRetainedLocalValue(first);
  ADXConstraintWidget *next;
  jboolean done = false;
  ADXConstraintAnchor *begin = IOSObjectArray_Get(nil_chk(((ADXConstraintWidget *) nil_chk(first))->mListAnchors_), offset);
  ADXConstraintAnchor *end = IOSObjectArray_Get(((ADXConstraintWidget *) nil_chk(last))->mListAnchors_, offset + 1);
  if (((ADXConstraintAnchor *) nil_chk(begin))->mTarget_ == nil || ((ADXConstraintAnchor *) nil_chk(end))->mTarget_ == nil) {
    return false;
  }
  if (![begin->mTarget_ hasFinalValue] || ![((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(end))->mTarget_)) hasFinalValue]) {
    return false;
  }
  if (firstVisibleWidget == nil || lastVisibleWidget == nil) {
    return false;
  }
  jint startPoint = [((ADXConstraintAnchor *) nil_chk(begin->mTarget_)) getFinalValue] + [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(firstVisibleWidget->mListAnchors_), offset))) getMargin];
  jint endPoint = [((ADXConstraintAnchor *) nil_chk(((ADXConstraintAnchor *) nil_chk(end))->mTarget_)) getFinalValue] - [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(lastVisibleWidget->mListAnchors_), offset + 1))) getMargin];
  jint distance = endPoint - startPoint;
  if (distance <= 0) {
    return false;
  }
  jint totalSize = 0;
  ADXBasicMeasure_Measure *measure = create_ADXBasicMeasure_Measure_init();
  jint numWidgets = 0;
  jint numVisibleWidgets = 0;
  while (!done) {
    jboolean canMeasure = ADXDirect_canMeasureWithInt_withADXConstraintWidget_(level + 1, widget);
    if (!canMeasure) {
      return false;
    }
    if (IOSObjectArray_Get(nil_chk(((ADXConstraintWidget *) nil_chk(widget))->mListDimensionBehaviors_), orientation) == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT)) {
      return false;
    }
    if ([widget isMeasureRequested]) {
      ADXConstraintWidgetContainer_measureWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withADXBasicMeasure_Measure_withInt_(level + 1, widget, [container getMeasurer], measure, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
    }
    totalSize += [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset))) getMargin];
    if (orientation == ADXConstraintWidget_HORIZONTAL) {
      totalSize += +[widget getWidth];
    }
    else {
      totalSize += [widget getHeight];
    }
    totalSize += [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset + 1))) getMargin];
    numWidgets++;
    if ([widget getVisibility] != ADXConstraintWidget_GONE) {
      numVisibleWidgets++;
    }
    ADXConstraintAnchor *nextAnchor = JreRetainedLocalValue(((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset + 1)))->mTarget_);
    if (nextAnchor != nil) {
      next = nextAnchor->mOwner_;
      if (((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(((ADXConstraintWidget *) nil_chk(next))->mListAnchors_, offset)))->mTarget_ == nil || ((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(next->mListAnchors_, offset)))->mTarget_->mOwner_ != widget) {
        next = nil;
      }
    }
    else {
      next = nil;
    }
    if (next != nil) {
      widget = next;
    }
    else {
      done = true;
    }
  }
  if (numVisibleWidgets == 0) {
    return false;
  }
  if (numVisibleWidgets != numWidgets) {
    return false;
  }
  if (distance < totalSize) {
    return false;
  }
  jint gap = distance - totalSize;
  if (isChainSpread) {
    gap = JreIntDiv(gap, (numVisibleWidgets + 1));
  }
  else if (isChainSpreadInside) {
    if (numVisibleWidgets > 2) {
      gap = JreIntDiv(gap, numVisibleWidgets) - 1;
    }
  }
  if (numVisibleWidgets == 1) {
    jfloat bias;
    if (orientation == ADXConstraintWidget_HORIZONTAL) {
      bias = [((ADXConstraintWidget *) nil_chk(head)) getHorizontalBiasPercent];
    }
    else {
      bias = [((ADXConstraintWidget *) nil_chk(head)) getVerticalBiasPercent];
    }
    jint p1 = JreFpToInt((0.5f + startPoint + gap * bias));
    if (orientation == ADXConstraintWidget_HORIZONTAL) {
      [firstVisibleWidget setFinalHorizontalWithInt:p1 withInt:p1 + [firstVisibleWidget getWidth]];
    }
    else {
      [firstVisibleWidget setFinalVerticalWithInt:p1 withInt:p1 + [firstVisibleWidget getHeight]];
    }
    ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, firstVisibleWidget, [container getMeasurer], isRtl);
    return true;
  }
  if (isChainSpread) {
    done = false;
    jint current = startPoint + gap;
    widget = first;
    while (!done) {
      if ([widget getVisibility] == ADXConstraintWidget_GONE) {
        if (orientation == ADXConstraintWidget_HORIZONTAL) {
          [widget setFinalHorizontalWithInt:current withInt:current];
          ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, widget, [container getMeasurer], isRtl);
        }
        else {
          [widget setFinalVerticalWithInt:current withInt:current];
          ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, widget, [container getMeasurer]);
        }
      }
      else {
        current += [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset))) getMargin];
        if (orientation == ADXConstraintWidget_HORIZONTAL) {
          [widget setFinalHorizontalWithInt:current withInt:current + [widget getWidth]];
          ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, widget, [container getMeasurer], isRtl);
          current += [widget getWidth];
        }
        else {
          [widget setFinalVerticalWithInt:current withInt:current + [widget getHeight]];
          ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, widget, [container getMeasurer]);
          current += [widget getHeight];
        }
        current += [((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset + 1))) getMargin];
        current += gap;
      }
      [widget addToSolverWithADXLinearSystem:system withBoolean:false];
      ADXConstraintAnchor *nextAnchor = JreRetainedLocalValue(((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(nil_chk(widget->mListAnchors_), offset + 1)))->mTarget_);
      if (nextAnchor != nil) {
        next = nextAnchor->mOwner_;
        if (((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(((ADXConstraintWidget *) nil_chk(next))->mListAnchors_, offset)))->mTarget_ == nil || ((ADXConstraintAnchor *) nil_chk(IOSObjectArray_Get(next->mListAnchors_, offset)))->mTarget_->mOwner_ != widget) {
          next = nil;
        }
      }
      else {
        next = nil;
      }
      if (next != nil) {
        widget = next;
      }
      else {
        done = true;
      }
    }
  }
  else if (isChainSpreadInside) {
    if (numVisibleWidgets == 2) {
      if (orientation == ADXConstraintWidget_HORIZONTAL) {
        [firstVisibleWidget setFinalHorizontalWithInt:startPoint withInt:startPoint + [firstVisibleWidget getWidth]];
        [lastVisibleWidget setFinalHorizontalWithInt:endPoint - [lastVisibleWidget getWidth] withInt:endPoint];
        ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, firstVisibleWidget, [container getMeasurer], isRtl);
        ADXDirect_horizontalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_withBoolean_(level + 1, lastVisibleWidget, [container getMeasurer], isRtl);
      }
      else {
        [firstVisibleWidget setFinalVerticalWithInt:startPoint withInt:startPoint + [firstVisibleWidget getHeight]];
        [lastVisibleWidget setFinalVerticalWithInt:endPoint - [lastVisibleWidget getHeight] withInt:endPoint];
        ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, firstVisibleWidget, [container getMeasurer]);
        ADXDirect_verticalSolvingPassWithInt_withADXConstraintWidget_withADXBasicMeasure_Measurer_(level + 1, lastVisibleWidget, [container getMeasurer]);
      }
      return true;
    }
    return false;
  }
  return true;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXDirect)
