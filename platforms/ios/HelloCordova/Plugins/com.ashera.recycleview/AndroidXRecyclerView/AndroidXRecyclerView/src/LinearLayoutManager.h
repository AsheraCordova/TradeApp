//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXRecyclerView\src\main\java\androidx\recyclerview\widget\LinearLayoutManager.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_LinearLayoutManager")
#ifdef RESTRICT_LinearLayoutManager
#define INCLUDE_ALL_LinearLayoutManager 0
#else
#define INCLUDE_ALL_LinearLayoutManager 1
#endif
#undef RESTRICT_LinearLayoutManager

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ADXLinearLayoutManager_) && (INCLUDE_ALL_LinearLayoutManager || defined(INCLUDE_ADXLinearLayoutManager))
#define ADXLinearLayoutManager_

#define RESTRICT_RecyclerView 1
#define INCLUDE_ADXRecyclerView_LayoutManager 1
#include "RecyclerView.h"

@class ADContext;
@class ADView;
@class ADXLinearLayoutManager_AnchorInfo;
@class ADXLinearLayoutManager_LayoutChunkResult;
@class ADXLinearLayoutManager_LayoutState;
@class ADXLinearLayoutManager_SavedState;
@class ADXOrientationHelper;
@class ADXRecyclerView;
@class ADXRecyclerView_LayoutParams;
@class ADXRecyclerView_Recycler;
@class ADXRecyclerView_State;
@class IOSIntArray;
@protocol ADParcelable;
@protocol ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry;

/*!
 @brief A <code>RecyclerView.LayoutManager</code> implementation which provides
  similar functionality to <code>r.android.widget.ListView</code>.
 */
@interface ADXLinearLayoutManager : ADXRecyclerView_LayoutManager {
 @public
  /*!
   @brief Current orientation.Either <code>HORIZONTAL</code> or <code>VERTICAL</code>
   */
  jint mOrientation_;
  /*!
   @brief Many calculations are made depending on orientation.To keep it clean, this interface
  helps <code>LinearLayoutManager</code> make those decisions.
   */
  ADXOrientationHelper *mOrientationHelper_;
  /*!
   @brief This keeps the final value for how LayoutManager should start laying out views.
   It is calculated by checking <code>getReverseLayout()</code> and View's layout direction. 
 <code>onLayoutChildren(RecyclerView.Recycler, RecyclerView.State)</code> is run.
   */
  jboolean mShouldReverseLayout_;
  /*!
   @brief When LayoutManager needs to scroll to a position, it sets this variable and requests a
  layout which will check this variable and re-layout accordingly.
   */
  jint mPendingScrollPosition_;
  /*!
   @brief Used to keep the offset value when <code>scrollToPositionWithOffset(int, int)</code> is
  called.
   */
  jint mPendingScrollPositionOffset_;
  ADXLinearLayoutManager_SavedState *mPendingSavedState_;
  /*!
   @brief Re-used variable to keep anchor information on re-layout.
   Anchor position and coordinate defines the reference point for LLM while doing a layout.
   */
  ADXLinearLayoutManager_AnchorInfo *mAnchorInfo_;
}

#pragma mark Public

/*!
 @brief Creates a vertical LinearLayoutManager
 @param context Current context, will be used to access resources.
 */
- (instancetype)initWithADContext:(ADContext *)context;

/*!
 @param context Current context, will be used to access resources.
 @param orientation Layout orientation. Should be <code>HORIZONTAL</code>  or <code>VERTICAL</code>
  .
 @param reverseLayout When set to true, layouts from end to start.
 */
- (instancetype)initWithADContext:(ADContext *)context
                          withInt:(jint)orientation
                      withBoolean:(jboolean)reverseLayout;

- (void)assertNotInLayoutOrScrollWithNSString:(NSString *)message;

/*!
 @return true if <code>getOrientation()</code> is <code>HORIZONTAL</code>
 */
- (jboolean)canScrollHorizontally;

/*!
 @return true if <code>getOrientation()</code> is <code>VERTICAL</code>
 */
- (jboolean)canScrollVertically;

- (void)collectAdjacentPrefetchPositionsWithInt:(jint)dx
                                        withInt:(jint)dy
                      withADXRecyclerView_State:(ADXRecyclerView_State *)state
withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:(id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>)layoutPrefetchRegistry;

- (void)collectInitialPrefetchPositionsWithInt:(jint)adapterItemCount
withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:(id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>)layoutPrefetchRegistry;

- (jint)computeHorizontalScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeHorizontalScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeHorizontalScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeVerticalScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeVerticalScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeVerticalScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 @brief Returns the adapter position of the first fully visible view.This position does not include
  adapter changes that were dispatched after the last layout pass.
 <p>
  Note that bounds check is only performed in the current orientation. That means, if
  LayoutManager is horizontal, it will only check the view's left and right edges.
 @return The adapter position of the first fully visible item or 
 <code>RecyclerView.NO_POSITION</code> if there aren't any visible items.
 - seealso: #findFirstVisibleItemPosition()
 - seealso: #findLastCompletelyVisibleItemPosition()
 */
- (jint)findFirstCompletelyVisibleItemPosition;

/*!
 @brief Returns the adapter position of the first visible view.This position does not include
  adapter changes that were dispatched after the last layout pass.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  LayoutManager may pre-cache some views that are not necessarily visible. Those views
  are ignored in this method.
 @return The adapter position of the first visible item or <code>RecyclerView.NO_POSITION</code> if
  there aren't any visible items.
 - seealso: #findFirstCompletelyVisibleItemPosition()
 - seealso: #findLastVisibleItemPosition()
 */
- (jint)findFirstVisibleItemPosition;

/*!
 @brief Returns the adapter position of the last fully visible view.This position does not include
  adapter changes that were dispatched after the last layout pass.
 <p>
  Note that bounds check is only performed in the current orientation. That means, if
  LayoutManager is horizontal, it will only check the view's left and right edges.
 @return The adapter position of the last fully visible view or 
 <code>RecyclerView.NO_POSITION</code> if there aren't any visible items.
 - seealso: #findLastVisibleItemPosition()
 - seealso: #findFirstCompletelyVisibleItemPosition()
 */
- (jint)findLastCompletelyVisibleItemPosition;

/*!
 @brief Returns the adapter position of the last visible view.This position does not include
  adapter changes that were dispatched after the last layout pass.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  LayoutManager may pre-cache some views that are not necessarily visible. Those views
  are ignored in this method.
 @return The adapter position of the last visible view or <code>RecyclerView.NO_POSITION</code> if
  there aren't any visible items.
 - seealso: #findLastCompletelyVisibleItemPosition()
 - seealso: #findFirstVisibleItemPosition()
 */
- (jint)findLastVisibleItemPosition;

/*!
 */
- (ADView *)findViewByPositionWithInt:(jint)position;

/*!
 */
- (ADXRecyclerView_LayoutParams *)generateDefaultLayoutParams;

/*!
 @brief Gets the number of items to prefetch in 
 <code>collectInitialPrefetchPositions(int, LayoutPrefetchRegistry)</code>, which defines
  how many inner items should be prefetched when this LayoutManager's RecyclerView
  is nested inside another RecyclerView.
 @return number of items to prefetch.
 - seealso: #isItemPrefetchEnabled()
 - seealso: #setInitialPrefetchItemCount(int)
 - seealso: #collectInitialPrefetchPositions(int, LayoutPrefetchRegistry)
 */
- (jint)getInitialPrefetchItemCount;

/*!
 @brief Returns the current orientation of the layout.
 @return Current orientation,  either <code>HORIZONTAL</code> or <code>VERTICAL</code>
 - seealso: #setOrientation(int)
 */
- (jint)getOrientation;

/*!
 @brief Returns whether LayoutManager will recycle its children when it is detached from
  RecyclerView.
 @return true if LayoutManager will recycle its children when it is detached from
  RecyclerView.
 */
- (jboolean)getRecycleChildrenOnDetach;

/*!
 @brief Returns if views are laid out from the opposite direction of the layout.
 @return If layout is reversed or not.
 - seealso: #setReverseLayout(boolean)
 */
- (jboolean)getReverseLayout;

- (jboolean)getStackFromEnd;

/*!
 */
- (jboolean)isAutoMeasureEnabled;

/*!
 @brief Returns the current state of the smooth scrollbar feature.It is enabled by default.
 @return True if smooth scrollbar is enabled, false otherwise.
 - seealso: #setSmoothScrollbarEnabled(boolean)
 */
- (jboolean)isSmoothScrollbarEnabled;

- (void)onDetachedFromWindowWithADXRecyclerView:(ADXRecyclerView *)view
                   withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler;

- (ADView *)onFocusSearchFailedWithADView:(ADView *)focused
                                  withInt:(jint)direction
             withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                withADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 */
- (void)onLayoutChildrenWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                           withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)onLayoutCompletedWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)onRestoreInstanceStateWithADParcelable:(id<ADParcelable>)state;

- (id<ADParcelable>)onSaveInstanceState;

/*!
 */
- (void)prepareForDropWithADView:(ADView *)view
                      withADView:(ADView *)target
                         withInt:(jint)x
                         withInt:(jint)y;

/*!
 */
- (jint)scrollHorizontallyByWithInt:(jint)dx
       withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
          withADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 @brief <p>Scroll the RecyclerView to make the position visible.
 </p>
  
 <p>RecyclerView will scroll the minimum amount that is necessary to make the
  target position visible. If you are looking for a similar behavior to 
 <code>r.android.widget.ListView.setSelection(int)</code> or 
 <code>r.android.widget.ListView.setSelectionFromTop(int, int)</code>, use 
 <code>scrollToPositionWithOffset(int, int)</code>.</p>
  
 <p>Note that scroll position change will not be reflected until the next layout call.</p>
 @param position Scroll to this adapter position
 - seealso: #scrollToPositionWithOffset(int, int)
 */
- (void)scrollToPositionWithInt:(jint)position;

/*!
 @brief Scroll to the specified adapter position with the given offset from resolved layout
  start.Resolved layout start depends on <code>getReverseLayout()</code>,
  <code>ViewCompat.getLayoutDirection(r.android.view.View)</code> and <code>getStackFromEnd()</code>.
 <p>
  For example, if layout is <code>VERTICAL</code> and <code>getStackFromEnd()</code> is true, calling 
 <code>scrollToPositionWithOffset(10, 20)</code> will layout such that 
 <code>item[10]</code>'s bottom is 20 pixels above the RecyclerView's bottom. 
 <p>
  Note that scroll position change will not be reflected until the next layout call. 
 <p>
  If you are just trying to make a position visible, use <code>scrollToPosition(int)</code>.
 @param position Index (starting at 0) of the reference item.
 @param offset The distance (in pixels) between the start edge of the item view and                  start edge of the RecyclerView.
 - seealso: #setReverseLayout(boolean)
 - seealso: #scrollToPosition(int)
 */
- (void)scrollToPositionWithOffsetWithInt:(jint)position
                                  withInt:(jint)offset;

/*!
 */
- (jint)scrollVerticallyByWithInt:(jint)dy
     withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
        withADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 @brief Sets the number of items to prefetch in 
 <code>collectInitialPrefetchPositions(int, LayoutPrefetchRegistry)</code>, which defines
  how many inner items should be prefetched when this LayoutManager's RecyclerView
  is nested inside another RecyclerView.
 <p>Set this value to the number of items this inner LayoutManager will display when it is
  first scrolled into the viewport. RecyclerView will attempt to prefetch that number of items
  so they are ready, avoiding jank as the inner RecyclerView is scrolled into the viewport.</p>
  
 <p>For example, take a vertically scrolling RecyclerView with horizontally scrolling inner
  RecyclerViews. The rows always have 4 items visible in them (or 5 if not aligned). Passing 
 <code>4</code> to this method for each inner RecyclerView's LinearLayoutManager will enable
  RecyclerView's prefetching feature to do create/bind work for 4 views within a row early,
  before it is scrolled on screen, instead of just the default 2.</p>
  
 <p>Calling this method does nothing unless the LayoutManager is in a RecyclerView
  nested in another RecyclerView.</p>
  
 <p class="note"><strong>Note:</strong> Setting this value to be larger than the number of
  views that will be visible in this view can incur unnecessary bind work, and an increase to
  the number of Views created and in active use.</p>
 @param itemCount Number of items to prefetch
 - seealso: #isItemPrefetchEnabled()
 - seealso: #getInitialPrefetchItemCount()
 - seealso: #collectInitialPrefetchPositions(int, LayoutPrefetchRegistry)
 */
- (void)setInitialPrefetchItemCountWithInt:(jint)itemCount;

/*!
 @brief Sets the orientation of the layout.
 <code>LinearLayoutManager</code>
  will do its best to keep scroll position.
 @param orientation<code>HORIZONTAL</code>  or <code>VERTICAL</code>
 */
- (void)setOrientationWithInt:(jint)orientation;

/*!
 @brief Set whether LayoutManager will recycle its children when it is detached from
  RecyclerView.
 <p>
  If you are using a <code>RecyclerView.RecycledViewPool</code>, it might be a good idea to set
  this flag to <code>true</code> so that views will be available to other RecyclerViews
  immediately. 
 <p>
  Note that, setting this flag will result in a performance drop if RecyclerView
  is restored.
 @param recycleChildrenOnDetach Whether children should be recycled in detach or not.
 */
- (void)setRecycleChildrenOnDetachWithBoolean:(jboolean)recycleChildrenOnDetach;

/*!
 @brief Used to reverse item traversal and layout order.
 This behaves similar to the layout change for RTL views. When set to true, first item is
  laid out at the end of the UI, second item is laid out before it etc.
  For horizontal layouts, it depends on the layout direction.
  When set to true, If <code>RecyclerView</code> is LTR, than it will
  layout from RTL, if <code>RecyclerView</code>} is RTL, it will layout
  from LTR.
  If you are looking for the exact same behavior of 
 <code>r.android.widget.AbsListView.setStackFromBottom(boolean)</code>, use 
 <code>setStackFromEnd(boolean)</code>
 */
- (void)setReverseLayoutWithBoolean:(jboolean)reverseLayout;

/*!
 @brief When smooth scrollbar is enabled, the position and size of the scrollbar thumb is computed
  based on the number of visible pixels in the visible items.This however assumes that all
  list items have similar or equal widths or heights (depending on list orientation).
 If you use a list in which items have different dimensions, the scrollbar will change
  appearance as the user scrolls through the list. To avoid this issue,  you need to disable
  this property.
  When smooth scrollbar is disabled, the position and size of the scrollbar thumb is based
  solely on the number of items in the adapter and the position of the visible items inside
  the adapter. This provides a stable scrollbar as the user navigates through a list of items
  with varying widths / heights.
 @param enabled Whether or not to enable smooth scrollbar.
 - seealso: #setSmoothScrollbarEnabled(boolean)
 */
- (void)setSmoothScrollbarEnabledWithBoolean:(jboolean)enabled;

/*!
 @brief Compatibility support for <code>r.android.widget.AbsListView.setStackFromBottom(boolean)</code>
 */
- (void)setStackFromEndWithBoolean:(jboolean)stackFromEnd;

- (jboolean)supportsPredictiveItemAnimations;

#pragma mark Protected

/*!
 @brief <p>Calculates the amount of extra space (in pixels) that should be laid out by <code>LinearLayoutManager</code>
  and stores the result in <code>extraLayoutSpace</code>.
 <code>extraLayoutSpace[0]</code>
  should be used for the extra space at the top/left, and <code>extraLayoutSpace[1]</code>
  should be used for the extra space at the bottom/right (depending on the
  orientation). Thus, the side where it is applied is unaffected by <code>getLayoutDirection()</code>
  (LTR vs RTL), <code>getStackFromEnd()</code> and <code>getReverseLayout()</code>
 . Negative values are ignored.</p>
  
 <p>By default, <code>LinearLayoutManager</code> lays out 1 extra page of items while smooth
  scrolling, in the direction of the scroll, and no extra space is laid out in all other
  situations. You can override this method to implement your own custom pre-cache logic. Use 
 <code>RecyclerView.State.hasTargetScrollPosition()</code> to find out if a smooth scroll to a
  position is in progress, and <code>RecyclerView.State.getTargetScrollPosition()</code> to find out
  which item it is scrolling to.</p>
  
 <p><strong>Note:</strong>Laying out extra items generally comes with significant performance
  cost. It's typically only desirable in places like smooth scrolling to an unknown location,
  where 1) the extra content helps LinearLayoutManager know in advance when its target is
  approaching, so it can decelerate early and smoothly and 2) while motion is continuous.</p>
  
 <p>Extending the extra layout space is especially expensive if done while the user may change
  scrolling direction. In the default implementation, changing direction will cause the extra
  layout space to swap to the opposite side of the viewport, incurring many rebinds/recycles,
  unless the cache is large enough to handle it.</p>
 */
- (void)calculateExtraLayoutSpaceWithADXRecyclerView_State:(ADXRecyclerView_State *)state
                                              withIntArray:(IOSIntArray *)extraLayoutSpace;

/*!
 @brief <p>Returns the amount of extra space that should be laid out by LayoutManager.
 </p>
  
 <p>By default, <code>LinearLayoutManager</code> lays out 1 extra page
  of items while smooth scrolling and 0 otherwise. You can override this method to implement
  your custom layout pre-cache logic.</p>
  
 <p><strong>Note:</strong>Laying out invisible elements generally comes with significant
  performance cost. It's typically only desirable in places like smooth scrolling to an unknown
  location, where 1) the extra content helps LinearLayoutManager know in advance when its
  target is approaching, so it can decelerate early and smoothly and 2) while motion is
  continuous.</p>
  
 <p>Extending the extra layout space is especially expensive if done while the user may change
  scrolling direction. Changing direction will cause the extra layout space to swap to the
  opposite side of the viewport, incurring many rebinds/recycles, unless the cache is large
  enough to handle it.</p>
 @return The extra space that should be laid out (in pixels).
 */
- (jint)getExtraLayoutSpaceWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jboolean)isLayoutRTL;

#pragma mark Package-Private

- (void)collectPrefetchPositionsForLayoutStateWithADXRecyclerView_State:(ADXRecyclerView_State *)state
                                 withADXLinearLayoutManager_LayoutState:(ADXLinearLayoutManager_LayoutState *)layoutState
               withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:(id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>)layoutPrefetchRegistry;

/*!
 @brief Converts a focusDirection to orientation.
 @param focusDirection One of <code>View.FOCUS_UP</code> , <code>View.FOCUS_DOWN</code> ,
                         <code>View.FOCUS_LEFT</code> , <code>View.FOCUS_RIGHT</code> ,                        
 <code>View.FOCUS_BACKWARD</code> , <code>View.FOCUS_FORWARD</code>                        or 0 for not applicable
 @return <code>LayoutState.LAYOUT_START</code> or <code>LayoutState.LAYOUT_END</code> if focus direction
  is applicable to current state, <code>LayoutState.INVALID_LAYOUT</code> otherwise.
 */
- (jint)convertFocusDirectionToLayoutDirectionWithInt:(jint)focusDirection;

/*!
 @brief Test overrides this to plug some tracking and verification.
 @return A new LayoutState
 */
- (ADXLinearLayoutManager_LayoutState *)createLayoutState;

- (void)ensureLayoutState;

/*!
 @brief The magic functions :).Fills the given layout, defined by the layoutState.
 This is fairly
  independent from the rest of the <code>LinearLayoutManager</code>
  and with little change, can be made publicly available as a helper class.
 @param recycler Current recycler that is attached to RecyclerView
 @param layoutState Configuration on how we should fill out the available space.
 @param state Context passed by the RecyclerView to control scroll steps.
 @param stopOnFocusable If true, filling stops in the first focusable new child
 @return Number of pixels that it added. Useful for scroll functions.
 */
- (jint)fillWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
  withADXLinearLayoutManager_LayoutState:(ADXLinearLayoutManager_LayoutState *)layoutState
               withADXRecyclerView_State:(ADXRecyclerView_State *)state
                             withBoolean:(jboolean)stopOnFocusable;

/*!
 @brief Convenience method to find the visible child closes to end.Caller should check if it has
  enough children.
 @param completelyVisible Whether child should be completely visible or not
 @return The first visible child closest to end of the layout from user's perspective.
 */
- (ADView *)findFirstVisibleChildClosestToEndWithBoolean:(jboolean)completelyVisible
                                             withBoolean:(jboolean)acceptPartiallyVisible;

/*!
 @brief Convenience method to find the visible child closes to start.Caller should check if it has
  enough children.
 @param completelyVisible Whether child should be completely visible or not
 @return The first visible child closest to start of the layout from user's perspective.
 */
- (ADView *)findFirstVisibleChildClosestToStartWithBoolean:(jboolean)completelyVisible
                                               withBoolean:(jboolean)acceptPartiallyVisible;

- (ADView *)findOnePartiallyOrCompletelyInvisibleChildWithInt:(jint)fromIndex
                                                      withInt:(jint)toIndex;

- (ADView *)findOneVisibleChildWithInt:(jint)fromIndex
                               withInt:(jint)toIndex
                           withBoolean:(jboolean)completelyVisible
                           withBoolean:(jboolean)acceptPartiallyVisible;

/*!
 @brief Finds a suitable anchor child.
 <p>
  Due to ambiguous adapter updates or children being removed, some children's positions may be
  invalid. This method is a best effort to find a position within adapter bounds if possible. 
 <p>
  It also prioritizes children from best to worst in this order: 
 <ol>
    <li> An in bounds child.
    <li> An out of bounds child.
    <li> An invalid child. 
 </ol>
 @param layoutFromEnd True if the RV scrolls in the reverse direction, which is the same as                       (reverseLayout ^ stackFromEnd).
 @param traverseChildrenInReverseOrder True if the children should be traversed in reverse                                        order (stackFromEnd).
 @return A View that can be used an an anchor View.
 */
- (ADView *)findReferenceChildWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                 withADXRecyclerView_State:(ADXRecyclerView_State *)state
                                               withBoolean:(jboolean)layoutFromEnd
                                               withBoolean:(jboolean)traverseChildrenInReverseOrder;

- (void)layoutChunkWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                      withADXRecyclerView_State:(ADXRecyclerView_State *)state
         withADXLinearLayoutManager_LayoutState:(ADXLinearLayoutManager_LayoutState *)layoutState
   withADXLinearLayoutManager_LayoutChunkResult:(ADXLinearLayoutManager_LayoutChunkResult *)result;

/*!
 @brief Method called when Anchor position is decided.Extending class can setup accordingly or
  even update anchor info if necessary.
 @param recycler The recycler for the layout
 @param state The layout state
 @param anchorInfo The mutable POJO that keeps the position and offset.
 @param firstLayoutItemDirection The direction of the first layout filling in terms of adapter                                  indices.
 */
- (void)onAnchorReadyWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                        withADXRecyclerView_State:(ADXRecyclerView_State *)state
            withADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo
                                          withInt:(jint)firstLayoutItemDirection;

- (jboolean)resolveIsInfinite;

- (jint)scrollByWithInt:(jint)delta
withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jboolean)shouldMeasureTwice;

/*!
 @brief Used for debugging.
 Validates that child views are laid out in correct order. This is important because rest of
  the algorithm relies on this constraint.
  In default layout, child 0 should be closest to screen position 0 and last child should be
  closest to position WIDTH or HEIGHT.
  In reverse layout, last child should be closes to screen position 0 and first child should
  be closest to position WIDTH  or HEIGHT
 */
- (void)validateChildOrder;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXLinearLayoutManager)

J2OBJC_FIELD_SETTER(ADXLinearLayoutManager, mOrientationHelper_, ADXOrientationHelper *)
J2OBJC_FIELD_SETTER(ADXLinearLayoutManager, mPendingSavedState_, ADXLinearLayoutManager_SavedState *)
J2OBJC_FIELD_SETTER(ADXLinearLayoutManager, mAnchorInfo_, ADXLinearLayoutManager_AnchorInfo *)

inline jboolean ADXLinearLayoutManager_get_DEBUG(void);
#define ADXLinearLayoutManager_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager, DEBUG, jboolean)

inline jint ADXLinearLayoutManager_get_HORIZONTAL(void);
#define ADXLinearLayoutManager_HORIZONTAL 0
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager, HORIZONTAL, jint)

inline jint ADXLinearLayoutManager_get_VERTICAL(void);
#define ADXLinearLayoutManager_VERTICAL 1
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager, VERTICAL, jint)

inline jint ADXLinearLayoutManager_get_INVALID_OFFSET(void);
#define ADXLinearLayoutManager_INVALID_OFFSET ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager, INVALID_OFFSET, jint)

FOUNDATION_EXPORT void ADXLinearLayoutManager_initWithADContext_(ADXLinearLayoutManager *self, ADContext *context);

FOUNDATION_EXPORT ADXLinearLayoutManager *new_ADXLinearLayoutManager_initWithADContext_(ADContext *context) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXLinearLayoutManager *create_ADXLinearLayoutManager_initWithADContext_(ADContext *context);

FOUNDATION_EXPORT void ADXLinearLayoutManager_initWithADContext_withInt_withBoolean_(ADXLinearLayoutManager *self, ADContext *context, jint orientation, jboolean reverseLayout);

FOUNDATION_EXPORT ADXLinearLayoutManager *new_ADXLinearLayoutManager_initWithADContext_withInt_withBoolean_(ADContext *context, jint orientation, jboolean reverseLayout) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXLinearLayoutManager *create_ADXLinearLayoutManager_initWithADContext_withInt_withBoolean_(ADContext *context, jint orientation, jboolean reverseLayout);

J2OBJC_TYPE_LITERAL_HEADER(ADXLinearLayoutManager)

@compatibility_alias AndroidxRecyclerviewWidgetLinearLayoutManager ADXLinearLayoutManager;

#endif

#if !defined (ADXLinearLayoutManager_LayoutState_) && (INCLUDE_ALL_LinearLayoutManager || defined(INCLUDE_ADXLinearLayoutManager_LayoutState))
#define ADXLinearLayoutManager_LayoutState_

@class ADView;
@class ADXRecyclerView_Recycler;
@class ADXRecyclerView_State;
@protocol JavaUtilList;

/*!
 @brief Helper class that keeps temporary state while {LayoutManager} is filling out the empty
  space.
 */
@interface ADXLinearLayoutManager_LayoutState : NSObject {
 @public
  /*!
   @brief We may not want to recycle children in some cases (e.g.layout)
   */
  jboolean mRecycle_;
  /*!
   @brief Pixel offset where layout should start
   */
  jint mOffset_;
  /*!
   @brief Number of pixels that we should fill, in the layout direction.
   */
  jint mAvailable_;
  /*!
   @brief Current position on the adapter to get the next item.
   */
  jint mCurrentPosition_;
  /*!
   @brief Defines the direction in which the data adapter is traversed.
   Should be <code>ITEM_DIRECTION_HEAD</code> or <code>ITEM_DIRECTION_TAIL</code>
   */
  jint mItemDirection_;
  /*!
   @brief Defines the direction in which the layout is filled.
   Should be <code>LAYOUT_START</code> or <code>LAYOUT_END</code>
   */
  jint mLayoutDirection_;
  /*!
   @brief Used when LayoutState is constructed in a scrolling state.
   It should be set the amount of scrolling we can make without creating a new view.
  Settings this is required for efficient view recycling.
   */
  jint mScrollingOffset_;
  /*!
   @brief Used if you want to pre-layout items that are not yet visible.
   The difference with <code>mAvailable</code> is that, when recycling, distance laid out for 
 <code>mExtraFillSpace</code> is not considered to avoid recycling visible children.
   */
  jint mExtraFillSpace_;
  /*!
   @brief Contains the <code>calculateExtraLayoutSpace(RecyclerView.State, int[])</code>  extra layout
  space} that should be excluded for recycling when cleaning up the tail of the list during
  a smooth scroll.
   */
  jint mNoRecycleSpace_;
  /*!
   @brief Equal to <code>RecyclerView.State.isPreLayout()</code>.When consuming scrap, if this value
  is set to true, we skip removed views since they should not be laid out in post layout
  step.
   */
  jboolean mIsPreLayout_;
  /*!
   @brief The most recent <code>scrollBy(int, RecyclerView.Recycler, RecyclerView.State)</code>
  amount.
   */
  jint mLastScrollDelta_;
  /*!
   @brief When LLM needs to layout particular views, it sets this list in which case, LayoutState
  will only return views from this list and return null if it cannot find an item.
   */
  id<JavaUtilList> mScrapList_;
  /*!
   @brief Used when there is no limit in how many views can be laid out.
   */
  jboolean mInfinite_;
}

#pragma mark Public

- (void)assignPositionFromScrapList;

- (void)assignPositionFromScrapListWithADView:(ADView *)ignore;

- (ADView *)nextViewInLimitedListWithADView:(ADView *)ignore;

#pragma mark Package-Private

- (instancetype)init;

/*!
 @return true if there are more items in the data adapter
 */
- (jboolean)hasMoreWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)log;

/*!
 @brief Gets the view for the next element that we should layout.
 Also updates current item index to the next item, based on <code>mItemDirection</code>
 @return The next element that we should layout.
 */
- (ADView *)nextWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXLinearLayoutManager_LayoutState)

J2OBJC_FIELD_SETTER(ADXLinearLayoutManager_LayoutState, mScrapList_, id<JavaUtilList>)

inline NSString *ADXLinearLayoutManager_LayoutState_get_TAG(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ADXLinearLayoutManager_LayoutState_TAG;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADXLinearLayoutManager_LayoutState, TAG, NSString *)

inline jint ADXLinearLayoutManager_LayoutState_get_LAYOUT_START(void);
#define ADXLinearLayoutManager_LayoutState_LAYOUT_START -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager_LayoutState, LAYOUT_START, jint)

inline jint ADXLinearLayoutManager_LayoutState_get_LAYOUT_END(void);
#define ADXLinearLayoutManager_LayoutState_LAYOUT_END 1
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager_LayoutState, LAYOUT_END, jint)

inline jint ADXLinearLayoutManager_LayoutState_get_INVALID_LAYOUT(void);
#define ADXLinearLayoutManager_LayoutState_INVALID_LAYOUT ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager_LayoutState, INVALID_LAYOUT, jint)

inline jint ADXLinearLayoutManager_LayoutState_get_ITEM_DIRECTION_HEAD(void);
#define ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager_LayoutState, ITEM_DIRECTION_HEAD, jint)

inline jint ADXLinearLayoutManager_LayoutState_get_ITEM_DIRECTION_TAIL(void);
#define ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL 1
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager_LayoutState, ITEM_DIRECTION_TAIL, jint)

inline jint ADXLinearLayoutManager_LayoutState_get_SCROLLING_OFFSET_NaN(void);
#define ADXLinearLayoutManager_LayoutState_SCROLLING_OFFSET_NaN ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager_LayoutState, SCROLLING_OFFSET_NaN, jint)

FOUNDATION_EXPORT void ADXLinearLayoutManager_LayoutState_init(ADXLinearLayoutManager_LayoutState *self);

FOUNDATION_EXPORT ADXLinearLayoutManager_LayoutState *new_ADXLinearLayoutManager_LayoutState_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXLinearLayoutManager_LayoutState *create_ADXLinearLayoutManager_LayoutState_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXLinearLayoutManager_LayoutState)

#endif

#if !defined (ADXLinearLayoutManager_SavedState_) && (INCLUDE_ALL_LinearLayoutManager || defined(INCLUDE_ADXLinearLayoutManager_SavedState))
#define ADXLinearLayoutManager_SavedState_

#define RESTRICT_Parcelable 1
#define INCLUDE_ADParcelable 1
#include "Parcelable.h"

@protocol ADParcel;

/*!
 */
@interface ADXLinearLayoutManager_SavedState : NSObject < ADParcelable > {
 @public
  jint mAnchorPosition_;
  jint mAnchorOffset_;
  jboolean mAnchorLayoutFromEnd_;
}

#pragma mark Public

- (instancetype)init;

- (instancetype)initWithADXLinearLayoutManager_SavedState:(ADXLinearLayoutManager_SavedState *)other;

- (jint)describeContents;

- (void)writeToParcelWithADParcel:(id<ADParcel>)dest
                          withInt:(jint)flags;

#pragma mark Package-Private

- (instancetype)initWithADParcel:(id<ADParcel>)inArg;

- (jboolean)hasValidAnchor;

- (void)invalidateAnchor;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXLinearLayoutManager_SavedState)

FOUNDATION_EXPORT void ADXLinearLayoutManager_SavedState_init(ADXLinearLayoutManager_SavedState *self);

FOUNDATION_EXPORT ADXLinearLayoutManager_SavedState *new_ADXLinearLayoutManager_SavedState_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXLinearLayoutManager_SavedState *create_ADXLinearLayoutManager_SavedState_init(void);

FOUNDATION_EXPORT void ADXLinearLayoutManager_SavedState_initWithADParcel_(ADXLinearLayoutManager_SavedState *self, id<ADParcel> inArg);

FOUNDATION_EXPORT ADXLinearLayoutManager_SavedState *new_ADXLinearLayoutManager_SavedState_initWithADParcel_(id<ADParcel> inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXLinearLayoutManager_SavedState *create_ADXLinearLayoutManager_SavedState_initWithADParcel_(id<ADParcel> inArg);

FOUNDATION_EXPORT void ADXLinearLayoutManager_SavedState_initWithADXLinearLayoutManager_SavedState_(ADXLinearLayoutManager_SavedState *self, ADXLinearLayoutManager_SavedState *other);

FOUNDATION_EXPORT ADXLinearLayoutManager_SavedState *new_ADXLinearLayoutManager_SavedState_initWithADXLinearLayoutManager_SavedState_(ADXLinearLayoutManager_SavedState *other) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXLinearLayoutManager_SavedState *create_ADXLinearLayoutManager_SavedState_initWithADXLinearLayoutManager_SavedState_(ADXLinearLayoutManager_SavedState *other);

J2OBJC_TYPE_LITERAL_HEADER(ADXLinearLayoutManager_SavedState)

#endif

#if !defined (ADXLinearLayoutManager_AnchorInfo_) && (INCLUDE_ALL_LinearLayoutManager || defined(INCLUDE_ADXLinearLayoutManager_AnchorInfo))
#define ADXLinearLayoutManager_AnchorInfo_

@class ADView;
@class ADXOrientationHelper;
@class ADXRecyclerView_State;

/*!
 @brief Simple data class to keep Anchor information
 */
@interface ADXLinearLayoutManager_AnchorInfo : NSObject {
 @public
  ADXOrientationHelper *mOrientationHelper_;
  jint mPosition_;
  jint mCoordinate_;
  jboolean mLayoutFromEnd_;
  jboolean mValid_;
}

#pragma mark Public

- (void)assignFromViewWithADView:(ADView *)child
                         withInt:(jint)position;

- (void)assignFromViewAndKeepVisibleRectWithADView:(ADView *)child
                                           withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype)init;

/*!
 @brief assigns anchor coordinate from the RecyclerView's padding depending on current
  layoutFromEnd value
 */
- (void)assignCoordinateFromPadding;

- (jboolean)isViewValidAsAnchorWithADView:(ADView *)child
                withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)reset;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXLinearLayoutManager_AnchorInfo)

J2OBJC_FIELD_SETTER(ADXLinearLayoutManager_AnchorInfo, mOrientationHelper_, ADXOrientationHelper *)

FOUNDATION_EXPORT void ADXLinearLayoutManager_AnchorInfo_init(ADXLinearLayoutManager_AnchorInfo *self);

FOUNDATION_EXPORT ADXLinearLayoutManager_AnchorInfo *new_ADXLinearLayoutManager_AnchorInfo_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXLinearLayoutManager_AnchorInfo *create_ADXLinearLayoutManager_AnchorInfo_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXLinearLayoutManager_AnchorInfo)

#endif

#if !defined (ADXLinearLayoutManager_LayoutChunkResult_) && (INCLUDE_ALL_LinearLayoutManager || defined(INCLUDE_ADXLinearLayoutManager_LayoutChunkResult))
#define ADXLinearLayoutManager_LayoutChunkResult_

@interface ADXLinearLayoutManager_LayoutChunkResult : NSObject {
 @public
  jint mConsumed_;
  jboolean mFinished_;
  jboolean mIgnoreConsumed_;
  jboolean mFocusable_;
}

#pragma mark Protected

- (instancetype)init;

#pragma mark Package-Private

- (void)resetInternal;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXLinearLayoutManager_LayoutChunkResult)

FOUNDATION_EXPORT void ADXLinearLayoutManager_LayoutChunkResult_init(ADXLinearLayoutManager_LayoutChunkResult *self);

FOUNDATION_EXPORT ADXLinearLayoutManager_LayoutChunkResult *new_ADXLinearLayoutManager_LayoutChunkResult_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXLinearLayoutManager_LayoutChunkResult *create_ADXLinearLayoutManager_LayoutChunkResult_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXLinearLayoutManager_LayoutChunkResult)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_LinearLayoutManager")
