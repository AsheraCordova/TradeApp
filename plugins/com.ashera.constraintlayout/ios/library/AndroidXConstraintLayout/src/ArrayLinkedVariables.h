//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\ArrayLinkedVariables.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ArrayLinkedVariables")
#ifdef RESTRICT_ArrayLinkedVariables
#define INCLUDE_ALL_ArrayLinkedVariables 0
#else
#define INCLUDE_ALL_ArrayLinkedVariables 1
#endif
#undef RESTRICT_ArrayLinkedVariables

#if !defined (ADXArrayLinkedVariables_) && (INCLUDE_ALL_ArrayLinkedVariables || defined(INCLUDE_ADXArrayLinkedVariables))
#define ADXArrayLinkedVariables_

#define RESTRICT_ArrayRow 1
#define INCLUDE_ADXArrayRow_ArrayRowVariables 1
#include "ArrayRow.h"

@class ADXArrayRow;
@class ADXCache;
@class ADXSolverVariable;

/*!
 @brief Store a set of variables and their values in an array-based linked list.
 The general idea is that we want to store a list of variables that need to be ordered,
  space efficient, and relatively fast to maintain (add/remove).
  ArrayBackedVariables implements a sparse array, so is rather space efficient, but maintaining
  the array sorted is costly, as we spend quite a bit of time recopying parts of the array on element deletion.
  LinkedVariables implements a standard linked list structure, and is able to be faster than ArrayBackedVariables
  even though it's more costly to set up (pool of objects...), as the elements removal and maintenance of the
  structure is a lot more efficient.
  This ArrayLinkedVariables class takes inspiration from both of the above, and implement a linked list
  stored in several arrays. This allows us to be a lot more efficient in terms of setup (no need to deal with pool
  of objects...), resetting the structure, and insertion/deletion of elements.
 */
@interface ADXArrayLinkedVariables : NSObject < ADXArrayRow_ArrayRowVariables > {
 @public
  jint currentSize_;
  __unsafe_unretained ADXCache *mCache_;
}

#pragma mark Public

/*!
 @brief Add value to an existing variable
  The code is broadly identical to the put() method, only differing
  in in-line deletion, and of course doing an add rather than a put
 @param variable the variable we want to add
 @param value its value
 @param removeFromDefinition
 */
- (void)addWithADXSolverVariable:(ADXSolverVariable *)variable
                       withFloat:(jfloat)value
                     withBoolean:(jboolean)removeFromDefinition;

/*!
 @brief Clear the list of variables
 */
- (void)clear;

/*!
 @brief Returns true if the variable is contained in the list
 @param variable the variable we are looking for
 @return return true if we found the variable
 */
- (jboolean)containsWithADXSolverVariable:(ADXSolverVariable *)variable;

- (void)display;

/*!
 @brief Divide the values of all the variables in the list
  by the given amount
 @param amount amount to divide by
 */
- (void)divideByAmountWithFloat:(jfloat)amount;

/*!
 @brief Return the value of a variable, 0 if not found
 @param v the variable we are looking up
 @return the value of the found variable, or 0 if not found
 */
- (jfloat)getWithADXSolverVariable:(ADXSolverVariable *)v;

- (jint)getCurrentSize;

- (jint)getHead;

- (jint)getIdWithInt:(jint)index;

- (jint)getNextIndiceWithInt:(jint)index;

- (jfloat)getValueWithInt:(jint)index;

/*!
 @brief Return a variable from its position in the linked list
 @param index the index of the variable we want to return
 @return the variable found, or null
 */
- (ADXSolverVariable *)getVariableWithInt:(jint)index;

/*!
 @brief Return the value of a variable from its position in the linked list
 @param index the index of the variable we want to look up
 @return the value of the found variable, or 0 if not found
 */
- (jfloat)getVariableValueWithInt:(jint)index;

- (jint)indexOfWithADXSolverVariable:(ADXSolverVariable *)variable;

/*!
 @brief Invert the values of all the variables in the list
 */
- (void)invert;

/*!
 @brief Insert a variable with a given value in the linked list
 @param variable the variable to add in the list
 @param value the value of the variable
 */
- (void)putWithADXSolverVariable:(ADXSolverVariable *)variable
                       withFloat:(jfloat)value;

/*!
 @brief Remove a variable from the list
 @param variable the variable we want to remove
 @param removeFromDefinition
 @return the value of the removed variable
 */
- (jfloat)removeWithADXSolverVariable:(ADXSolverVariable *)variable
                          withBoolean:(jboolean)removeFromDefinition;

- (jint)sizeInBytes;

/*!
 @brief Returns a string representation of the list
 @return a string containing a representation of the list
 */
- (NSString *)description;

/*!
 @brief Update the current list with a new definition
 @param definition the row containing the definition
 @param removeFromDefinition
 */
- (jfloat)useWithADXArrayRow:(ADXArrayRow *)definition
                 withBoolean:(jboolean)removeFromDefinition;

#pragma mark Package-Private

/*!
 @brief Constructor
 @param arrayRow the row owning us
 @param cache instances cache
 */
- (instancetype)initWithADXArrayRow:(ADXArrayRow *)arrayRow
                       withADXCache:(ADXCache *)cache;

/*!
 @brief TODO: check if still needed
  Return a pivot candidate
 @return return a variable we can pivot on
 */
- (ADXSolverVariable *)getPivotCandidate;

/*!
 @brief Returns true if at least one of the variable is positive
 @return true if at least one of the variable is positive
 */
- (jboolean)hasAtLeastOnePositiveVariable;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXArrayLinkedVariables)

inline jint ADXArrayLinkedVariables_get_NONE(void);
#define ADXArrayLinkedVariables_NONE -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXArrayLinkedVariables, NONE, jint)

FOUNDATION_EXPORT void ADXArrayLinkedVariables_initWithADXArrayRow_withADXCache_(ADXArrayLinkedVariables *self, ADXArrayRow *arrayRow, ADXCache *cache);

FOUNDATION_EXPORT ADXArrayLinkedVariables *new_ADXArrayLinkedVariables_initWithADXArrayRow_withADXCache_(ADXArrayRow *arrayRow, ADXCache *cache) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXArrayLinkedVariables *create_ADXArrayLinkedVariables_initWithADXArrayRow_withADXCache_(ADXArrayRow *arrayRow, ADXCache *cache);

J2OBJC_TYPE_LITERAL_HEADER(ADXArrayLinkedVariables)

@compatibility_alias AndroidxConstraintlayoutCoreArrayLinkedVariables ADXArrayLinkedVariables;

#endif

#pragma pop_macro("INCLUDE_ALL_ArrayLinkedVariables")
