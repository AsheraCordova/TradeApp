//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\motion\MotionPaths.java
//

#include "CustomVariable.h"
#include "Easing.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "Motion.h"
#include "MotionKeyPosition.h"
#include "MotionPaths.h"
#include "MotionWidget.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/Math.h"
#include "java/util/Arrays.h"
#include "java/util/HashMap.h"
#include "java/util/Set.h"


@interface ADXMotionPaths ()

+ (jfloat)xRotateWithFloat:(jfloat)sin
                 withFloat:(jfloat)cos
                 withFloat:(jfloat)cx
                 withFloat:(jfloat)cy
                 withFloat:(jfloat)x
                 withFloat:(jfloat)y;

+ (jfloat)yRotateWithFloat:(jfloat)sin
                 withFloat:(jfloat)cos
                 withFloat:(jfloat)cx
                 withFloat:(jfloat)cy
                 withFloat:(jfloat)x
                 withFloat:(jfloat)y;

- (jboolean)diffWithFloat:(jfloat)a
                withFloat:(jfloat)b;

@end

__attribute__((unused)) static jfloat ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(jfloat sin, jfloat cos, jfloat cx, jfloat cy, jfloat x, jfloat y);

__attribute__((unused)) static jfloat ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(jfloat sin, jfloat cos, jfloat cx, jfloat cy, jfloat x, jfloat y);

__attribute__((unused)) static jboolean ADXMotionPaths_diffWithFloat_withFloat_(ADXMotionPaths *self, jfloat a, jfloat b);

J2OBJC_INITIALIZED_DEFN(ADXMotionPaths)

NSString *ADXMotionPaths_TAG = @"MotionPaths";
IOSObjectArray *ADXMotionPaths_names;

@implementation ADXMotionPaths

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXMotionPaths_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)initCartesianWithADXMotionKeyPosition:(ADXMotionKeyPosition *)c
                           withADXMotionPaths:(ADXMotionPaths *)startTimePoint
                           withADXMotionPaths:(ADXMotionPaths *)endTimePoint {
  jfloat position = ((ADXMotionKeyPosition *) nil_chk(c))->mFramePosition_ / 100.0f;
  ADXMotionPaths *point = self;
  point->time_ = position;
  mDrawPath_ = c->mDrawPath_;
  jfloat scaleWidth = JavaLangFloat_isNaNWithFloat_(c->mPercentWidth_) ? position : c->mPercentWidth_;
  jfloat scaleHeight = JavaLangFloat_isNaNWithFloat_(c->mPercentHeight_) ? position : c->mPercentHeight_;
  jfloat scaleX = ((ADXMotionPaths *) nil_chk(endTimePoint))->width_ - ((ADXMotionPaths *) nil_chk(startTimePoint))->width_;
  jfloat scaleY = endTimePoint->height_ - startTimePoint->height_;
  point->position_ = point->time_;
  jfloat path = position;
  jfloat startCenterX = startTimePoint->x_ + startTimePoint->width_ / 2;
  jfloat startCenterY = startTimePoint->y_ + startTimePoint->height_ / 2;
  jfloat endCenterX = endTimePoint->x_ + endTimePoint->width_ / 2;
  jfloat endCenterY = endTimePoint->y_ + endTimePoint->height_ / 2;
  jfloat pathVectorX = endCenterX - startCenterX;
  jfloat pathVectorY = endCenterY - startCenterY;
  point->x_ = JreFpToInt((startTimePoint->x_ + (pathVectorX) * path - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + (pathVectorY) * path - scaleY * scaleHeight / 2));
  point->width_ = JreFpToInt((startTimePoint->width_ + scaleX * scaleWidth));
  point->height_ = JreFpToInt((startTimePoint->height_ + scaleY * scaleHeight));
  jfloat dxdx = (JavaLangFloat_isNaNWithFloat_(c->mPercentX_)) ? position : c->mPercentX_;
  jfloat dydx = (JavaLangFloat_isNaNWithFloat_(c->mAltPercentY_)) ? 0 : c->mAltPercentY_;
  jfloat dydy = (JavaLangFloat_isNaNWithFloat_(c->mPercentY_)) ? position : c->mPercentY_;
  jfloat dxdy = (JavaLangFloat_isNaNWithFloat_(c->mAltPercentX_)) ? 0 : c->mAltPercentX_;
  point->mMode_ = ADXMotionPaths_CARTESIAN;
  point->x_ = JreFpToInt((startTimePoint->x_ + pathVectorX * dxdx + pathVectorY * dxdy - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + pathVectorX * dydx + pathVectorY * dydy - scaleY * scaleHeight / 2));
  JreStrongAssign(&point->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(c->mTransitionEasing_));
  point->mPathMotionArc_ = c->mPathMotionArc_;
}

- (instancetype)initWithInt:(jint)parentWidth
                    withInt:(jint)parentHeight
   withADXMotionKeyPosition:(ADXMotionKeyPosition *)c
         withADXMotionPaths:(ADXMotionPaths *)startTimePoint
         withADXMotionPaths:(ADXMotionPaths *)endTimePoint {
  ADXMotionPaths_initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_(self, parentWidth, parentHeight, c, startTimePoint, endTimePoint);
  return self;
}

- (void)initPolarWithInt:(jint)parentWidth
                 withInt:(jint)parentHeight
withADXMotionKeyPosition:(ADXMotionKeyPosition *)c
      withADXMotionPaths:(ADXMotionPaths *)s
      withADXMotionPaths:(ADXMotionPaths *)e {
  jfloat position = ((ADXMotionKeyPosition *) nil_chk(c))->mFramePosition_ / 100.0f;
  self->time_ = position;
  mDrawPath_ = c->mDrawPath_;
  self->mMode_ = c->mPositionType_;
  jfloat scaleWidth = JavaLangFloat_isNaNWithFloat_(c->mPercentWidth_) ? position : c->mPercentWidth_;
  jfloat scaleHeight = JavaLangFloat_isNaNWithFloat_(c->mPercentHeight_) ? position : c->mPercentHeight_;
  jfloat scaleX = ((ADXMotionPaths *) nil_chk(e))->width_ - ((ADXMotionPaths *) nil_chk(s))->width_;
  jfloat scaleY = e->height_ - s->height_;
  self->position_ = self->time_;
  width_ = JreFpToInt((s->width_ + scaleX * scaleWidth));
  height_ = JreFpToInt((s->height_ + scaleY * scaleHeight));
  jfloat startfactor = 1 - position;
  jfloat endfactor = position;
  switch (c->mPositionType_) {
    case ADXMotionKeyPosition_TYPE_SCREEN:
    self->x_ = JavaLangFloat_isNaNWithFloat_(c->mPercentX_) ? (position * (e->x_ - s->x_) + s->x_) : c->mPercentX_ * JavaLangMath_minWithFloat_withFloat_(scaleHeight, scaleWidth);
    self->y_ = JavaLangFloat_isNaNWithFloat_(c->mPercentY_) ? (position * (e->y_ - s->y_) + s->y_) : c->mPercentY_;
    break;
    case ADXMotionKeyPosition_TYPE_PATH:
    self->x_ = (JavaLangFloat_isNaNWithFloat_(c->mPercentX_) ? position : c->mPercentX_) * (e->x_ - s->x_) + s->x_;
    self->y_ = (JavaLangFloat_isNaNWithFloat_(c->mPercentY_) ? position : c->mPercentY_) * (e->y_ - s->y_) + s->y_;
    break;
    default:
    case ADXMotionKeyPosition_TYPE_CARTESIAN:
    self->x_ = (JavaLangFloat_isNaNWithFloat_(c->mPercentX_) ? position : c->mPercentX_) * (e->x_ - s->x_) + s->x_;
    self->y_ = (JavaLangFloat_isNaNWithFloat_(c->mPercentY_) ? position : c->mPercentY_) * (e->y_ - s->y_) + s->y_;
    break;
  }
  self->mAnimateRelativeTo_ = s->mAnimateRelativeTo_;
  JreStrongAssign(&self->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(c->mTransitionEasing_));
  self->mPathMotionArc_ = c->mPathMotionArc_;
}

- (void)setupRelativeWithADXMotion:(ADXMotion *)mc
                withADXMotionPaths:(ADXMotionPaths *)relative {
  jdouble dx = x_ + width_ / 2 - ((ADXMotionPaths *) nil_chk(relative))->x_ - relative->width_ / 2;
  jdouble dy = y_ + height_ / 2 - relative->y_ - relative->height_ / 2;
  JreStrongAssign(&mRelativeToController_, mc);
  x_ = (jfloat) JavaLangMath_hypotWithDouble_withDouble_(dy, dx);
  if (JavaLangFloat_isNaNWithFloat_(mRelativeAngle_)) {
    y_ = (jfloat) (JavaLangMath_atan2WithDouble_withDouble_(dy, dx) + JavaLangMath_PI / 2);
  }
  else {
    y_ = (jfloat) JavaLangMath_toRadiansWithDouble_(mRelativeAngle_);
  }
}

- (void)initScreenWithInt:(jint)parentWidth
                  withInt:(jint)parentHeight
 withADXMotionKeyPosition:(ADXMotionKeyPosition *)c
       withADXMotionPaths:(ADXMotionPaths *)startTimePoint
       withADXMotionPaths:(ADXMotionPaths *)endTimePoint {
  jfloat position = ((ADXMotionKeyPosition *) nil_chk(c))->mFramePosition_ / 100.0f;
  ADXMotionPaths *point = self;
  point->time_ = position;
  mDrawPath_ = c->mDrawPath_;
  jfloat scaleWidth = JavaLangFloat_isNaNWithFloat_(c->mPercentWidth_) ? position : c->mPercentWidth_;
  jfloat scaleHeight = JavaLangFloat_isNaNWithFloat_(c->mPercentHeight_) ? position : c->mPercentHeight_;
  jfloat scaleX = ((ADXMotionPaths *) nil_chk(endTimePoint))->width_ - ((ADXMotionPaths *) nil_chk(startTimePoint))->width_;
  jfloat scaleY = endTimePoint->height_ - startTimePoint->height_;
  point->position_ = point->time_;
  jfloat path = position;
  jfloat startCenterX = startTimePoint->x_ + startTimePoint->width_ / 2;
  jfloat startCenterY = startTimePoint->y_ + startTimePoint->height_ / 2;
  jfloat endCenterX = endTimePoint->x_ + endTimePoint->width_ / 2;
  jfloat endCenterY = endTimePoint->y_ + endTimePoint->height_ / 2;
  jfloat pathVectorX = endCenterX - startCenterX;
  jfloat pathVectorY = endCenterY - startCenterY;
  point->x_ = JreFpToInt((startTimePoint->x_ + (pathVectorX) * path - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + (pathVectorY) * path - scaleY * scaleHeight / 2));
  point->width_ = JreFpToInt((startTimePoint->width_ + scaleX * scaleWidth));
  point->height_ = JreFpToInt((startTimePoint->height_ + scaleY * scaleHeight));
  point->mMode_ = ADXMotionPaths_SCREEN;
  if (!JavaLangFloat_isNaNWithFloat_(c->mPercentX_)) {
    JreMinusAssignIntF(&parentWidth, point->width_);
    point->x_ = JreFpToInt((c->mPercentX_ * parentWidth));
  }
  if (!JavaLangFloat_isNaNWithFloat_(c->mPercentY_)) {
    JreMinusAssignIntF(&parentHeight, point->height_);
    point->y_ = JreFpToInt((c->mPercentY_ * parentHeight));
  }
  point->mAnimateRelativeTo_ = mAnimateRelativeTo_;
  JreStrongAssign(&point->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(c->mTransitionEasing_));
  point->mPathMotionArc_ = c->mPathMotionArc_;
}

- (void)initPathWithADXMotionKeyPosition:(ADXMotionKeyPosition *)c
                      withADXMotionPaths:(ADXMotionPaths *)startTimePoint
                      withADXMotionPaths:(ADXMotionPaths *)endTimePoint {
  jfloat position = ((ADXMotionKeyPosition *) nil_chk(c))->mFramePosition_ / 100.0f;
  ADXMotionPaths *point = self;
  point->time_ = position;
  mDrawPath_ = c->mDrawPath_;
  jfloat scaleWidth = JavaLangFloat_isNaNWithFloat_(c->mPercentWidth_) ? position : c->mPercentWidth_;
  jfloat scaleHeight = JavaLangFloat_isNaNWithFloat_(c->mPercentHeight_) ? position : c->mPercentHeight_;
  jfloat scaleX = ((ADXMotionPaths *) nil_chk(endTimePoint))->width_ - ((ADXMotionPaths *) nil_chk(startTimePoint))->width_;
  jfloat scaleY = endTimePoint->height_ - startTimePoint->height_;
  point->position_ = point->time_;
  jfloat path = JavaLangFloat_isNaNWithFloat_(c->mPercentX_) ? position : c->mPercentX_;
  jfloat startCenterX = startTimePoint->x_ + startTimePoint->width_ / 2;
  jfloat startCenterY = startTimePoint->y_ + startTimePoint->height_ / 2;
  jfloat endCenterX = endTimePoint->x_ + endTimePoint->width_ / 2;
  jfloat endCenterY = endTimePoint->y_ + endTimePoint->height_ / 2;
  jfloat pathVectorX = endCenterX - startCenterX;
  jfloat pathVectorY = endCenterY - startCenterY;
  point->x_ = JreFpToInt((startTimePoint->x_ + (pathVectorX) * path - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + (pathVectorY) * path - scaleY * scaleHeight / 2));
  point->width_ = JreFpToInt((startTimePoint->width_ + scaleX * scaleWidth));
  point->height_ = JreFpToInt((startTimePoint->height_ + scaleY * scaleHeight));
  jfloat perpendicular = JavaLangFloat_isNaNWithFloat_(c->mPercentY_) ? 0 : c->mPercentY_;
  jfloat perpendicularX = -pathVectorY;
  jfloat perpendicularY = pathVectorX;
  jfloat normalX = perpendicularX * perpendicular;
  jfloat normalY = perpendicularY * perpendicular;
  point->mMode_ = ADXMotionPaths_PERPENDICULAR;
  point->x_ = JreFpToInt((startTimePoint->x_ + (pathVectorX) * path - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + (pathVectorY) * path - scaleY * scaleHeight / 2));
  JrePlusAssignFloatF(&point->x_, normalX);
  JrePlusAssignFloatF(&point->y_, normalY);
  point->mAnimateRelativeTo_ = mAnimateRelativeTo_;
  JreStrongAssign(&point->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(c->mTransitionEasing_));
  point->mPathMotionArc_ = c->mPathMotionArc_;
}

+ (jfloat)xRotateWithFloat:(jfloat)sin
                 withFloat:(jfloat)cos
                 withFloat:(jfloat)cx
                 withFloat:(jfloat)cy
                 withFloat:(jfloat)x
                 withFloat:(jfloat)y {
  return ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x, y);
}

+ (jfloat)yRotateWithFloat:(jfloat)sin
                 withFloat:(jfloat)cos
                 withFloat:(jfloat)cx
                 withFloat:(jfloat)cy
                 withFloat:(jfloat)x
                 withFloat:(jfloat)y {
  return ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x, y);
}

- (jboolean)diffWithFloat:(jfloat)a
                withFloat:(jfloat)b {
  return ADXMotionPaths_diffWithFloat_withFloat_(self, a, b);
}

- (void)differentWithADXMotionPaths:(ADXMotionPaths *)points
                   withBooleanArray:(IOSBooleanArray *)mask
                  withNSStringArray:(IOSObjectArray *)custom
                        withBoolean:(jboolean)arcMode {
  jint c = 0;
  jboolean diffx = ADXMotionPaths_diffWithFloat_withFloat_(self, x_, ((ADXMotionPaths *) nil_chk(points))->x_);
  jboolean diffy = ADXMotionPaths_diffWithFloat_withFloat_(self, y_, points->y_);
  *IOSBooleanArray_GetRef(nil_chk(mask), c++) |= ADXMotionPaths_diffWithFloat_withFloat_(self, position_, points->position_);
  *IOSBooleanArray_GetRef(mask, c++) |= (diffx | diffy | arcMode);
  *IOSBooleanArray_GetRef(mask, c++) |= (diffx | diffy | arcMode);
  *IOSBooleanArray_GetRef(mask, c++) |= ADXMotionPaths_diffWithFloat_withFloat_(self, width_, points->width_);
  *IOSBooleanArray_GetRef(mask, c++) |= ADXMotionPaths_diffWithFloat_withFloat_(self, height_, points->height_);
}

- (void)getCenterWithDouble:(jdouble)p
               withIntArray:(IOSIntArray *)toUse
            withDoubleArray:(IOSDoubleArray *)data
             withFloatArray:(IOSFloatArray *)point
                    withInt:(jint)offset {
  jfloat v_x = x_;
  jfloat v_y = y_;
  jfloat v_width = width_;
  jfloat v_height = height_;
  jfloat translationX = 0;
  jfloat translationY = 0;
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    jfloat value = (jfloat) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_X:
      v_x = value;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      break;
    }
  }
  if (mRelativeToController_ != nil) {
    IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
    IOSFloatArray *vel = [IOSFloatArray arrayWithLength:2];
    [mRelativeToController_ getCenterWithDouble:p withFloatArray:pos withFloatArray:vel];
    jfloat rx = IOSFloatArray_Get(pos, 0);
    jfloat ry = IOSFloatArray_Get(pos, 1);
    jfloat radius = v_x;
    jfloat angle = v_y;
    v_x = (jfloat) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    v_y = (jfloat) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
  }
  *IOSFloatArray_GetRef(nil_chk(point), offset) = v_x + v_width / 2 + translationX;
  *IOSFloatArray_GetRef(point, offset + 1) = v_y + v_height / 2 + translationY;
}

- (void)getCenterWithDouble:(jdouble)p
               withIntArray:(IOSIntArray *)toUse
            withDoubleArray:(IOSDoubleArray *)data
             withFloatArray:(IOSFloatArray *)point
            withDoubleArray:(IOSDoubleArray *)vdata
             withFloatArray:(IOSFloatArray *)velocity {
  jfloat v_x = x_;
  jfloat v_y = y_;
  jfloat v_width = width_;
  jfloat v_height = height_;
  jfloat dv_x = 0;
  jfloat dv_y = 0;
  jfloat dv_width = 0;
  jfloat dv_height = 0;
  jfloat translationX = 0;
  jfloat translationY = 0;
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    jfloat value = (jfloat) IOSDoubleArray_Get(nil_chk(data), i);
    jfloat dvalue = (jfloat) IOSDoubleArray_Get(nil_chk(vdata), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_X:
      v_x = value;
      dv_x = dvalue;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      dv_y = dvalue;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      dv_width = dvalue;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      dv_height = dvalue;
      break;
    }
  }
  jfloat dpos_x = dv_x + dv_width / 2;
  jfloat dpos_y = dv_y + dv_height / 2;
  if (mRelativeToController_ != nil) {
    IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
    IOSFloatArray *vel = [IOSFloatArray arrayWithLength:2];
    [mRelativeToController_ getCenterWithDouble:p withFloatArray:pos withFloatArray:vel];
    jfloat rx = IOSFloatArray_Get(pos, 0);
    jfloat ry = IOSFloatArray_Get(pos, 1);
    jfloat radius = v_x;
    jfloat angle = v_y;
    jfloat dradius = dv_x;
    jfloat dangle = dv_y;
    jfloat drx = IOSFloatArray_Get(vel, 0);
    jfloat dry = IOSFloatArray_Get(vel, 1);
    v_x = (jfloat) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    v_y = (jfloat) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
    dpos_x = (jfloat) (drx + dradius * JavaLangMath_sinWithDouble_(angle) + JavaLangMath_cosWithDouble_(angle) * dangle);
    dpos_y = (jfloat) (dry - dradius * JavaLangMath_cosWithDouble_(angle) + JavaLangMath_sinWithDouble_(angle) * dangle);
  }
  *IOSFloatArray_GetRef(nil_chk(point), 0) = v_x + v_width / 2 + translationX;
  *IOSFloatArray_GetRef(point, 1) = v_y + v_height / 2 + translationY;
  *IOSFloatArray_GetRef(nil_chk(velocity), 0) = dpos_x;
  *IOSFloatArray_GetRef(velocity, 1) = dpos_y;
}

- (void)getCenterVelocityWithDouble:(jdouble)p
                       withIntArray:(IOSIntArray *)toUse
                    withDoubleArray:(IOSDoubleArray *)data
                     withFloatArray:(IOSFloatArray *)point
                            withInt:(jint)offset {
  jfloat v_x = x_;
  jfloat v_y = y_;
  jfloat v_width = width_;
  jfloat v_height = height_;
  jfloat translationX = 0;
  jfloat translationY = 0;
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    jfloat value = (jfloat) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_X:
      v_x = value;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      break;
    }
  }
  if (mRelativeToController_ != nil) {
    IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
    IOSFloatArray *vel = [IOSFloatArray arrayWithLength:2];
    [mRelativeToController_ getCenterWithDouble:p withFloatArray:pos withFloatArray:vel];
    jfloat rx = IOSFloatArray_Get(pos, 0);
    jfloat ry = IOSFloatArray_Get(pos, 1);
    jfloat radius = v_x;
    jfloat angle = v_y;
    v_x = (jfloat) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    v_y = (jfloat) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
  }
  *IOSFloatArray_GetRef(nil_chk(point), offset) = v_x + v_width / 2 + translationX;
  *IOSFloatArray_GetRef(point, offset + 1) = v_y + v_height / 2 + translationY;
}

- (void)getBoundsWithIntArray:(IOSIntArray *)toUse
              withDoubleArray:(IOSDoubleArray *)data
               withFloatArray:(IOSFloatArray *)point
                      withInt:(jint)offset {
  jfloat v_x = x_;
  jfloat v_y = y_;
  jfloat v_width = width_;
  jfloat v_height = height_;
  jfloat translationX = 0;
  jfloat translationY = 0;
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    jfloat value = (jfloat) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_X:
      v_x = value;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      break;
    }
  }
  *IOSFloatArray_GetRef(nil_chk(point), offset) = v_width;
  *IOSFloatArray_GetRef(point, offset + 1) = v_height;
}

- (void)setViewWithFloat:(jfloat)position
     withADXMotionWidget:(ADXMotionWidget *)view
            withIntArray:(IOSIntArray *)toUse
         withDoubleArray:(IOSDoubleArray *)data
         withDoubleArray:(IOSDoubleArray *)slope
         withDoubleArray:(IOSDoubleArray *)cycle {
  jfloat v_x = x_;
  jfloat v_y = y_;
  jfloat v_width = width_;
  jfloat v_height = height_;
  jfloat dv_x = 0;
  jfloat dv_y = 0;
  jfloat dv_width = 0;
  jfloat dv_height = 0;
  jfloat delta_path = 0;
  jfloat path_rotate = JavaLangFloat_NaN;
  NSString *mod;
  if (((IOSIntArray *) nil_chk(toUse))->size_ != 0 && ((IOSDoubleArray *) nil_chk(mTempValue_))->size_ <= IOSIntArray_Get(toUse, toUse->size_ - 1)) {
    jint scratch_data_length = IOSIntArray_Get(toUse, toUse->size_ - 1) + 1;
    JreStrongAssignAndConsume(&mTempValue_, [IOSDoubleArray newArrayWithLength:scratch_data_length]);
    JreStrongAssignAndConsume(&mTempDelta_, [IOSDoubleArray newArrayWithLength:scratch_data_length]);
  }
  JavaUtilArrays_fillWithDoubleArray_withDouble_(mTempValue_, JavaLangDouble_NaN);
  for (jint i = 0; i < toUse->size_; i++) {
    *IOSDoubleArray_GetRef(nil_chk(mTempValue_), IOSIntArray_Get(toUse, i)) = IOSDoubleArray_Get(nil_chk(data), i);
    *IOSDoubleArray_GetRef(nil_chk(mTempDelta_), IOSIntArray_Get(toUse, i)) = IOSDoubleArray_Get(nil_chk(slope), i);
  }
  for (jint i = 0; i < ((IOSDoubleArray *) nil_chk(mTempValue_))->size_; i++) {
    if (JavaLangDouble_isNaNWithDouble_(IOSDoubleArray_Get(mTempValue_, i)) && (cycle == nil || IOSDoubleArray_Get(cycle, i) == 0.0)) {
      continue;
    }
    jdouble deltaCycle = (cycle != nil) ? IOSDoubleArray_Get(nil_chk(cycle), i) : 0.0;
    jfloat value = (jfloat) (JavaLangDouble_isNaNWithDouble_(IOSDoubleArray_Get(nil_chk(mTempValue_), i)) ? deltaCycle : IOSDoubleArray_Get(nil_chk(mTempValue_), i) + deltaCycle);
    jfloat dvalue = (jfloat) IOSDoubleArray_Get(nil_chk(mTempDelta_), i);
    switch (i) {
      case ADXMotionPaths_OFF_POSITION:
      delta_path = value;
      break;
      case ADXMotionPaths_OFF_X:
      v_x = value;
      dv_x = dvalue;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      dv_y = dvalue;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      dv_width = dvalue;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      dv_height = dvalue;
      break;
      case ADXMotionPaths_OFF_PATH_ROTATE:
      path_rotate = value;
      break;
    }
  }
  if (mRelativeToController_ != nil) {
    IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
    IOSFloatArray *vel = [IOSFloatArray arrayWithLength:2];
    [mRelativeToController_ getCenterWithDouble:position withFloatArray:pos withFloatArray:vel];
    jfloat rx = IOSFloatArray_Get(pos, 0);
    jfloat ry = IOSFloatArray_Get(pos, 1);
    jfloat radius = v_x;
    jfloat angle = v_y;
    jfloat dradius = dv_x;
    jfloat dangle = dv_y;
    jfloat drx = IOSFloatArray_Get(vel, 0);
    jfloat dry = IOSFloatArray_Get(vel, 1);
    jfloat pos_x = (jfloat) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    jfloat pos_y = (jfloat) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
    jfloat dpos_x = (jfloat) (drx + dradius * JavaLangMath_sinWithDouble_(angle) + radius * JavaLangMath_cosWithDouble_(angle) * dangle);
    jfloat dpos_y = (jfloat) (dry - dradius * JavaLangMath_cosWithDouble_(angle) + radius * JavaLangMath_sinWithDouble_(angle) * dangle);
    dv_x = dpos_x;
    dv_y = dpos_y;
    v_x = pos_x;
    v_y = pos_y;
    if (((IOSDoubleArray *) nil_chk(slope))->size_ >= 2) {
      *IOSDoubleArray_GetRef(slope, 0) = dpos_x;
      *IOSDoubleArray_GetRef(slope, 1) = dpos_y;
    }
    if (!JavaLangFloat_isNaNWithFloat_(path_rotate)) {
      jfloat rot = (jfloat) (path_rotate + JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(dv_y, dv_x)));
      [((ADXMotionWidget *) nil_chk(view)) setRotationZWithFloat:rot];
    }
  }
  else {
    if (!JavaLangFloat_isNaNWithFloat_(path_rotate)) {
      jfloat rot = 0;
      jfloat dx = dv_x + dv_width / 2;
      jfloat dy = dv_y + dv_height / 2;
      JrePlusAssignFloatD(&rot, path_rotate + JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(dy, dx)));
      [((ADXMotionWidget *) nil_chk(view)) setRotationZWithFloat:rot];
    }
  }
  jint l = JreFpToInt((0.5f + v_x));
  jint t = JreFpToInt((0.5f + v_y));
  jint r = JreFpToInt((0.5f + v_x + v_width));
  jint b = JreFpToInt((0.5f + v_y + v_height));
  jint i_width = r - l;
  jint i_height = b - t;
  [((ADXMotionWidget *) nil_chk(view)) layoutWithInt:l withInt:t withInt:r withInt:b];
}

- (void)getRectWithIntArray:(IOSIntArray *)toUse
            withDoubleArray:(IOSDoubleArray *)data
             withFloatArray:(IOSFloatArray *)path
                    withInt:(jint)offset {
  jfloat v_x = x_;
  jfloat v_y = y_;
  jfloat v_width = width_;
  jfloat v_height = height_;
  jfloat delta_path = 0;
  jfloat rotation = 0;
  jfloat alpha = 0;
  jfloat rotationX = 0;
  jfloat rotationY = 0;
  jfloat scaleX = 1;
  jfloat scaleY = 1;
  jfloat pivotX = JavaLangFloat_NaN;
  jfloat pivotY = JavaLangFloat_NaN;
  jfloat translationX = 0;
  jfloat translationY = 0;
  NSString *mod;
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    jfloat value = (jfloat) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_POSITION:
      delta_path = value;
      break;
      case ADXMotionPaths_OFF_X:
      v_x = value;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      break;
    }
  }
  if (mRelativeToController_ != nil) {
    jfloat rx = [mRelativeToController_ getCenterX];
    jfloat ry = [((ADXMotion *) nil_chk(mRelativeToController_)) getCenterY];
    jfloat radius = v_x;
    jfloat angle = v_y;
    v_x = (jfloat) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    v_y = (jfloat) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
  }
  jfloat x1 = v_x;
  jfloat y1 = v_y;
  jfloat x2 = v_x + v_width;
  jfloat y2 = y1;
  jfloat x3 = x2;
  jfloat y3 = v_y + v_height;
  jfloat x4 = x1;
  jfloat y4 = y3;
  jfloat cx = x1 + v_width / 2;
  jfloat cy = y1 + v_height / 2;
  if (!JavaLangFloat_isNaNWithFloat_(pivotX)) {
    cx = x1 + (x2 - x1) * pivotX;
  }
  if (!JavaLangFloat_isNaNWithFloat_(pivotY)) {
    cy = y1 + (y3 - y1) * pivotY;
  }
  if (scaleX != 1) {
    jfloat midx = (x1 + x2) / 2;
    x1 = (x1 - midx) * scaleX + midx;
    x2 = (x2 - midx) * scaleX + midx;
    x3 = (x3 - midx) * scaleX + midx;
    x4 = (x4 - midx) * scaleX + midx;
  }
  if (scaleY != 1) {
    jfloat midy = (y1 + y3) / 2;
    y1 = (y1 - midy) * scaleY + midy;
    y2 = (y2 - midy) * scaleY + midy;
    y3 = (y3 - midy) * scaleY + midy;
    y4 = (y4 - midy) * scaleY + midy;
  }
  if (rotation != 0) {
    jfloat sin = (jfloat) JavaLangMath_sinWithDouble_(JavaLangMath_toRadiansWithDouble_(rotation));
    jfloat cos = (jfloat) JavaLangMath_cosWithDouble_(JavaLangMath_toRadiansWithDouble_(rotation));
    jfloat tx1 = ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x1, y1);
    jfloat ty1 = ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x1, y1);
    jfloat tx2 = ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x2, y2);
    jfloat ty2 = ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x2, y2);
    jfloat tx3 = ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x3, y3);
    jfloat ty3 = ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x3, y3);
    jfloat tx4 = ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x4, y4);
    jfloat ty4 = ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x4, y4);
    x1 = tx1;
    y1 = ty1;
    x2 = tx2;
    y2 = ty2;
    x3 = tx3;
    y3 = ty3;
    x4 = tx4;
    y4 = ty4;
  }
  JrePlusAssignFloatF(&x1, translationX);
  JrePlusAssignFloatF(&y1, translationY);
  JrePlusAssignFloatF(&x2, translationX);
  JrePlusAssignFloatF(&y2, translationY);
  JrePlusAssignFloatF(&x3, translationX);
  JrePlusAssignFloatF(&y3, translationY);
  JrePlusAssignFloatF(&x4, translationX);
  JrePlusAssignFloatF(&y4, translationY);
  *IOSFloatArray_GetRef(nil_chk(path), offset++) = x1;
  *IOSFloatArray_GetRef(path, offset++) = y1;
  *IOSFloatArray_GetRef(path, offset++) = x2;
  *IOSFloatArray_GetRef(path, offset++) = y2;
  *IOSFloatArray_GetRef(path, offset++) = x3;
  *IOSFloatArray_GetRef(path, offset++) = y3;
  *IOSFloatArray_GetRef(path, offset++) = x4;
  *IOSFloatArray_GetRef(path, offset++) = y4;
}

- (void)setDpDtWithFloat:(jfloat)locationX
               withFloat:(jfloat)locationY
          withFloatArray:(IOSFloatArray *)mAnchorDpDt
            withIntArray:(IOSIntArray *)toUse
         withDoubleArray:(IOSDoubleArray *)deltaData
         withDoubleArray:(IOSDoubleArray *)data {
  jfloat d_x = 0;
  jfloat d_y = 0;
  jfloat d_width = 0;
  jfloat d_height = 0;
  jfloat deltaScaleX = 0;
  jfloat deltaScaleY = 0;
  jfloat mPathRotate = JavaLangFloat_NaN;
  jfloat deltaTranslationX = 0;
  jfloat deltaTranslationY = 0;
  NSString *mod = @" dd = ";
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    jfloat deltaV = (jfloat) IOSDoubleArray_Get(nil_chk(deltaData), i);
    jfloat value = (jfloat) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_POSITION:
      break;
      case ADXMotionPaths_OFF_X:
      d_x = deltaV;
      break;
      case ADXMotionPaths_OFF_Y:
      d_y = deltaV;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      d_width = deltaV;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      d_height = deltaV;
      break;
    }
  }
  jfloat deltaX = d_x - deltaScaleX * d_width / 2;
  jfloat deltaY = d_y - deltaScaleY * d_height / 2;
  jfloat deltaWidth = d_width * (1 + deltaScaleX);
  jfloat deltaHeight = d_height * (1 + deltaScaleY);
  jfloat deltaRight = deltaX + deltaWidth;
  jfloat deltaBottom = deltaY + deltaHeight;
  *IOSFloatArray_GetRef(nil_chk(mAnchorDpDt), 0) = deltaX * (1 - locationX) + deltaRight * (locationX) + deltaTranslationX;
  *IOSFloatArray_GetRef(mAnchorDpDt, 1) = deltaY * (1 - locationY) + deltaBottom * (locationY) + deltaTranslationY;
}

- (void)fillStandardWithDoubleArray:(IOSDoubleArray *)data
                       withIntArray:(IOSIntArray *)toUse {
  IOSFloatArray *set = [IOSFloatArray arrayWithFloats:(jfloat[]){ position_, x_, y_, width_, height_, mPathRotate_ } count:6];
  jint c = 0;
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    if (IOSIntArray_Get(toUse, i) < set->size_) {
      *IOSDoubleArray_GetRef(nil_chk(data), c++) = IOSFloatArray_Get(set, IOSIntArray_Get(toUse, i));
    }
  }
}

- (jboolean)hasCustomDataWithNSString:(NSString *)name {
  return [((JavaUtilHashMap *) nil_chk(customAttributes_)) containsKeyWithId:name];
}

- (jint)getCustomDataCountWithNSString:(NSString *)name {
  ADXCustomVariable *a = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(customAttributes_)) getWithId:name]);
  if (a == nil) {
    return 0;
  }
  return [a numberOfInterpolatedValues];
}

- (jint)getCustomDataWithNSString:(NSString *)name
                  withDoubleArray:(IOSDoubleArray *)value
                          withInt:(jint)offset {
  ADXCustomVariable *a = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(customAttributes_)) getWithId:name]);
  if (a == nil) {
    return 0;
  }
  else if ([a numberOfInterpolatedValues] == 1) {
    *IOSDoubleArray_GetRef(nil_chk(value), offset) = [a getValueToInterpolate];
    return 1;
  }
  else {
    jint N = [a numberOfInterpolatedValues];
    IOSFloatArray *f = [IOSFloatArray arrayWithLength:N];
    [a getValuesToInterpolateWithFloatArray:f];
    for (jint i = 0; i < N; i++) {
      *IOSDoubleArray_GetRef(nil_chk(value), offset++) = IOSFloatArray_Get(f, i);
    }
    return N;
  }
}

- (void)setBoundsWithFloat:(jfloat)x
                 withFloat:(jfloat)y
                 withFloat:(jfloat)w
                 withFloat:(jfloat)h {
  self->x_ = x;
  self->y_ = y;
  width_ = w;
  height_ = h;
}

- (jint)compareToWithId:(ADXMotionPaths *)o {
  cast_chk(o, [ADXMotionPaths class]);
  return JavaLangFloat_compareWithFloat_withFloat_(position_, ((ADXMotionPaths *) nil_chk(o))->position_);
}

- (void)applyParametersWithADXMotionWidget:(ADXMotionWidget *)c {
  ADXMotionPaths *point = self;
  JreStrongAssign(&point->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(((ADXMotionWidget_Motion *) nil_chk(((ADXMotionWidget *) nil_chk(c))->motion_))->mTransitionEasing_));
  point->mPathMotionArc_ = ((ADXMotionWidget_Motion *) nil_chk(c->motion_))->mPathMotionArc_;
  point->mAnimateRelativeTo_ = c->motion_->mAnimateRelativeTo_;
  point->mPathRotate_ = c->motion_->mPathRotate_;
  point->mDrawPath_ = c->motion_->mDrawPath_;
  point->mAnimateCircleAngleTo_ = c->motion_->mAnimateCircleAngleTo_;
  point->mProgress_ = ((ADXMotionWidget_PropertySet *) nil_chk(c->propertySet_))->mProgress_;
  point->mRelativeAngle_ = 0;
  id<JavaUtilSet> at = JreRetainedLocalValue([c getCustomAttributeNames]);
  for (NSString * __strong s in nil_chk(at)) {
    ADXCustomVariable *attr = JreRetainedLocalValue([c getCustomAttributeWithNSString:s]);
    if (attr != nil && [attr isContinuous]) {
      [((JavaUtilHashMap *) nil_chk(self->customAttributes_)) putWithId:s withId:attr];
    }
  }
}

- (void)configureRelativeToWithADXMotion:(ADXMotion *)toOrbit {
  IOSDoubleArray *p = [((ADXMotion *) nil_chk(toOrbit)) getPosWithDouble:mProgress_];
}

- (void)dealloc {
  RELEASE_(mKeyFrameEasing_);
  RELEASE_(mRelativeToController_);
  RELEASE_(customAttributes_);
  RELEASE_(mTempValue_);
  RELEASE_(mTempDelta_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 3, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 6, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 7, 1, -1, -1, -1, -1 },
    { NULL, "F", 0x1a, 8, 9, -1, -1, -1, -1 },
    { NULL, "F", 0x1a, 10, 9, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 15, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 15, 17, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 18, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 19, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 21, 22, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 23, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 24, 25, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 26, 27, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 28, 29, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 30, 29, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 31, 32, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 33, 34, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 35, 36, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 37, 38, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 39, 40, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initCartesianWithADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[2].selector = @selector(initWithInt:withInt:withADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[3].selector = @selector(initPolarWithInt:withInt:withADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[4].selector = @selector(setupRelativeWithADXMotion:withADXMotionPaths:);
  methods[5].selector = @selector(initScreenWithInt:withInt:withADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[6].selector = @selector(initPathWithADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[7].selector = @selector(xRotateWithFloat:withFloat:withFloat:withFloat:withFloat:withFloat:);
  methods[8].selector = @selector(yRotateWithFloat:withFloat:withFloat:withFloat:withFloat:withFloat:);
  methods[9].selector = @selector(diffWithFloat:withFloat:);
  methods[10].selector = @selector(differentWithADXMotionPaths:withBooleanArray:withNSStringArray:withBoolean:);
  methods[11].selector = @selector(getCenterWithDouble:withIntArray:withDoubleArray:withFloatArray:withInt:);
  methods[12].selector = @selector(getCenterWithDouble:withIntArray:withDoubleArray:withFloatArray:withDoubleArray:withFloatArray:);
  methods[13].selector = @selector(getCenterVelocityWithDouble:withIntArray:withDoubleArray:withFloatArray:withInt:);
  methods[14].selector = @selector(getBoundsWithIntArray:withDoubleArray:withFloatArray:withInt:);
  methods[15].selector = @selector(setViewWithFloat:withADXMotionWidget:withIntArray:withDoubleArray:withDoubleArray:withDoubleArray:);
  methods[16].selector = @selector(getRectWithIntArray:withDoubleArray:withFloatArray:withInt:);
  methods[17].selector = @selector(setDpDtWithFloat:withFloat:withFloatArray:withIntArray:withDoubleArray:withDoubleArray:);
  methods[18].selector = @selector(fillStandardWithDoubleArray:withIntArray:);
  methods[19].selector = @selector(hasCustomDataWithNSString:);
  methods[20].selector = @selector(getCustomDataCountWithNSString:);
  methods[21].selector = @selector(getCustomDataWithNSString:withDoubleArray:withInt:);
  methods[22].selector = @selector(setBoundsWithFloat:withFloat:withFloat:withFloat:);
  methods[23].selector = @selector(compareToWithId:);
  methods[24].selector = @selector(applyParametersWithADXMotionWidget:);
  methods[25].selector = @selector(configureRelativeToWithADXMotion:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 41, -1, -1 },
    { "DEBUG", "Z", .constantValue.asBOOL = ADXMotionPaths_DEBUG, 0x19, -1, -1, -1, -1 },
    { "OLD_WAY", "Z", .constantValue.asBOOL = ADXMotionPaths_OLD_WAY, 0x19, -1, -1, -1, -1 },
    { "OFF_POSITION", "I", .constantValue.asInt = ADXMotionPaths_OFF_POSITION, 0x18, -1, -1, -1, -1 },
    { "OFF_X", "I", .constantValue.asInt = ADXMotionPaths_OFF_X, 0x18, -1, -1, -1, -1 },
    { "OFF_Y", "I", .constantValue.asInt = ADXMotionPaths_OFF_Y, 0x18, -1, -1, -1, -1 },
    { "OFF_WIDTH", "I", .constantValue.asInt = ADXMotionPaths_OFF_WIDTH, 0x18, -1, -1, -1, -1 },
    { "OFF_HEIGHT", "I", .constantValue.asInt = ADXMotionPaths_OFF_HEIGHT, 0x18, -1, -1, -1, -1 },
    { "OFF_PATH_ROTATE", "I", .constantValue.asInt = ADXMotionPaths_OFF_PATH_ROTATE, 0x18, -1, -1, -1, -1 },
    { "PERPENDICULAR", "I", .constantValue.asInt = ADXMotionPaths_PERPENDICULAR, 0x19, -1, -1, -1, -1 },
    { "CARTESIAN", "I", .constantValue.asInt = ADXMotionPaths_CARTESIAN, 0x19, -1, -1, -1, -1 },
    { "SCREEN", "I", .constantValue.asInt = ADXMotionPaths_SCREEN, 0x19, -1, -1, -1, -1 },
    { "names", "[LNSString;", .constantValue.asLong = 0, 0x8, -1, 42, -1, -1 },
    { "mKeyFrameEasing_", "LADXEasing;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mDrawPath_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "time_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "position_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "x_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "y_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "width_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "height_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mPathRotate_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mProgress_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mPathMotionArc_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mAnimateRelativeTo_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mRelativeAngle_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mRelativeToController_", "LADXMotion;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "customAttributes_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x0, -1, -1, 43, -1 },
    { "mMode_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mAnimateCircleAngleTo_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTempValue_", "[D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTempDelta_", "[D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "initCartesian", "LADXMotionKeyPosition;LADXMotionPaths;LADXMotionPaths;", "IILADXMotionKeyPosition;LADXMotionPaths;LADXMotionPaths;", "initPolar", "setupRelative", "LADXMotion;LADXMotionPaths;", "initScreen", "initPath", "xRotate", "FFFFFF", "yRotate", "diff", "FF", "different", "LADXMotionPaths;[Z[LNSString;Z", "getCenter", "D[I[D[FI", "D[I[D[F[D[F", "getCenterVelocity", "getBounds", "[I[D[FI", "setView", "FLADXMotionWidget;[I[D[D[D", "getRect", "setDpDt", "FF[F[I[D[D", "fillStandard", "[D[I", "hasCustomData", "LNSString;", "getCustomDataCount", "getCustomData", "LNSString;[DI", "setBounds", "FFFF", "compareTo", "LADXMotionPaths;", "applyParameters", "LADXMotionWidget;", "configureRelativeTo", "LADXMotion;", &ADXMotionPaths_TAG, &ADXMotionPaths_names, "Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/core/motion/CustomVariable;>;", "Ljava/lang/Object;Ljava/lang/Comparable<Landroidx/constraintlayout/core/motion/MotionPaths;>;" };
  static const J2ObjcClassInfo _ADXMotionPaths = { "MotionPaths", "androidx.constraintlayout.core.motion", ptrTable, methods, fields, 7, 0x1, 26, 32, -1, -1, -1, 44, -1 };
  return &_ADXMotionPaths;
}

+ (void)initialize {
  if (self == [ADXMotionPaths class]) {
    JreStrongAssignAndConsume(&ADXMotionPaths_names, [IOSObjectArray newArrayWithObjects:(id[]){ @"position", @"x", @"y", @"width", @"height", @"pathRotate" } count:6 type:NSString_class_()]);
    J2OBJC_SET_INITIALIZED(ADXMotionPaths)
  }
}

@end

void ADXMotionPaths_init(ADXMotionPaths *self) {
  NSObject_init(self);
  self->mDrawPath_ = 0;
  self->mPathRotate_ = JavaLangFloat_NaN;
  self->mProgress_ = JavaLangFloat_NaN;
  self->mPathMotionArc_ = ADXMotionWidget_UNSET;
  self->mAnimateRelativeTo_ = ADXMotionWidget_UNSET;
  self->mRelativeAngle_ = JavaLangFloat_NaN;
  JreStrongAssign(&self->mRelativeToController_, nil);
  JreStrongAssignAndConsume(&self->customAttributes_, new_JavaUtilHashMap_init());
  self->mMode_ = 0;
  JreStrongAssignAndConsume(&self->mTempValue_, [IOSDoubleArray newArrayWithLength:18]);
  JreStrongAssignAndConsume(&self->mTempDelta_, [IOSDoubleArray newArrayWithLength:18]);
}

ADXMotionPaths *new_ADXMotionPaths_init() {
  J2OBJC_NEW_IMPL(ADXMotionPaths, init)
}

ADXMotionPaths *create_ADXMotionPaths_init() {
  J2OBJC_CREATE_IMPL(ADXMotionPaths, init)
}

void ADXMotionPaths_initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_(ADXMotionPaths *self, jint parentWidth, jint parentHeight, ADXMotionKeyPosition *c, ADXMotionPaths *startTimePoint, ADXMotionPaths *endTimePoint) {
  NSObject_init(self);
  self->mDrawPath_ = 0;
  self->mPathRotate_ = JavaLangFloat_NaN;
  self->mProgress_ = JavaLangFloat_NaN;
  self->mPathMotionArc_ = ADXMotionWidget_UNSET;
  self->mAnimateRelativeTo_ = ADXMotionWidget_UNSET;
  self->mRelativeAngle_ = JavaLangFloat_NaN;
  JreStrongAssign(&self->mRelativeToController_, nil);
  JreStrongAssignAndConsume(&self->customAttributes_, new_JavaUtilHashMap_init());
  self->mMode_ = 0;
  JreStrongAssignAndConsume(&self->mTempValue_, [IOSDoubleArray newArrayWithLength:18]);
  JreStrongAssignAndConsume(&self->mTempDelta_, [IOSDoubleArray newArrayWithLength:18]);
  if (((ADXMotionPaths *) nil_chk(startTimePoint))->mAnimateRelativeTo_ != ADXMotionWidget_UNSET) {
    [self initPolarWithInt:parentWidth withInt:parentHeight withADXMotionKeyPosition:c withADXMotionPaths:startTimePoint withADXMotionPaths:endTimePoint];
    return;
  }
  switch (((ADXMotionKeyPosition *) nil_chk(c))->mPositionType_) {
    case ADXMotionKeyPosition_TYPE_SCREEN:
    [self initScreenWithInt:parentWidth withInt:parentHeight withADXMotionKeyPosition:c withADXMotionPaths:startTimePoint withADXMotionPaths:endTimePoint];
    return;
    case ADXMotionKeyPosition_TYPE_PATH:
    [self initPathWithADXMotionKeyPosition:c withADXMotionPaths:startTimePoint withADXMotionPaths:endTimePoint];
    return;
    default:
    case ADXMotionKeyPosition_TYPE_CARTESIAN:
    [self initCartesianWithADXMotionKeyPosition:c withADXMotionPaths:startTimePoint withADXMotionPaths:endTimePoint];
    return;
  }
}

ADXMotionPaths *new_ADXMotionPaths_initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_(jint parentWidth, jint parentHeight, ADXMotionKeyPosition *c, ADXMotionPaths *startTimePoint, ADXMotionPaths *endTimePoint) {
  J2OBJC_NEW_IMPL(ADXMotionPaths, initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_, parentWidth, parentHeight, c, startTimePoint, endTimePoint)
}

ADXMotionPaths *create_ADXMotionPaths_initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_(jint parentWidth, jint parentHeight, ADXMotionKeyPosition *c, ADXMotionPaths *startTimePoint, ADXMotionPaths *endTimePoint) {
  J2OBJC_CREATE_IMPL(ADXMotionPaths, initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_, parentWidth, parentHeight, c, startTimePoint, endTimePoint)
}

jfloat ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(jfloat sin, jfloat cos, jfloat cx, jfloat cy, jfloat x, jfloat y) {
  ADXMotionPaths_initialize();
  x = x - cx;
  y = y - cy;
  return x * cos - y * sin + cx;
}

jfloat ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(jfloat sin, jfloat cos, jfloat cx, jfloat cy, jfloat x, jfloat y) {
  ADXMotionPaths_initialize();
  x = x - cx;
  y = y - cy;
  return x * sin + y * cos + cy;
}

jboolean ADXMotionPaths_diffWithFloat_withFloat_(ADXMotionPaths *self, jfloat a, jfloat b) {
  if (JavaLangFloat_isNaNWithFloat_(a) || JavaLangFloat_isNaNWithFloat_(b)) {
    return JavaLangFloat_isNaNWithFloat_(a) != JavaLangFloat_isNaNWithFloat_(b);
  }
  return JavaLangMath_absWithFloat_(a - b) > 0.000001f;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXMotionPaths)
