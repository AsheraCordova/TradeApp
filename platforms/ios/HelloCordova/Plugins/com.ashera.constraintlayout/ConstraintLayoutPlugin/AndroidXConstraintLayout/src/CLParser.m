//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\parser\CLParser.java
//

#include "CLArray.h"
#include "CLContainer.h"
#include "CLElement.h"
#include "CLKey.h"
#include "CLNumber.h"
#include "CLObject.h"
#include "CLParser.h"
#include "CLParsingException.h"
#include "CLString.h"
#include "CLToken.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/PrintStream.h"
#include "java/lang/Enum.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"
#include "java/util/ArrayList.h"


@interface ADXCLParser () {
 @public
  NSString *mContent_;
  jboolean hasComment_;
  jint lineNumber_;
}

- (ADXCLElement *)getNextJsonElementWithInt:(jint)position
                                   withChar:(jchar)c
                           withADXCLElement:(ADXCLElement *)currentElement
                              withCharArray:(IOSCharArray *)content;

- (ADXCLElement *)createElementWithADXCLElement:(ADXCLElement *)currentElement
                                        withInt:(jint)position
                           withADXCLParser_TYPE:(ADXCLParser_TYPE *)type
                                    withBoolean:(jboolean)applyStart
                                  withCharArray:(IOSCharArray *)content;

@end

J2OBJC_FIELD_SETTER(ADXCLParser, mContent_, NSString *)

__attribute__((unused)) static ADXCLElement *ADXCLParser_getNextJsonElementWithInt_withChar_withADXCLElement_withCharArray_(ADXCLParser *self, jint position, jchar c, ADXCLElement *currentElement, IOSCharArray *content);

__attribute__((unused)) static ADXCLElement *ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(ADXCLParser *self, ADXCLElement *currentElement, jint position, ADXCLParser_TYPE *type, jboolean applyStart, IOSCharArray *content);

__attribute__((unused)) static void ADXCLParser_TYPE_initWithNSString_withInt_(ADXCLParser_TYPE *self, NSString *__name, jint __ordinal);

jboolean ADXCLParser_DEBUG = false;

@implementation ADXCLParser

+ (ADXCLObject *)parseWithNSString:(NSString *)string {
  return ADXCLParser_parseWithNSString_(string);
}

- (instancetype)initWithNSString:(NSString *)content {
  ADXCLParser_initWithNSString_(self, content);
  return self;
}

- (ADXCLObject *)parse {
  ADXCLObject *root = nil;
  IOSCharArray *content = [((NSString *) nil_chk(mContent_)) java_toCharArray];
  ADXCLElement *currentElement = nil;
  jint length = ((IOSCharArray *) nil_chk(content))->size_;
  lineNumber_ = 1;
  jint startIndex = -1;
  for (jint i = 0; i < length; i++) {
    jchar c = IOSCharArray_Get(content, i);
    if (c == '{') {
      startIndex = i;
      break;
    }
    if (c == 0x000a) {
      lineNumber_++;
    }
  }
  if (startIndex == -1) {
    @throw create_ADXCLParsingException_initWithNSString_withADXCLElement_(@"invalid json content", nil);
  }
  root = ADXCLObject_allocateWithCharArray_(content);
  [((ADXCLObject *) nil_chk(root)) setLineWithInt:lineNumber_];
  [root setStartWithLong:startIndex];
  currentElement = root;
  for (jint i = startIndex + 1; i < length; i++) {
    jchar c = IOSCharArray_Get(content, i);
    if (c == 0x000a) {
      lineNumber_++;
    }
    if (hasComment_) {
      if (c == 0x000a) {
        hasComment_ = false;
      }
      else {
        continue;
      }
    }
    if (currentElement == nil) {
      break;
    }
    if ([currentElement isDone]) {
      currentElement = ADXCLParser_getNextJsonElementWithInt_withChar_withADXCLElement_withCharArray_(self, i, c, currentElement, content);
    }
    else if ([currentElement isKindOfClass:[ADXCLObject class]]) {
      if (c == '}') {
        [currentElement setEndWithLong:i - 1];
      }
      else {
        currentElement = ADXCLParser_getNextJsonElementWithInt_withChar_withADXCLElement_withCharArray_(self, i, c, currentElement, content);
      }
    }
    else if ([currentElement isKindOfClass:[ADXCLArray class]]) {
      if (c == ']') {
        [currentElement setEndWithLong:i - 1];
      }
      else {
        currentElement = ADXCLParser_getNextJsonElementWithInt_withChar_withADXCLElement_withCharArray_(self, i, c, currentElement, content);
      }
    }
    else if ([currentElement isKindOfClass:[ADXCLString class]]) {
      jchar ck = IOSCharArray_Get(content, (jint) currentElement->start_);
      if (ck == c) {
        [currentElement setStartWithLong:currentElement->start_ + 1];
        [currentElement setEndWithLong:i - 1];
      }
    }
    else {
      if ([currentElement isKindOfClass:[ADXCLToken class]]) {
        ADXCLToken *token = (ADXCLToken *) currentElement;
        if (![token validateWithChar:c withLong:i]) {
          @throw create_ADXCLParsingException_initWithNSString_withADXCLElement_(JreStrcat("$$$I", @"parsing incorrect token ", [token content], @" at line ", lineNumber_), token);
        }
      }
      if ([currentElement isKindOfClass:[ADXCLKey class]] || [currentElement isKindOfClass:[ADXCLString class]]) {
        jchar ck = IOSCharArray_Get(content, (jint) currentElement->start_);
        if ((ck == '\'' || ck == '"') && ck == c) {
          [currentElement setStartWithLong:currentElement->start_ + 1];
          [currentElement setEndWithLong:i - 1];
        }
      }
      if (![currentElement isDone]) {
        if (c == '}' || c == ']' || c == ',' || c == ' ' || c == 0x0009 || c == 0x000d || c == 0x000a || c == ':') {
          [currentElement setEndWithLong:i - 1];
          if (c == '}' || c == ']') {
            currentElement = [currentElement getContainer];
            [((ADXCLElement *) nil_chk(currentElement)) setEndWithLong:i - 1];
            if ([currentElement isKindOfClass:[ADXCLKey class]]) {
              currentElement = [currentElement getContainer];
              [((ADXCLElement *) nil_chk(currentElement)) setEndWithLong:i - 1];
            }
          }
        }
      }
    }
    if ([((ADXCLElement *) nil_chk(currentElement)) isDone] && (!([currentElement isKindOfClass:[ADXCLKey class]]) || [((JavaUtilArrayList *) nil_chk(((ADXCLKey *) cast_chk(currentElement, [ADXCLKey class]))->mElements_)) size] > 0)) {
      currentElement = [currentElement getContainer];
    }
  }
  while (currentElement != nil && ![currentElement isDone]) {
    if ([currentElement isKindOfClass:[ADXCLString class]]) {
      [currentElement setStartWithLong:(jint) currentElement->start_ + 1];
    }
    [currentElement setEndWithLong:length - 1];
    currentElement = [currentElement getContainer];
  }
  if (ADXCLParser_DEBUG) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Root: ", [root toJSON])];
  }
  return root;
}

- (ADXCLElement *)getNextJsonElementWithInt:(jint)position
                                   withChar:(jchar)c
                           withADXCLElement:(ADXCLElement *)currentElement
                              withCharArray:(IOSCharArray *)content {
  return ADXCLParser_getNextJsonElementWithInt_withChar_withADXCLElement_withCharArray_(self, position, c, currentElement, content);
}

- (ADXCLElement *)createElementWithADXCLElement:(ADXCLElement *)currentElement
                                        withInt:(jint)position
                           withADXCLParser_TYPE:(ADXCLParser_TYPE *)type
                                    withBoolean:(jboolean)applyStart
                                  withCharArray:(IOSCharArray *)content {
  return ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(self, currentElement, position, type, applyStart, content);
}

- (void)dealloc {
  RELEASE_(mContent_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LADXCLObject;", 0x9, 0, 1, 2, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "LADXCLObject;", 0x1, -1, -1, 2, -1, -1, -1 },
    { NULL, "LADXCLElement;", 0x2, 3, 4, 2, -1, -1, -1 },
    { NULL, "LADXCLElement;", 0x2, 5, 6, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(parseWithNSString:);
  methods[1].selector = @selector(initWithNSString:);
  methods[2].selector = @selector(parse);
  methods[3].selector = @selector(getNextJsonElementWithInt:withChar:withADXCLElement:withCharArray:);
  methods[4].selector = @selector(createElementWithADXCLElement:withInt:withADXCLParser_TYPE:withBoolean:withCharArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEBUG", "Z", .constantValue.asLong = 0, 0x8, -1, 7, -1, -1 },
    { "mContent_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "hasComment_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lineNumber_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "parse", "LNSString;", "LADXCLParsingException;", "getNextJsonElement", "ICLADXCLElement;[C", "createElement", "LADXCLElement;ILADXCLParser_TYPE;Z[C", &ADXCLParser_DEBUG, "LADXCLParser_TYPE;" };
  static const J2ObjcClassInfo _ADXCLParser = { "CLParser", "androidx.constraintlayout.core.parser", ptrTable, methods, fields, 7, 0x1, 5, 4, -1, 8, -1, -1, -1 };
  return &_ADXCLParser;
}

@end

ADXCLObject *ADXCLParser_parseWithNSString_(NSString *string) {
  ADXCLParser_initialize();
  return [(create_ADXCLParser_initWithNSString_(string)) parse];
}

void ADXCLParser_initWithNSString_(ADXCLParser *self, NSString *content) {
  NSObject_init(self);
  self->hasComment_ = false;
  JreStrongAssign(&self->mContent_, content);
}

ADXCLParser *new_ADXCLParser_initWithNSString_(NSString *content) {
  J2OBJC_NEW_IMPL(ADXCLParser, initWithNSString_, content)
}

ADXCLParser *create_ADXCLParser_initWithNSString_(NSString *content) {
  J2OBJC_CREATE_IMPL(ADXCLParser, initWithNSString_, content)
}

ADXCLElement *ADXCLParser_getNextJsonElementWithInt_withChar_withADXCLElement_withCharArray_(ADXCLParser *self, jint position, jchar c, ADXCLElement *currentElement, IOSCharArray *content) {
  switch (c) {
    case ' ':
    case ':':
    case ',':
    case 0x0009:
    case 0x000d:
    case 0x000a:
    {
    }
    break;
    case '{':
    {
      currentElement = ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(self, currentElement, position, JreLoadEnum(ADXCLParser_TYPE, OBJECT), true, content);
    }
    break;
    case '[':
    {
      currentElement = ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(self, currentElement, position, JreLoadEnum(ADXCLParser_TYPE, ARRAY), true, content);
    }
    break;
    case ']':
    case '}':
    {
      [((ADXCLElement *) nil_chk(currentElement)) setEndWithLong:position - 1];
      currentElement = [currentElement getContainer];
      [((ADXCLElement *) nil_chk(currentElement)) setEndWithLong:position];
    }
    break;
    case '"':
    case '\'':
    {
      if ([currentElement isKindOfClass:[ADXCLObject class]]) {
        currentElement = ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(self, currentElement, position, JreLoadEnum(ADXCLParser_TYPE, KEY), true, content);
      }
      else {
        currentElement = ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(self, currentElement, position, JreLoadEnum(ADXCLParser_TYPE, STRING), true, content);
      }
    }
    break;
    case '/':
    {
      if (position + 1 < ((IOSCharArray *) nil_chk(content))->size_ && IOSCharArray_Get(content, position + 1) == '/') {
        self->hasComment_ = true;
      }
    }
    break;
    case '-':
    case '+':
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
      currentElement = ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(self, currentElement, position, JreLoadEnum(ADXCLParser_TYPE, NUMBER), true, content);
    }
    break;
    default:
    {
      if ([currentElement isKindOfClass:[ADXCLContainer class]] && !([currentElement isKindOfClass:[ADXCLObject class]])) {
        currentElement = ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(self, currentElement, position, JreLoadEnum(ADXCLParser_TYPE, TOKEN), true, content);
        ADXCLToken *token = (ADXCLToken *) cast_chk(currentElement, [ADXCLToken class]);
        if (![((ADXCLToken *) nil_chk(token)) validateWithChar:c withLong:position]) {
          @throw create_ADXCLParsingException_initWithNSString_withADXCLElement_(JreStrcat("$C$I", @"incorrect token <", c, @"> at line ", self->lineNumber_), token);
        }
      }
      else {
        currentElement = ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(self, currentElement, position, JreLoadEnum(ADXCLParser_TYPE, KEY), true, content);
      }
    }
  }
  return currentElement;
}

ADXCLElement *ADXCLParser_createElementWithADXCLElement_withInt_withADXCLParser_TYPE_withBoolean_withCharArray_(ADXCLParser *self, ADXCLElement *currentElement, jint position, ADXCLParser_TYPE *type, jboolean applyStart, IOSCharArray *content) {
  ADXCLElement *newElement = nil;
  if (ADXCLParser_DEBUG) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@$C", @"CREATE ", type, @" at ", IOSCharArray_Get(nil_chk(content), position))];
  }
  switch ([type ordinal]) {
    case ADXCLParser_TYPE_Enum_OBJECT:
    {
      newElement = ADXCLObject_allocateWithCharArray_(content);
      position++;
    }
    break;
    case ADXCLParser_TYPE_Enum_ARRAY:
    {
      newElement = ADXCLArray_allocateWithCharArray_(content);
      position++;
    }
    break;
    case ADXCLParser_TYPE_Enum_STRING:
    {
      newElement = ADXCLString_allocateWithCharArray_(content);
    }
    break;
    case ADXCLParser_TYPE_Enum_NUMBER:
    {
      newElement = ADXCLNumber_allocateWithCharArray_(content);
    }
    break;
    case ADXCLParser_TYPE_Enum_KEY:
    {
      newElement = ADXCLKey_allocateWithCharArray_(content);
    }
    break;
    case ADXCLParser_TYPE_Enum_TOKEN:
    {
      newElement = ADXCLToken_allocateWithCharArray_(content);
    }
    break;
    default:
    break;
  }
  if (newElement == nil) {
    return nil;
  }
  [newElement setLineWithInt:self->lineNumber_];
  if (applyStart) {
    [newElement setStartWithLong:position];
  }
  if ([currentElement isKindOfClass:[ADXCLContainer class]]) {
    ADXCLContainer *container = (ADXCLContainer *) currentElement;
    [newElement setContainerWithADXCLContainer:container];
  }
  return newElement;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXCLParser)

J2OBJC_INITIALIZED_DEFN(ADXCLParser_TYPE)

ADXCLParser_TYPE *ADXCLParser_TYPE_values_[7];

@implementation ADXCLParser_TYPE

+ (IOSObjectArray *)values {
  return ADXCLParser_TYPE_values();
}

+ (ADXCLParser_TYPE *)valueOfWithNSString:(NSString *)name {
  return ADXCLParser_TYPE_valueOfWithNSString_(name);
}

- (ADXCLParser_TYPE_Enum)toNSEnum {
  return (ADXCLParser_TYPE_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[LADXCLParser_TYPE;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXCLParser_TYPE;", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(values);
  methods[1].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "UNKNOWN", "LADXCLParser_TYPE;", .constantValue.asLong = 0, 0x4019, -1, 2, -1, -1 },
    { "OBJECT", "LADXCLParser_TYPE;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "ARRAY", "LADXCLParser_TYPE;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
    { "NUMBER", "LADXCLParser_TYPE;", .constantValue.asLong = 0, 0x4019, -1, 5, -1, -1 },
    { "STRING", "LADXCLParser_TYPE;", .constantValue.asLong = 0, 0x4019, -1, 6, -1, -1 },
    { "KEY", "LADXCLParser_TYPE;", .constantValue.asLong = 0, 0x4019, -1, 7, -1, -1 },
    { "TOKEN", "LADXCLParser_TYPE;", .constantValue.asLong = 0, 0x4019, -1, 8, -1, -1 },
  };
  static const void *ptrTable[] = { "valueOf", "LNSString;", &JreEnum(ADXCLParser_TYPE, UNKNOWN), &JreEnum(ADXCLParser_TYPE, OBJECT), &JreEnum(ADXCLParser_TYPE, ARRAY), &JreEnum(ADXCLParser_TYPE, NUMBER), &JreEnum(ADXCLParser_TYPE, STRING), &JreEnum(ADXCLParser_TYPE, KEY), &JreEnum(ADXCLParser_TYPE, TOKEN), "LADXCLParser;", "Ljava/lang/Enum<Landroidx/constraintlayout/core/parser/CLParser$TYPE;>;" };
  static const J2ObjcClassInfo _ADXCLParser_TYPE = { "TYPE", "androidx.constraintlayout.core.parser", ptrTable, methods, fields, 7, 0x4018, 2, 7, 9, -1, -1, 10, -1 };
  return &_ADXCLParser_TYPE;
}

+ (void)initialize {
  if (self == [ADXCLParser_TYPE class]) {
    size_t objSize = class_getInstanceSize(self);
    size_t allocSize = 7 * objSize;
    uintptr_t ptr = (uintptr_t)calloc(allocSize, 1);
    id e;
    for (jint i = 0; i < 7; i++) {
      ((void)(ADXCLParser_TYPE_values_[i] = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
      ADXCLParser_TYPE_initWithNSString_withInt_(e, JreEnumConstantName(ADXCLParser_TYPE_class_(), i), i);
    }
    J2OBJC_SET_INITIALIZED(ADXCLParser_TYPE)
  }
}

@end

void ADXCLParser_TYPE_initWithNSString_withInt_(ADXCLParser_TYPE *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}

IOSObjectArray *ADXCLParser_TYPE_values() {
  ADXCLParser_TYPE_initialize();
  return [IOSObjectArray arrayWithObjects:ADXCLParser_TYPE_values_ count:7 type:ADXCLParser_TYPE_class_()];
}

ADXCLParser_TYPE *ADXCLParser_TYPE_valueOfWithNSString_(NSString *name) {
  ADXCLParser_TYPE_initialize();
  for (int i = 0; i < 7; i++) {
    ADXCLParser_TYPE *e = ADXCLParser_TYPE_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

ADXCLParser_TYPE *ADXCLParser_TYPE_fromOrdinal(NSUInteger ordinal) {
  ADXCLParser_TYPE_initialize();
  if (ordinal >= 7) {
    return nil;
  }
  return ADXCLParser_TYPE_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXCLParser_TYPE)
