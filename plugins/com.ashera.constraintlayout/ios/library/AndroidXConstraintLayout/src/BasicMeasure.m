//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\widgets\analyzer\BasicMeasure.java
//

#include "BasicMeasure.h"
#include "ConstraintAnchor.h"
#include "ConstraintWidget.h"
#include "ConstraintWidgetContainer.h"
#include "CoreBarrier.h"
#include "CoreGuideline.h"
#include "CoreVirtualLayout.h"
#include "DimensionDependency.h"
#include "Helper.h"
#include "HorizontalWidgetRun.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "LinearSystem.h"
#include "Metrics.h"
#include "Optimizer.h"
#include "VerticalWidgetRun.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"

@class JavaUtilArrayList;


@interface ADXBasicMeasure () {
 @public
  JavaUtilArrayList *mVariableDimensionsWidgets_;
  ADXBasicMeasure_Measure *mMeasure_;
  __unsafe_unretained ADXConstraintWidgetContainer *constraintWidgetContainer_;
}

- (void)measureChildrenWithADXConstraintWidgetContainer:(ADXConstraintWidgetContainer *)layout;

- (void)solveLinearSystemWithADXConstraintWidgetContainer:(ADXConstraintWidgetContainer *)layout
                                             withNSString:(NSString *)reason
                                                  withInt:(jint)pass
                                                  withInt:(jint)w
                                                  withInt:(jint)h;

/*!
 @brief Convenience function to fill in the measure spec
 @param measurer the measurer callback
 @param widget the widget to measure
 @param measureStrategy how to use the current ConstraintWidget dimensions during the measure
 @return true if needs another solver pass
 */
- (jboolean)measureWithADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                        withADXConstraintWidget:(ADXConstraintWidget *)widget
                                        withInt:(jint)measureStrategy;

@end

J2OBJC_FIELD_SETTER(ADXBasicMeasure, mVariableDimensionsWidgets_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADXBasicMeasure, mMeasure_, ADXBasicMeasure_Measure *)

inline jboolean ADXBasicMeasure_get_DEBUG(void);
#define ADXBasicMeasure_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADXBasicMeasure, DEBUG, jboolean)

inline jint ADXBasicMeasure_get_MODE_SHIFT(void);
#define ADXBasicMeasure_MODE_SHIFT 30
J2OBJC_STATIC_FIELD_CONSTANT(ADXBasicMeasure, MODE_SHIFT, jint)

__attribute__((unused)) static void ADXBasicMeasure_measureChildrenWithADXConstraintWidgetContainer_(ADXBasicMeasure *self, ADXConstraintWidgetContainer *layout);

__attribute__((unused)) static void ADXBasicMeasure_solveLinearSystemWithADXConstraintWidgetContainer_withNSString_withInt_withInt_withInt_(ADXBasicMeasure *self, ADXConstraintWidgetContainer *layout, NSString *reason, jint pass, jint w, jint h);

__attribute__((unused)) static jboolean ADXBasicMeasure_measureWithADXBasicMeasure_Measurer_withADXConstraintWidget_withInt_(ADXBasicMeasure *self, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget, jint measureStrategy);

@interface ADXBasicMeasure_Measurer : NSObject

@end

@implementation ADXBasicMeasure

- (void)updateHierarchyWithADXConstraintWidgetContainer:(ADXConstraintWidgetContainer *)layout {
  [((JavaUtilArrayList *) nil_chk(mVariableDimensionsWidgets_)) clear];
  jint childCount = [((JavaUtilArrayList *) nil_chk(((ADXConstraintWidgetContainer *) nil_chk(layout))->mChildren_)) size];
  for (jint i = 0; i < childCount; i++) {
    ADXConstraintWidget *widget = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(layout->mChildren_)) getWithInt:i]);
    if ([((ADXConstraintWidget *) nil_chk(widget)) getHorizontalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) || [widget getVerticalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT)) {
      [mVariableDimensionsWidgets_ addWithId:widget];
    }
  }
  [layout invalidateGraph];
}

- (instancetype)initWithADXConstraintWidgetContainer:(ADXConstraintWidgetContainer *)constraintWidgetContainer {
  ADXBasicMeasure_initWithADXConstraintWidgetContainer_(self, constraintWidgetContainer);
  return self;
}

- (void)measureChildrenWithADXConstraintWidgetContainer:(ADXConstraintWidgetContainer *)layout {
  ADXBasicMeasure_measureChildrenWithADXConstraintWidgetContainer_(self, layout);
}

- (void)solveLinearSystemWithADXConstraintWidgetContainer:(ADXConstraintWidgetContainer *)layout
                                             withNSString:(NSString *)reason
                                                  withInt:(jint)pass
                                                  withInt:(jint)w
                                                  withInt:(jint)h {
  ADXBasicMeasure_solveLinearSystemWithADXConstraintWidgetContainer_withNSString_withInt_withInt_withInt_(self, layout, reason, pass, w, h);
}

- (jlong)solverMeasureWithADXConstraintWidgetContainer:(ADXConstraintWidgetContainer *)layout
                                               withInt:(jint)optimizationLevel
                                               withInt:(jint)paddingX
                                               withInt:(jint)paddingY
                                               withInt:(jint)widthMode
                                               withInt:(jint)widthSize
                                               withInt:(jint)heightMode
                                               withInt:(jint)heightSize
                                               withInt:(jint)lastMeasureWidth
                                               withInt:(jint)lastMeasureHeight {
  id<ADXBasicMeasure_Measurer> measurer = JreRetainedLocalValue([((ADXConstraintWidgetContainer *) nil_chk(layout)) getMeasurer]);
  jlong layoutTime = 0;
  jint childCount = [((JavaUtilArrayList *) nil_chk(layout->mChildren_)) size];
  jint startingWidth = [layout getWidth];
  jint startingHeight = [layout getHeight];
  jboolean optimizeWrap = ADXOptimizer_enabledWithInt_withInt_(optimizationLevel, ADXOptimizer_OPTIMIZATION_GRAPH_WRAP);
  jboolean optimize = optimizeWrap || ADXOptimizer_enabledWithInt_withInt_(optimizationLevel, ADXOptimizer_OPTIMIZATION_GRAPH);
  if (optimize) {
    for (jint i = 0; i < childCount; i++) {
      ADXConstraintWidget *child = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(layout->mChildren_)) getWithInt:i]);
      jboolean matchWidth = [((ADXConstraintWidget *) nil_chk(child)) getHorizontalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT);
      jboolean matchHeight = [child getVerticalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT);
      jboolean ratio = matchWidth && matchHeight && [child getDimensionRatio] > 0;
      if ([child isInHorizontalChain] && (ratio)) {
        optimize = false;
        break;
      }
      if ([child isInVerticalChain] && (ratio)) {
        optimize = false;
        break;
      }
      if ([child isKindOfClass:[ADXCoreVirtualLayout class]]) {
        optimize = false;
        break;
      }
      if ([child isInHorizontalChain] || [child isInVerticalChain]) {
        optimize = false;
        break;
      }
    }
  }
  if (optimize && JreLoadStatic(ADXLinearSystem, sMetrics) != nil) {
    JreLoadStatic(ADXLinearSystem, sMetrics)->measures_++;
  }
  jboolean allSolved = false;
  optimize &= ((widthMode == ADXBasicMeasure_EXACTLY && heightMode == ADXBasicMeasure_EXACTLY) || optimizeWrap);
  jint computations = 0;
  if (optimize) {
    widthSize = JavaLangMath_minWithInt_withInt_([layout getMaxWidth], widthSize);
    heightSize = JavaLangMath_minWithInt_withInt_([layout getMaxHeight], heightSize);
    if (widthMode == ADXBasicMeasure_EXACTLY && [layout getWidth] != widthSize) {
      [layout setWidthWithInt:widthSize];
      [layout invalidateGraph];
    }
    if (heightMode == ADXBasicMeasure_EXACTLY && [layout getHeight] != heightSize) {
      [layout setHeightWithInt:heightSize];
      [layout invalidateGraph];
    }
    if (widthMode == ADXBasicMeasure_EXACTLY && heightMode == ADXBasicMeasure_EXACTLY) {
      allSolved = [layout directMeasureWithBoolean:optimizeWrap];
      computations = 2;
    }
    else {
      allSolved = [layout directMeasureSetupWithBoolean:optimizeWrap];
      if (widthMode == ADXBasicMeasure_EXACTLY) {
        allSolved &= [layout directMeasureWithOrientationWithBoolean:optimizeWrap withInt:ADXConstraintWidget_HORIZONTAL];
        computations++;
      }
      if (heightMode == ADXBasicMeasure_EXACTLY) {
        allSolved &= [layout directMeasureWithOrientationWithBoolean:optimizeWrap withInt:ADXConstraintWidget_VERTICAL];
        computations++;
      }
    }
    if (allSolved) {
      [layout updateFromRunsWithBoolean:widthMode == ADXBasicMeasure_EXACTLY withBoolean:heightMode == ADXBasicMeasure_EXACTLY];
    }
  }
  else {
  }
  if (!allSolved || computations != 2) {
    jint optimizations = [layout getOptimizationLevel];
    if (childCount > 0) {
      ADXBasicMeasure_measureChildrenWithADXConstraintWidgetContainer_(self, layout);
    }
    [self updateHierarchyWithADXConstraintWidgetContainer:layout];
    jint sizeDependentWidgetsCount = [((JavaUtilArrayList *) nil_chk(mVariableDimensionsWidgets_)) size];
    if (childCount > 0) {
      ADXBasicMeasure_solveLinearSystemWithADXConstraintWidgetContainer_withNSString_withInt_withInt_withInt_(self, layout, @"First pass", 0, startingWidth, startingHeight);
    }
    if (sizeDependentWidgetsCount > 0) {
      jboolean needSolverPass = false;
      jboolean containerWrapWidth = [layout getHorizontalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, WRAP_CONTENT);
      jboolean containerWrapHeight = [layout getVerticalDimensionBehaviour] == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, WRAP_CONTENT);
      jint minWidth = JavaLangMath_maxWithInt_withInt_([layout getWidth], [((ADXConstraintWidgetContainer *) nil_chk(constraintWidgetContainer_)) getMinWidth]);
      jint minHeight = JavaLangMath_maxWithInt_withInt_([layout getHeight], [((ADXConstraintWidgetContainer *) nil_chk(constraintWidgetContainer_)) getMinHeight]);
      for (jint i = 0; i < sizeDependentWidgetsCount; i++) {
        ADXConstraintWidget *widget = JreRetainedLocalValue([mVariableDimensionsWidgets_ getWithInt:i]);
        if (!([widget isKindOfClass:[ADXCoreVirtualLayout class]])) {
          continue;
        }
        jint preWidth = [((ADXConstraintWidget *) nil_chk(widget)) getWidth];
        jint preHeight = [widget getHeight];
        needSolverPass |= ADXBasicMeasure_measureWithADXBasicMeasure_Measurer_withADXConstraintWidget_withInt_(self, measurer, widget, JreLoadStatic(ADXBasicMeasure_Measure, TRY_GIVEN_DIMENSIONS));
        if (layout->mMetrics_ != nil) {
          layout->mMetrics_->measuredMatchWidgets_++;
        }
        jint measuredWidth = [widget getWidth];
        jint measuredHeight = [widget getHeight];
        if (measuredWidth != preWidth) {
          [widget setWidthWithInt:measuredWidth];
          if (containerWrapWidth && [widget getRight] > minWidth) {
            jint w = [widget getRight] + [((ADXConstraintAnchor *) nil_chk([widget getAnchorWithADXConstraintAnchor_Type:JreLoadEnum(ADXConstraintAnchor_Type, RIGHT)])) getMargin];
            minWidth = JavaLangMath_maxWithInt_withInt_(minWidth, w);
          }
          needSolverPass = true;
        }
        if (measuredHeight != preHeight) {
          [widget setHeightWithInt:measuredHeight];
          if (containerWrapHeight && [widget getBottom] > minHeight) {
            jint h = [widget getBottom] + [((ADXConstraintAnchor *) nil_chk([widget getAnchorWithADXConstraintAnchor_Type:JreLoadEnum(ADXConstraintAnchor_Type, BOTTOM)])) getMargin];
            minHeight = JavaLangMath_maxWithInt_withInt_(minHeight, h);
          }
          needSolverPass = true;
        }
        ADXCoreVirtualLayout *virtualLayout = (ADXCoreVirtualLayout *) cast_chk(widget, [ADXCoreVirtualLayout class]);
        needSolverPass |= [virtualLayout needSolverPass];
      }
      jint maxIterations = 2;
      for (jint j = 0; j < maxIterations; j++) {
        for (jint i = 0; i < sizeDependentWidgetsCount; i++) {
          ADXConstraintWidget *widget = JreRetainedLocalValue([mVariableDimensionsWidgets_ getWithInt:i]);
          if (([ADXHelper_class_() isInstance:widget] && !([widget isKindOfClass:[ADXCoreVirtualLayout class]])) || [widget isKindOfClass:[ADXCoreGuideline class]]) {
            continue;
          }
          if ([((ADXConstraintWidget *) nil_chk(widget)) getVisibility] == ADXConstraintWidget_GONE) {
            continue;
          }
          if (optimize && ((ADXDimensionDependency *) nil_chk(((ADXHorizontalWidgetRun *) nil_chk(widget->horizontalRun_))->dimension_))->resolved_ && ((ADXVerticalWidgetRun *) nil_chk(widget->verticalRun_))->dimension_->resolved_) {
            continue;
          }
          if ([widget isKindOfClass:[ADXCoreVirtualLayout class]]) {
            continue;
          }
          jint preWidth = [widget getWidth];
          jint preHeight = [widget getHeight];
          jint preBaselineDistance = [widget getBaselineDistance];
          jint measureStrategy = JreLoadStatic(ADXBasicMeasure_Measure, TRY_GIVEN_DIMENSIONS);
          if (j == maxIterations - 1) {
            measureStrategy = JreLoadStatic(ADXBasicMeasure_Measure, USE_GIVEN_DIMENSIONS);
          }
          jboolean hasMeasure = ADXBasicMeasure_measureWithADXBasicMeasure_Measurer_withADXConstraintWidget_withInt_(self, measurer, widget, measureStrategy);
          needSolverPass |= hasMeasure;
          if (layout->mMetrics_ != nil) {
            layout->mMetrics_->measuredMatchWidgets_++;
          }
          jint measuredWidth = [widget getWidth];
          jint measuredHeight = [widget getHeight];
          if (measuredWidth != preWidth) {
            [widget setWidthWithInt:measuredWidth];
            if (containerWrapWidth && [widget getRight] > minWidth) {
              jint w = [widget getRight] + [((ADXConstraintAnchor *) nil_chk([widget getAnchorWithADXConstraintAnchor_Type:JreLoadEnum(ADXConstraintAnchor_Type, RIGHT)])) getMargin];
              minWidth = JavaLangMath_maxWithInt_withInt_(minWidth, w);
            }
            needSolverPass = true;
          }
          if (measuredHeight != preHeight) {
            [widget setHeightWithInt:measuredHeight];
            if (containerWrapHeight && [widget getBottom] > minHeight) {
              jint h = [widget getBottom] + [((ADXConstraintAnchor *) nil_chk([widget getAnchorWithADXConstraintAnchor_Type:JreLoadEnum(ADXConstraintAnchor_Type, BOTTOM)])) getMargin];
              minHeight = JavaLangMath_maxWithInt_withInt_(minHeight, h);
            }
            needSolverPass = true;
          }
          if ([widget hasBaseline] && preBaselineDistance != [widget getBaselineDistance]) {
            needSolverPass = true;
          }
        }
        if (needSolverPass) {
          ADXBasicMeasure_solveLinearSystemWithADXConstraintWidgetContainer_withNSString_withInt_withInt_withInt_(self, layout, @"intermediate pass", 1 + j, startingWidth, startingHeight);
          needSolverPass = false;
        }
        else {
          break;
        }
      }
    }
    [layout setOptimizationLevelWithInt:optimizations];
  }
  return layoutTime;
}

- (jboolean)measureWithADXBasicMeasure_Measurer:(id<ADXBasicMeasure_Measurer>)measurer
                        withADXConstraintWidget:(ADXConstraintWidget *)widget
                                        withInt:(jint)measureStrategy {
  return ADXBasicMeasure_measureWithADXBasicMeasure_Measurer_withADXConstraintWidget_withInt_(self, measurer, widget, measureStrategy);
}

- (void)__javaClone:(ADXBasicMeasure *)original {
  [super __javaClone:original];
  [constraintWidgetContainer_ release];
}

- (void)dealloc {
  RELEASE_(mVariableDimensionsWidgets_);
  RELEASE_(mMeasure_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 2, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 3, 4, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 7, 8, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(updateHierarchyWithADXConstraintWidgetContainer:);
  methods[1].selector = @selector(initWithADXConstraintWidgetContainer:);
  methods[2].selector = @selector(measureChildrenWithADXConstraintWidgetContainer:);
  methods[3].selector = @selector(solveLinearSystemWithADXConstraintWidgetContainer:withNSString:withInt:withInt:withInt:);
  methods[4].selector = @selector(solverMeasureWithADXConstraintWidgetContainer:withInt:withInt:withInt:withInt:withInt:withInt:withInt:withInt:withInt:);
  methods[5].selector = @selector(measureWithADXBasicMeasure_Measurer:withADXConstraintWidget:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEBUG", "Z", .constantValue.asBOOL = ADXBasicMeasure_DEBUG, 0x1a, -1, -1, -1, -1 },
    { "MODE_SHIFT", "I", .constantValue.asInt = ADXBasicMeasure_MODE_SHIFT, 0x1a, -1, -1, -1, -1 },
    { "UNSPECIFIED", "I", .constantValue.asInt = ADXBasicMeasure_UNSPECIFIED, 0x19, -1, -1, -1, -1 },
    { "EXACTLY", "I", .constantValue.asInt = ADXBasicMeasure_EXACTLY, 0x19, -1, -1, -1, -1 },
    { "AT_MOST", "I", .constantValue.asInt = ADXBasicMeasure_AT_MOST, 0x19, -1, -1, -1, -1 },
    { "MATCH_PARENT", "I", .constantValue.asInt = ADXBasicMeasure_MATCH_PARENT, 0x19, -1, -1, -1, -1 },
    { "WRAP_CONTENT", "I", .constantValue.asInt = ADXBasicMeasure_WRAP_CONTENT, 0x19, -1, -1, -1, -1 },
    { "FIXED", "I", .constantValue.asInt = ADXBasicMeasure_FIXED, 0x19, -1, -1, -1, -1 },
    { "mVariableDimensionsWidgets_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x12, -1, -1, 9, -1 },
    { "mMeasure_", "LADXBasicMeasure_Measure;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "constraintWidgetContainer_", "LADXConstraintWidgetContainer;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "updateHierarchy", "LADXConstraintWidgetContainer;", "measureChildren", "solveLinearSystem", "LADXConstraintWidgetContainer;LNSString;III", "solverMeasure", "LADXConstraintWidgetContainer;IIIIIIIII", "measure", "LADXBasicMeasure_Measurer;LADXConstraintWidget;I", "Ljava/util/ArrayList<Landroidx/constraintlayout/core/widgets/ConstraintWidget;>;", "LADXBasicMeasure_Measurer;LADXBasicMeasure_Measure;" };
  static const J2ObjcClassInfo _ADXBasicMeasure = { "BasicMeasure", "androidx.constraintlayout.core.widgets.analyzer", ptrTable, methods, fields, 7, 0x1, 6, 11, -1, 10, -1, -1, -1 };
  return &_ADXBasicMeasure;
}

@end

void ADXBasicMeasure_initWithADXConstraintWidgetContainer_(ADXBasicMeasure *self, ADXConstraintWidgetContainer *constraintWidgetContainer) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->mVariableDimensionsWidgets_, new_JavaUtilArrayList_init());
  JreStrongAssignAndConsume(&self->mMeasure_, new_ADXBasicMeasure_Measure_init());
  self->constraintWidgetContainer_ = constraintWidgetContainer;
}

ADXBasicMeasure *new_ADXBasicMeasure_initWithADXConstraintWidgetContainer_(ADXConstraintWidgetContainer *constraintWidgetContainer) {
  J2OBJC_NEW_IMPL(ADXBasicMeasure, initWithADXConstraintWidgetContainer_, constraintWidgetContainer)
}

ADXBasicMeasure *create_ADXBasicMeasure_initWithADXConstraintWidgetContainer_(ADXConstraintWidgetContainer *constraintWidgetContainer) {
  J2OBJC_CREATE_IMPL(ADXBasicMeasure, initWithADXConstraintWidgetContainer_, constraintWidgetContainer)
}

void ADXBasicMeasure_measureChildrenWithADXConstraintWidgetContainer_(ADXBasicMeasure *self, ADXConstraintWidgetContainer *layout) {
  jint childCount = [((JavaUtilArrayList *) nil_chk(((ADXConstraintWidgetContainer *) nil_chk(layout))->mChildren_)) size];
  jboolean optimize = [layout optimizeForWithInt:ADXOptimizer_OPTIMIZATION_GRAPH];
  id<ADXBasicMeasure_Measurer> measurer = JreRetainedLocalValue([layout getMeasurer]);
  for (jint i = 0; i < childCount; i++) {
    ADXConstraintWidget *child = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(layout->mChildren_)) getWithInt:i]);
    if ([child isKindOfClass:[ADXCoreGuideline class]]) {
      continue;
    }
    if ([child isKindOfClass:[ADXCoreBarrier class]]) {
      continue;
    }
    if ([((ADXConstraintWidget *) nil_chk(child)) isInVirtualLayout]) {
      continue;
    }
    if (optimize && child->horizontalRun_ != nil && child->verticalRun_ != nil && ((ADXDimensionDependency *) nil_chk(child->horizontalRun_->dimension_))->resolved_ && child->verticalRun_->dimension_->resolved_) {
      continue;
    }
    ADXConstraintWidget_DimensionBehaviour *widthBehavior = JreRetainedLocalValue([child getDimensionBehaviourWithInt:ADXConstraintWidget_HORIZONTAL]);
    ADXConstraintWidget_DimensionBehaviour *heightBehavior = JreRetainedLocalValue([child getDimensionBehaviourWithInt:ADXConstraintWidget_VERTICAL]);
    jboolean skip = widthBehavior == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && child->mMatchConstraintDefaultWidth_ != ADXConstraintWidget_MATCH_CONSTRAINT_WRAP && heightBehavior == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && child->mMatchConstraintDefaultHeight_ != ADXConstraintWidget_MATCH_CONSTRAINT_WRAP;
    if (!skip && [layout optimizeForWithInt:ADXOptimizer_OPTIMIZATION_DIRECT] && !([child isKindOfClass:[ADXCoreVirtualLayout class]])) {
      if (widthBehavior == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && child->mMatchConstraintDefaultWidth_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD && heightBehavior != JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && ![child isInHorizontalChain]) {
        skip = true;
      }
      if (heightBehavior == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && child->mMatchConstraintDefaultHeight_ == ADXConstraintWidget_MATCH_CONSTRAINT_SPREAD && widthBehavior != JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) && ![child isInHorizontalChain]) {
        skip = true;
      }
      if ((widthBehavior == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT) || heightBehavior == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT)) && child->mDimensionRatio_ > 0) {
        skip = true;
      }
    }
    if (skip) {
      continue;
    }
    ADXBasicMeasure_measureWithADXBasicMeasure_Measurer_withADXConstraintWidget_withInt_(self, measurer, child, JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS));
    if (layout->mMetrics_ != nil) {
      layout->mMetrics_->measuredWidgets_++;
    }
  }
  [((id<ADXBasicMeasure_Measurer>) nil_chk(measurer)) didMeasures];
}

void ADXBasicMeasure_solveLinearSystemWithADXConstraintWidgetContainer_withNSString_withInt_withInt_withInt_(ADXBasicMeasure *self, ADXConstraintWidgetContainer *layout, NSString *reason, jint pass, jint w, jint h) {
  jlong startLayout;
  jint minWidth = [((ADXConstraintWidgetContainer *) nil_chk(layout)) getMinWidth];
  jint minHeight = [layout getMinHeight];
  [layout setMinWidthWithInt:0];
  [layout setMinHeightWithInt:0];
  [layout setWidthWithInt:w];
  [layout setHeightWithInt:h];
  [layout setMinWidthWithInt:minWidth];
  [layout setMinHeightWithInt:minHeight];
  [((ADXConstraintWidgetContainer *) nil_chk(self->constraintWidgetContainer_)) setPassWithInt:pass];
  [((ADXConstraintWidgetContainer *) nil_chk(self->constraintWidgetContainer_)) layout];
}

jboolean ADXBasicMeasure_measureWithADXBasicMeasure_Measurer_withADXConstraintWidget_withInt_(ADXBasicMeasure *self, id<ADXBasicMeasure_Measurer> measurer, ADXConstraintWidget *widget, jint measureStrategy) {
  JreStrongAssign(&((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->horizontalBehavior_, [((ADXConstraintWidget *) nil_chk(widget)) getHorizontalDimensionBehaviour]);
  JreStrongAssign(&((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->verticalBehavior_, [widget getVerticalDimensionBehaviour]);
  ((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->horizontalDimension_ = [widget getWidth];
  ((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->verticalDimension_ = [widget getHeight];
  ((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->measuredNeedsSolverPass_ = false;
  self->mMeasure_->measureStrategy_ = measureStrategy;
  jboolean horizontalMatchConstraints = self->mMeasure_->horizontalBehavior_ == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT);
  jboolean verticalMatchConstraints = self->mMeasure_->verticalBehavior_ == JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, MATCH_CONSTRAINT);
  jboolean horizontalUseRatio = horizontalMatchConstraints && widget->mDimensionRatio_ > 0;
  jboolean verticalUseRatio = verticalMatchConstraints && widget->mDimensionRatio_ > 0;
  if (horizontalUseRatio) {
    if (IOSIntArray_Get(nil_chk(widget->mResolvedMatchConstraintDefault_), ADXConstraintWidget_HORIZONTAL) == ADXConstraintWidget_MATCH_CONSTRAINT_RATIO_RESOLVED) {
      JreStrongAssign(&self->mMeasure_->horizontalBehavior_, JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, FIXED));
    }
  }
  if (verticalUseRatio) {
    if (IOSIntArray_Get(nil_chk(widget->mResolvedMatchConstraintDefault_), ADXConstraintWidget_VERTICAL) == ADXConstraintWidget_MATCH_CONSTRAINT_RATIO_RESOLVED) {
      JreStrongAssign(&self->mMeasure_->verticalBehavior_, JreLoadEnum(ADXConstraintWidget_DimensionBehaviour, FIXED));
    }
  }
  [((id<ADXBasicMeasure_Measurer>) nil_chk(measurer)) measureWithADXConstraintWidget:widget withADXBasicMeasure_Measure:self->mMeasure_];
  [widget setWidthWithInt:((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->measuredWidth_];
  [widget setHeightWithInt:((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->measuredHeight_];
  [widget setHasBaselineWithBoolean:((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->measuredHasBaseline_];
  [widget setBaselineDistanceWithInt:((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->measuredBaseline_];
  ((ADXBasicMeasure_Measure *) nil_chk(self->mMeasure_))->measureStrategy_ = JreLoadStatic(ADXBasicMeasure_Measure, SELF_DIMENSIONS);
  return self->mMeasure_->measuredNeedsSolverPass_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXBasicMeasure)

@implementation ADXBasicMeasure_Measurer

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x401, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x401, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(measureWithADXConstraintWidget:withADXBasicMeasure_Measure:);
  methods[1].selector = @selector(didMeasures);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "measure", "LADXConstraintWidget;LADXBasicMeasure_Measure;", "LADXBasicMeasure;" };
  static const J2ObjcClassInfo _ADXBasicMeasure_Measurer = { "Measurer", "androidx.constraintlayout.core.widgets.analyzer", ptrTable, methods, NULL, 7, 0x609, 2, 0, 2, -1, -1, -1, -1 };
  return &_ADXBasicMeasure_Measurer;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(ADXBasicMeasure_Measurer)

jint ADXBasicMeasure_Measure_SELF_DIMENSIONS = 0;
jint ADXBasicMeasure_Measure_TRY_GIVEN_DIMENSIONS = 1;
jint ADXBasicMeasure_Measure_USE_GIVEN_DIMENSIONS = 2;

@implementation ADXBasicMeasure_Measure

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXBasicMeasure_Measure_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)dealloc {
  RELEASE_(horizontalBehavior_);
  RELEASE_(verticalBehavior_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "SELF_DIMENSIONS", "I", .constantValue.asLong = 0, 0x9, -1, 0, -1, -1 },
    { "TRY_GIVEN_DIMENSIONS", "I", .constantValue.asLong = 0, 0x9, -1, 1, -1, -1 },
    { "USE_GIVEN_DIMENSIONS", "I", .constantValue.asLong = 0, 0x9, -1, 2, -1, -1 },
    { "horizontalBehavior_", "LADXConstraintWidget_DimensionBehaviour;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "verticalBehavior_", "LADXConstraintWidget_DimensionBehaviour;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "horizontalDimension_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "verticalDimension_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "measuredWidth_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "measuredHeight_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "measuredBaseline_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "measuredHasBaseline_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "measuredNeedsSolverPass_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "measureStrategy_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { &ADXBasicMeasure_Measure_SELF_DIMENSIONS, &ADXBasicMeasure_Measure_TRY_GIVEN_DIMENSIONS, &ADXBasicMeasure_Measure_USE_GIVEN_DIMENSIONS, "LADXBasicMeasure;" };
  static const J2ObjcClassInfo _ADXBasicMeasure_Measure = { "Measure", "androidx.constraintlayout.core.widgets.analyzer", ptrTable, methods, fields, 7, 0x9, 1, 13, 3, -1, -1, -1, -1 };
  return &_ADXBasicMeasure_Measure;
}

@end

void ADXBasicMeasure_Measure_init(ADXBasicMeasure_Measure *self) {
  NSObject_init(self);
}

ADXBasicMeasure_Measure *new_ADXBasicMeasure_Measure_init() {
  J2OBJC_NEW_IMPL(ADXBasicMeasure_Measure, init)
}

ADXBasicMeasure_Measure *create_ADXBasicMeasure_Measure_init() {
  J2OBJC_CREATE_IMPL(ADXBasicMeasure_Measure, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXBasicMeasure_Measure)
