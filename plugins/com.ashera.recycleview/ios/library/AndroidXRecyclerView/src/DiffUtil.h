//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXRecyclerView\src\main\java\androidx\recyclerview\widget\DiffUtil.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_DiffUtil")
#ifdef RESTRICT_DiffUtil
#define INCLUDE_ALL_DiffUtil 0
#else
#define INCLUDE_ALL_DiffUtil 1
#endif
#undef RESTRICT_DiffUtil

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ADXDiffUtil_) && (INCLUDE_ALL_DiffUtil || defined(INCLUDE_ADXDiffUtil))
#define ADXDiffUtil_

@class ADXDiffUtil_Callback;
@class ADXDiffUtil_DiffResult;

/*!
 @brief DiffUtil is a utility class that calculates the difference between two lists and outputs a
  list of update operations that converts the first list into the second one.
 <p>
  It can be used to calculate updates for a RecyclerView Adapter. See <code>ListAdapter</code> and 
 <code>AsyncListDiffer</code> which can simplify the use of DiffUtil on a background thread. 
 <p>
  DiffUtil uses Eugene W. Myers's difference algorithm to calculate the minimal number of updates
  to convert one list into another. Myers's algorithm does not handle items that are moved so
  DiffUtil runs a second pass on the result to detect items that were moved. 
 <p>
  Note that DiffUtil, <code>ListAdapter</code>, and <code>AsyncListDiffer</code> require the list to not
  mutate while in use.
  This generally means that both the lists themselves and their elements (or at least, the
  properties of elements used in diffing) should not be modified directly. Instead, new lists
  should be provided any time content changes. It's common for lists passed to DiffUtil to share
  elements that have not mutated, so it is not strictly required to reload all data to use
  DiffUtil. 
 <p>
  If the lists are large, this operation may take significant time so you are advised to run this
  on a background thread, get the <code>DiffResult</code> then apply it on the RecyclerView on the main
  thread. 
 <p>
  This algorithm is optimized for space and uses O(N) space to find the minimal
  number of addition and removal operations between the two lists. It has O(N + D^2) expected time
  performance where D is the length of the edit script. 
 <p>
  If move detection is enabled, it takes an additional O(MN) time where M is the total number of
  added items and N is the total number of removed items. If your lists are already sorted by
  the same constraint (e.g. a created timestamp for a list of posts), you can disable move
  detection to improve performance. 
 <p>
  The actual runtime of the algorithm significantly depends on the number of changes in the list
  and the cost of your comparison methods. Below are some average run times for reference:
  (The test list is composed of random UUID Strings and the tests are run on Nexus 5X with M) 
 <ul>
      <li>100 items and 10 modifications: avg: 0.39 ms, median: 0.35 ms
      <li>100 items and 100 modifications: 3.82 ms, median: 3.75 ms
      <li>100 items and 100 modifications without moves: 2.09 ms, median: 2.06 ms
      <li>1000 items and 50 modifications: avg: 4.67 ms, median: 4.59 ms
      <li>1000 items and 50 modifications without moves: avg: 3.59 ms, median: 3.50 ms
      <li>1000 items and 200 modifications: 27.07 ms, median: 26.92 ms
      <li>1000 items and 200 modifications without moves: 13.54 ms, median: 13.36 ms 
 </ul>
  <p>
  Due to implementation constraints, the max size of the list can be 2^26.
 - seealso: ListAdapter
 - seealso: AsyncListDiffer
 */
@interface ADXDiffUtil : NSObject

#pragma mark Public

/*!
 @brief Calculates the list of update operations that can covert one list into the other one.
 @param cb The callback that acts as a gateway to the backing list data
 @return A DiffResult that contains the information about the edit sequence to convert the
  old list into the new list.
 */
+ (ADXDiffUtil_DiffResult *)calculateDiffWithADXDiffUtil_Callback:(ADXDiffUtil_Callback *)cb;

/*!
 @brief Calculates the list of update operations that can covert one list into the other one.
 <p>
  If your old and new lists are sorted by the same constraint and items never move (swap
  positions), you can disable move detection which takes <code>O(N^2)</code> time where
  N is the number of added, moved, removed items.
 @param cb The callback that acts as a gateway to the backing list data
 @param detectMoves True if DiffUtil should try to detect moved items, false otherwise.
 @return A DiffResult that contains the information about the edit sequence to convert the
  old list into the new list.
 */
+ (ADXDiffUtil_DiffResult *)calculateDiffWithADXDiffUtil_Callback:(ADXDiffUtil_Callback *)cb
                                                      withBoolean:(jboolean)detectMoves;

@end

J2OBJC_STATIC_INIT(ADXDiffUtil)

FOUNDATION_EXPORT ADXDiffUtil_DiffResult *ADXDiffUtil_calculateDiffWithADXDiffUtil_Callback_(ADXDiffUtil_Callback *cb);

FOUNDATION_EXPORT ADXDiffUtil_DiffResult *ADXDiffUtil_calculateDiffWithADXDiffUtil_Callback_withBoolean_(ADXDiffUtil_Callback *cb, jboolean detectMoves);

J2OBJC_TYPE_LITERAL_HEADER(ADXDiffUtil)

@compatibility_alias AndroidxRecyclerviewWidgetDiffUtil ADXDiffUtil;

#endif

#if !defined (ADXDiffUtil_Callback_) && (INCLUDE_ALL_DiffUtil || defined(INCLUDE_ADXDiffUtil_Callback))
#define ADXDiffUtil_Callback_

/*!
 @brief A Callback class used by DiffUtil while calculating the diff between two lists.
 */
@interface ADXDiffUtil_Callback : NSObject

#pragma mark Public

- (instancetype)init;

/*!
 @brief Called by the DiffUtil when it wants to check whether two items have the same data.
 DiffUtil uses this information to detect if the contents of an item has changed. 
 <p>
  DiffUtil uses this method to check equality instead of <code>Object.equals(Object)</code>
  so that you can change its behavior depending on your UI.
  For example, if you are using DiffUtil with a 
 <code>RecyclerView.Adapter</code>, you should
  return whether the items' visual representations are the same. 
 <p>
  This method is called only if <code>areItemsTheSame(int, int)</code> returns 
 <code>true</code> for these items.
 @param oldItemPosition The position of the item in the old list
 @param newItemPosition The position of the item in the new list which replaces the                         oldItem
 @return True if the contents of the items are the same or false if they are different.
 */
- (jboolean)areContentsTheSameWithInt:(jint)oldItemPosition
                              withInt:(jint)newItemPosition;

/*!
 @brief Called by the DiffUtil to decide whether two object represent the same Item.
 <p>
  For example, if your items have unique ids, this method should check their id equality.
 @param oldItemPosition The position of the item in the old list
 @param newItemPosition The position of the item in the new list
 @return True if the two items represent the same object or false if they are different.
 */
- (jboolean)areItemsTheSameWithInt:(jint)oldItemPosition
                           withInt:(jint)newItemPosition;

/*!
 @brief When <code>areItemsTheSame(int, int)</code> returns <code>true</code> for two items and 
 <code>areContentsTheSame(int, int)</code> returns false for them, DiffUtil
  calls this method to get a payload about the change.
 <p>
  For example, if you are using DiffUtil with <code>RecyclerView</code>, you can return the
  particular field that changed in the item and your 
 <code>ItemAnimator</code> can use that
  information to run the correct animation. 
 <p>
  Default implementation returns <code>null</code>.
 @param oldItemPosition The position of the item in the old list
 @param newItemPosition The position of the item in the new list
 @return A payload object that represents the change between the two items.
 */
- (id)getChangePayloadWithInt:(jint)oldItemPosition
                      withInt:(jint)newItemPosition;

/*!
 @brief Returns the size of the new list.
 @return The size of the new list.
 */
- (jint)getNewListSize;

/*!
 @brief Returns the size of the old list.
 @return The size of the old list.
 */
- (jint)getOldListSize;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXDiffUtil_Callback)

FOUNDATION_EXPORT void ADXDiffUtil_Callback_init(ADXDiffUtil_Callback *self);

J2OBJC_TYPE_LITERAL_HEADER(ADXDiffUtil_Callback)

#endif

#if !defined (ADXDiffUtil_ItemCallback_) && (INCLUDE_ALL_DiffUtil || defined(INCLUDE_ADXDiffUtil_ItemCallback))
#define ADXDiffUtil_ItemCallback_

/*!
 @brief Callback for calculating the diff between two non-null items in a list.
 <p>
  <code>Callback</code> serves two roles - list indexing, and item diffing. ItemCallback handles
  just the second of these, which allows separation of code that indexes into an array or List
  from the presentation-layer and content specific diffing code.
 */
@interface ADXDiffUtil_ItemCallback : NSObject

#pragma mark Public

- (instancetype)init;

/*!
 @brief Called to check whether two items have the same data.
 <p>
  This information is used to detect if the contents of an item have changed. 
 <p>
  This method to check equality instead of <code>Object.equals(Object)</code> so that you can
  change its behavior depending on your UI. 
 <p>
  For example, if you are using DiffUtil with a 
 <code>RecyclerView.Adapter</code>, you should
  return whether the items' visual representations are the same. 
 <p>
  This method is called only if <code>areItemsTheSame(T, T)</code> returns <code>true</code> for
  these items. 
 <p>
  Note: Two <code>null</code> items are assumed to represent the same contents. This callback
  will not be invoked for this case.
 @param oldItem The item in the old list.
 @param newItem The item in the new list.
 @return True if the contents of the items are the same or false if they are different.
 - seealso: Callback#areContentsTheSame(int, int)
 */
- (jboolean)areContentsTheSameWithId:(id)oldItem
                              withId:(id)newItem;

/*!
 @brief Called to check whether two objects represent the same item.
 <p>
  For example, if your items have unique ids, this method should check their id equality. 
 <p>
  Note: <code>null</code> items in the list are assumed to be the same as another <code>null</code>
  item and are assumed to not be the same as a non-<code>null</code> item. This callback will
  not be invoked for either of those cases.
 @param oldItem The item in the old list.
 @param newItem The item in the new list.
 @return True if the two items represent the same object or false if they are different.
 - seealso: Callback#areItemsTheSame(int, int)
 */
- (jboolean)areItemsTheSameWithId:(id)oldItem
                           withId:(id)newItem;

/*!
 @brief When <code>areItemsTheSame(T, T)</code> returns <code>true</code> for two items and 
 <code>areContentsTheSame(T, T)</code> returns false for them, this method is called to
  get a payload about the change.
 <p>
  For example, if you are using DiffUtil with <code>RecyclerView</code>, you can return the
  particular field that changed in the item and your 
 <code>ItemAnimator</code> can use that
  information to run the correct animation. 
 <p>
  Default implementation returns <code>null</code>.
 - seealso: Callback#getChangePayload(int, int)
 */
- (id)getChangePayloadWithId:(id)oldItem
                      withId:(id)newItem;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXDiffUtil_ItemCallback)

FOUNDATION_EXPORT void ADXDiffUtil_ItemCallback_init(ADXDiffUtil_ItemCallback *self);

J2OBJC_TYPE_LITERAL_HEADER(ADXDiffUtil_ItemCallback)

#endif

#if !defined (ADXDiffUtil_Diagonal_) && (INCLUDE_ALL_DiffUtil || defined(INCLUDE_ADXDiffUtil_Diagonal))
#define ADXDiffUtil_Diagonal_

/*!
 @brief A diagonal is a match in the graph.
 Rather than snakes, we only record the diagonals in the path.
 */
@interface ADXDiffUtil_Diagonal : NSObject {
 @public
  jint x_;
  jint y_;
  jint size_;
}

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)x
                    withInt:(jint)y
                    withInt:(jint)size;

- (jint)endX;

- (jint)endY;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXDiffUtil_Diagonal)

FOUNDATION_EXPORT void ADXDiffUtil_Diagonal_initWithInt_withInt_withInt_(ADXDiffUtil_Diagonal *self, jint x, jint y, jint size);

FOUNDATION_EXPORT ADXDiffUtil_Diagonal *new_ADXDiffUtil_Diagonal_initWithInt_withInt_withInt_(jint x, jint y, jint size) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXDiffUtil_Diagonal *create_ADXDiffUtil_Diagonal_initWithInt_withInt_withInt_(jint x, jint y, jint size);

J2OBJC_TYPE_LITERAL_HEADER(ADXDiffUtil_Diagonal)

#endif

#if !defined (ADXDiffUtil_Snake_) && (INCLUDE_ALL_DiffUtil || defined(INCLUDE_ADXDiffUtil_Snake))
#define ADXDiffUtil_Snake_

@class ADXDiffUtil_Diagonal;

/*!
 @brief Snakes represent a match between two lists.It is optionally prefixed or postfixed with an
  add or remove operation.
 See the Myers' paper for details.
 */
@interface ADXDiffUtil_Snake : NSObject {
 @public
  /*!
   @brief Position in the old list
   */
  jint startX_;
  /*!
   @brief Position in the new list
   */
  jint startY_;
  /*!
   @brief End position in the old list, exclusive
   */
  jint endX_;
  /*!
   @brief End position in the new list, exclusive
   */
  jint endY_;
  /*!
   @brief True if this snake was created in the reverse search, false otherwise.
   */
  jboolean reverse_;
}

#pragma mark Package-Private

- (instancetype)init;

- (jint)diagonalSize;

- (jboolean)hasAdditionOrRemoval;

- (jboolean)isAddition;

/*!
 @brief Extract the diagonal of the snake to make reasoning easier for the rest of the
  algorithm where we try to produce a path and also find moves.
 */
- (ADXDiffUtil_Diagonal *)toDiagonal;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXDiffUtil_Snake)

FOUNDATION_EXPORT void ADXDiffUtil_Snake_init(ADXDiffUtil_Snake *self);

FOUNDATION_EXPORT ADXDiffUtil_Snake *new_ADXDiffUtil_Snake_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXDiffUtil_Snake *create_ADXDiffUtil_Snake_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXDiffUtil_Snake)

#endif

#if !defined (ADXDiffUtil_Range_) && (INCLUDE_ALL_DiffUtil || defined(INCLUDE_ADXDiffUtil_Range))
#define ADXDiffUtil_Range_

/*!
 @brief Represents a range in two lists that needs to be solved.
 <p>
  This internal class is used when running Myers' algorithm without recursion. 
 <p>
  Ends are exclusive
 */
@interface ADXDiffUtil_Range : NSObject {
 @public
  jint oldListStart_;
  jint oldListEnd_;
  jint newListStart_;
  jint newListEnd_;
}

#pragma mark Public

- (instancetype)init;

- (instancetype)initWithInt:(jint)oldListStart
                    withInt:(jint)oldListEnd
                    withInt:(jint)newListStart
                    withInt:(jint)newListEnd;

#pragma mark Package-Private

- (jint)newSize OBJC_METHOD_FAMILY_NONE;

- (jint)oldSize;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXDiffUtil_Range)

FOUNDATION_EXPORT void ADXDiffUtil_Range_init(ADXDiffUtil_Range *self);

FOUNDATION_EXPORT ADXDiffUtil_Range *new_ADXDiffUtil_Range_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXDiffUtil_Range *create_ADXDiffUtil_Range_init(void);

FOUNDATION_EXPORT void ADXDiffUtil_Range_initWithInt_withInt_withInt_withInt_(ADXDiffUtil_Range *self, jint oldListStart, jint oldListEnd, jint newListStart, jint newListEnd);

FOUNDATION_EXPORT ADXDiffUtil_Range *new_ADXDiffUtil_Range_initWithInt_withInt_withInt_withInt_(jint oldListStart, jint oldListEnd, jint newListStart, jint newListEnd) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXDiffUtil_Range *create_ADXDiffUtil_Range_initWithInt_withInt_withInt_withInt_(jint oldListStart, jint oldListEnd, jint newListStart, jint newListEnd);

J2OBJC_TYPE_LITERAL_HEADER(ADXDiffUtil_Range)

#endif

#if !defined (ADXDiffUtil_DiffResult_) && (INCLUDE_ALL_DiffUtil || defined(INCLUDE_ADXDiffUtil_DiffResult))
#define ADXDiffUtil_DiffResult_

@class ADXDiffUtil_Callback;
@class ADXRecyclerView_Adapter;
@class IOSIntArray;
@protocol ADXListUpdateCallback;
@protocol JavaUtilList;

/*!
 @brief This class holds the information about the result of a 
 <code>DiffUtil.calculateDiff(Callback, boolean)</code> call.
 <p>
  You can consume the updates in a DiffResult via 
 <code>dispatchUpdatesTo(ListUpdateCallback)</code> or directly stream the results into a 
 <code>RecyclerView.Adapter</code> via <code>dispatchUpdatesTo(RecyclerView.Adapter)</code>.
 */
@interface ADXDiffUtil_DiffResult : NSObject

#pragma mark Public

/*!
 @brief Given a position in the new list, returns the position in the old list, or 
 <code>NO_POSITION</code> if it was removed.
 @param newListPosition Position of item in new list
 @return Position of item in old list, or <code>NO_POSITION</code> if not present.
 - seealso: #NO_POSITION
 - seealso: #convertOldPositionToNew(int)
 */
- (jint)convertNewPositionToOldWithInt:(jint)newListPosition;

/*!
 @brief Given a position in the old list, returns the position in the new list, or 
 <code>NO_POSITION</code> if it was removed.
 @param oldListPosition Position of item in old list
 @return Position of item in new list, or <code>NO_POSITION</code> if not present.
 - seealso: #NO_POSITION
 - seealso: #convertNewPositionToOld(int)
 */
- (jint)convertOldPositionToNewWithInt:(jint)oldListPosition;

/*!
 @brief Dispatches the update events to the given adapter.
 <p>
  For example, if you have an <code>Adapter</code>
  that is backed by a <code>List</code>, you can swap the list with the new one then call this
  method to dispatch all updates to the RecyclerView. 
 @code

      List oldList = mAdapter.getData();
      DiffResult result = DiffUtil.calculateDiff(new MyCallback(oldList, newList));
      mAdapter.setData(newList);
      result.dispatchUpdatesTo(mAdapter); 
  
@endcode
  <p>
  Note that the RecyclerView requires you to dispatch adapter updates immediately when you
  change the data (you cannot defer <code>notify*</code> calls). The usage above adheres to this
  rule because updates are sent to the adapter right after the backing data is changed,
  before RecyclerView tries to read it. 
 <p>
  On the other hand, if you have another 
 <code>AdapterDataObserver</code>
  that tries to process events synchronously, this may confuse that observer because the
  list is instantly moved to its final state while the adapter updates are dispatched later
  on, one by one. If you have such an 
 <code>AdapterDataObserver</code>,
  you can use 
 <code>dispatchUpdatesTo(ListUpdateCallback)</code> to handle each modification
  manually.
 @param adapter A RecyclerView adapter which was displaying the old list and will start                 displaying the new list.
 - seealso: AdapterListUpdateCallback
 */
- (void)dispatchUpdatesToWithADXRecyclerView_Adapter:(ADXRecyclerView_Adapter *)adapter;

/*!
 @brief Dispatches update operations to the given Callback.
 <p>
  These updates are atomic such that the first update call affects every update call that
  comes after it (the same as RecyclerView).
 @param updateCallback The callback to receive the update operations.
 - seealso: #dispatchUpdatesTo(RecyclerView.Adapter)
 */
- (void)dispatchUpdatesToWithADXListUpdateCallback:(id<ADXListUpdateCallback>)updateCallback;

#pragma mark Package-Private

/*!
 @param callback The callback that was used to calculate the diff
 @param diagonals Matches between the two lists
 @param oldItemStatuses An int[] that can be re-purposed to keep metadata
 @param newItemStatuses An int[] that can be re-purposed to keep metadata
 @param detectMoves True if this DiffResult will try to detect moved items
 */
- (instancetype)initWithADXDiffUtil_Callback:(ADXDiffUtil_Callback *)callback
                            withJavaUtilList:(id<JavaUtilList>)diagonals
                                withIntArray:(IOSIntArray *)oldItemStatuses
                                withIntArray:(IOSIntArray *)newItemStatuses
                                 withBoolean:(jboolean)detectMoves;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXDiffUtil_DiffResult)

/*!
 @brief Signifies an item not present in the list.
 */
inline jint ADXDiffUtil_DiffResult_get_NO_POSITION(void);
#define ADXDiffUtil_DiffResult_NO_POSITION -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXDiffUtil_DiffResult, NO_POSITION, jint)

FOUNDATION_EXPORT void ADXDiffUtil_DiffResult_initWithADXDiffUtil_Callback_withJavaUtilList_withIntArray_withIntArray_withBoolean_(ADXDiffUtil_DiffResult *self, ADXDiffUtil_Callback *callback, id<JavaUtilList> diagonals, IOSIntArray *oldItemStatuses, IOSIntArray *newItemStatuses, jboolean detectMoves);

FOUNDATION_EXPORT ADXDiffUtil_DiffResult *new_ADXDiffUtil_DiffResult_initWithADXDiffUtil_Callback_withJavaUtilList_withIntArray_withIntArray_withBoolean_(ADXDiffUtil_Callback *callback, id<JavaUtilList> diagonals, IOSIntArray *oldItemStatuses, IOSIntArray *newItemStatuses, jboolean detectMoves) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXDiffUtil_DiffResult *create_ADXDiffUtil_DiffResult_initWithADXDiffUtil_Callback_withJavaUtilList_withIntArray_withIntArray_withBoolean_(ADXDiffUtil_Callback *callback, id<JavaUtilList> diagonals, IOSIntArray *oldItemStatuses, IOSIntArray *newItemStatuses, jboolean detectMoves);

J2OBJC_TYPE_LITERAL_HEADER(ADXDiffUtil_DiffResult)

#endif

#if !defined (ADXDiffUtil_CenteredArray_) && (INCLUDE_ALL_DiffUtil || defined(INCLUDE_ADXDiffUtil_CenteredArray))
#define ADXDiffUtil_CenteredArray_

@class IOSIntArray;

/*!
 @brief Array wrapper w/ negative index support.
 We use this array instead of a regular array so that algorithm is easier to read without
  too many offsets when accessing the "k" array in the algorithm.
 */
@interface ADXDiffUtil_CenteredArray : NSObject

#pragma mark Public

- (void)fillWithInt:(jint)value;

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)size;

- (IOSIntArray *)backingData;

- (jint)getWithInt:(jint)index;

- (void)setWithInt:(jint)index
           withInt:(jint)value;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXDiffUtil_CenteredArray)

FOUNDATION_EXPORT void ADXDiffUtil_CenteredArray_initWithInt_(ADXDiffUtil_CenteredArray *self, jint size);

FOUNDATION_EXPORT ADXDiffUtil_CenteredArray *new_ADXDiffUtil_CenteredArray_initWithInt_(jint size) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXDiffUtil_CenteredArray *create_ADXDiffUtil_CenteredArray_initWithInt_(jint size);

J2OBJC_TYPE_LITERAL_HEADER(ADXDiffUtil_CenteredArray)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_DiffUtil")
