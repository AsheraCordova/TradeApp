//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\motion\Motion.java
//

#include "CLRect.h"
#include "CurveFit.h"
#include "CustomVariable.h"
#include "DifferentialInterpolator.h"
#include "Easing.h"
#include "FloatRect.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "KeyCache.h"
#include "KeyCycleOscillator.h"
#include "KeyFrameArray.h"
#include "Motion.h"
#include "MotionConstrainedPoint.h"
#include "MotionConstraintSet.h"
#include "MotionKey.h"
#include "MotionKeyAttributes.h"
#include "MotionKeyCycle.h"
#include "MotionKeyPosition.h"
#include "MotionKeyTimeCycle.h"
#include "MotionKeyTrigger.h"
#include "MotionPaths.h"
#include "MotionWidget.h"
#include "SplineSet.h"
#include "TimeCycleSplineSet.h"
#include "Utils.h"
#include "VelocityMatrix.h"
#include "ViewState.h"
#include "java/lang/Float.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/Collections.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Set.h"

@class JavaUtilArrayList;
@class JavaUtilHashMap;


@interface ADXMotion () {
 @public
  jint mCurveFitType_;
  ADXMotionPaths *mStartMotionPath_;
  ADXMotionPaths *mEndMotionPath_;
  ADXMotionConstrainedPoint *mStartPoint_;
  ADXMotionConstrainedPoint *mEndPoint_;
  IOSObjectArray *mSpline_;
  ADXCurveFit *mArcSpline_;
  IOSIntArray *mInterpolateVariables_;
  IOSDoubleArray *mInterpolateData_;
  IOSDoubleArray *mInterpolateVelocity_;
  IOSObjectArray *mAttributeNames_;
  IOSIntArray *mAttributeInterpolatorCount_;
  jint MAX_DIMENSION_;
  IOSFloatArray *mValuesBuff_;
  JavaUtilArrayList *mMotionPaths_;
  IOSFloatArray *mVelocity_;
  JavaUtilArrayList *mKeyList_;
  JavaUtilHashMap *mTimeCycleAttributesMap_;
  JavaUtilHashMap *mAttributesMap_;
  JavaUtilHashMap *mCycleMap_;
  IOSObjectArray *mKeyTriggers_;
  jint mPathMotionArc_;
  jint mTransformPivotTarget_;
  ADXMotionWidget *mTransformPivotView_;
  jint mQuantizeMotionSteps_;
  jfloat mQuantizeMotionPhase_;
  id<ADXDifferentialInterpolator> mQuantizeMotionInterpolator_;
  jboolean mNoMovement_;
}

- (jfloat)getPreCycleDistance;

- (void)insertKeyWithADXMotionPaths:(ADXMotionPaths *)point;

- (void)readViewWithADXMotionPaths:(ADXMotionPaths *)motionPaths;

+ (id<ADXDifferentialInterpolator>)getInterpolatorWithInt:(jint)type
                                             withNSString:(NSString *)interpolatorString
                                                  withInt:(jint)id_;

/*!
 @brief Calculates the adjusted (and optional velocity)
  Note if requesting velocity staggering is not considered
 @param position position pre stagger
 @param velocity return velocity
 @return actual position accounting for easing and staggering
 */
- (jfloat)getAdjustedPositionWithFloat:(jfloat)position
                        withFloatArray:(IOSFloatArray *)velocity;

@end

J2OBJC_FIELD_SETTER(ADXMotion, mStartMotionPath_, ADXMotionPaths *)
J2OBJC_FIELD_SETTER(ADXMotion, mEndMotionPath_, ADXMotionPaths *)
J2OBJC_FIELD_SETTER(ADXMotion, mStartPoint_, ADXMotionConstrainedPoint *)
J2OBJC_FIELD_SETTER(ADXMotion, mEndPoint_, ADXMotionConstrainedPoint *)
J2OBJC_FIELD_SETTER(ADXMotion, mSpline_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ADXMotion, mArcSpline_, ADXCurveFit *)
J2OBJC_FIELD_SETTER(ADXMotion, mInterpolateVariables_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXMotion, mInterpolateData_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(ADXMotion, mInterpolateVelocity_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(ADXMotion, mAttributeNames_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ADXMotion, mAttributeInterpolatorCount_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXMotion, mValuesBuff_, IOSFloatArray *)
J2OBJC_FIELD_SETTER(ADXMotion, mMotionPaths_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADXMotion, mVelocity_, IOSFloatArray *)
J2OBJC_FIELD_SETTER(ADXMotion, mKeyList_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADXMotion, mTimeCycleAttributesMap_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(ADXMotion, mAttributesMap_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(ADXMotion, mCycleMap_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(ADXMotion, mKeyTriggers_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ADXMotion, mTransformPivotView_, ADXMotionWidget *)
J2OBJC_FIELD_SETTER(ADXMotion, mQuantizeMotionInterpolator_, id<ADXDifferentialInterpolator>)

inline NSString *ADXMotion_get_TAG(void);
static NSString *ADXMotion_TAG = @"MotionController";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADXMotion, TAG, NSString *)

inline jboolean ADXMotion_get_DEBUG(void);
#define ADXMotion_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotion, DEBUG, jboolean)

inline jboolean ADXMotion_get_FAVOR_FIXED_SIZE_VIEWS(void);
#define ADXMotion_FAVOR_FIXED_SIZE_VIEWS false
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotion, FAVOR_FIXED_SIZE_VIEWS, jboolean)

inline jint ADXMotion_get_SPLINE_STRING(void);
#define ADXMotion_SPLINE_STRING -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotion, SPLINE_STRING, jint)

inline jint ADXMotion_get_INTERPOLATOR_REFERENCE_ID(void);
#define ADXMotion_INTERPOLATOR_REFERENCE_ID -2
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotion, INTERPOLATOR_REFERENCE_ID, jint)

inline jint ADXMotion_get_INTERPOLATOR_UNDEFINED(void);
#define ADXMotion_INTERPOLATOR_UNDEFINED -3
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotion, INTERPOLATOR_UNDEFINED, jint)

__attribute__((unused)) static jfloat ADXMotion_getPreCycleDistance(ADXMotion *self);

__attribute__((unused)) static void ADXMotion_insertKeyWithADXMotionPaths_(ADXMotion *self, ADXMotionPaths *point);

__attribute__((unused)) static void ADXMotion_readViewWithADXMotionPaths_(ADXMotion *self, ADXMotionPaths *motionPaths);

__attribute__((unused)) static id<ADXDifferentialInterpolator> ADXMotion_getInterpolatorWithInt_withNSString_withInt_(jint type, NSString *interpolatorString, jint id_);

__attribute__((unused)) static jfloat ADXMotion_getAdjustedPositionWithFloat_withFloatArray_(ADXMotion *self, jfloat position, IOSFloatArray *velocity);

@interface ADXMotion_1 : NSObject < ADXDifferentialInterpolator > {
 @public
  ADXEasing *val$easing_;
  jfloat mX_;
}

- (instancetype)initWithADXEasing:(ADXEasing *)capture$0;

- (jfloat)getInterpolationWithFloat:(jfloat)x;

- (jfloat)getVelocity;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXMotion_1)

__attribute__((unused)) static void ADXMotion_1_initWithADXEasing_(ADXMotion_1 *self, ADXEasing *capture$0);

__attribute__((unused)) static ADXMotion_1 *new_ADXMotion_1_initWithADXEasing_(ADXEasing *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADXMotion_1 *create_ADXMotion_1_initWithADXEasing_(ADXEasing *capture$0);

@implementation ADXMotion

- (jint)getTransformPivotTarget {
  return mTransformPivotTarget_;
}

- (void)setTransformPivotTargetWithInt:(jint)transformPivotTarget {
  mTransformPivotTarget_ = transformPivotTarget;
  JreStrongAssign(&mTransformPivotView_, nil);
}

- (ADXMotionPaths *)getKeyFrameWithInt:(jint)i {
  return [((JavaUtilArrayList *) nil_chk(mMotionPaths_)) getWithInt:i];
}

- (instancetype)initWithADXMotionWidget:(ADXMotionWidget *)view {
  ADXMotion_initWithADXMotionWidget_(self, view);
  return self;
}

- (jfloat)getStartX {
  return ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->x_;
}

- (jfloat)getStartY {
  return ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->y_;
}

- (jfloat)getFinalX {
  return ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->x_;
}

- (jfloat)getFinalY {
  return ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->y_;
}

- (jfloat)getStartWidth {
  return ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->width_;
}

- (jfloat)getStartHeight {
  return ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->height_;
}

- (jfloat)getFinalWidth {
  return ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->width_;
}

- (jfloat)getFinalHeight {
  return ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->height_;
}

- (jint)getAnimateRelativeTo {
  return ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->mAnimateRelativeTo_;
}

- (void)setupRelativeWithADXMotion:(ADXMotion *)motionController {
  [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) setupRelativeWithADXMotion:motionController withADXMotionPaths:((ADXMotion *) nil_chk(motionController))->mStartMotionPath_];
  [((ADXMotionPaths *) nil_chk(mEndMotionPath_)) setupRelativeWithADXMotion:motionController withADXMotionPaths:motionController->mEndMotionPath_];
}

- (jfloat)getCenterX {
  return mCurrentCenterX_;
}

- (jfloat)getCenterY {
  return mCurrentCenterY_;
}

- (void)getCenterWithDouble:(jdouble)p
             withFloatArray:(IOSFloatArray *)pos
             withFloatArray:(IOSFloatArray *)vel {
  IOSDoubleArray *position = [IOSDoubleArray arrayWithLength:4];
  IOSDoubleArray *velocity = [IOSDoubleArray arrayWithLength:4];
  IOSIntArray *temp = [IOSIntArray arrayWithLength:4];
  [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:p withDoubleArray:position];
  [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getSlopeWithDouble:p withDoubleArray:velocity];
  JavaUtilArrays_fillWithFloatArray_withFloat_(vel, 0);
  [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:p withIntArray:mInterpolateVariables_ withDoubleArray:position withFloatArray:pos withDoubleArray:velocity withFloatArray:vel];
}

- (void)buildPathWithFloatArray:(IOSFloatArray *)points
                        withInt:(jint)pointCount {
  jfloat mils = 1.0f / (pointCount - 1);
  ADXSplineSet *trans_x = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXMotionKey_TRANSLATION_X];
  ADXSplineSet *trans_y = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXMotionKey_TRANSLATION_Y];
  ADXKeyCycleOscillator *osc_x = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXMotionKey_TRANSLATION_X];
  ADXKeyCycleOscillator *osc_y = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXMotionKey_TRANSLATION_Y];
  for (jint i = 0; i < pointCount; i++) {
    jfloat position = (i) * mils;
    if (mStaggerScale_ != 1.0f) {
      if (position < mStaggerOffset_) {
        position = 0;
      }
      if (position > mStaggerOffset_ && position < 1.0) {
        JreMinusAssignFloatF(&position, mStaggerOffset_);
        JreTimesAssignFloatF(&position, mStaggerScale_);
        position = JavaLangMath_minWithFloat_withFloat_(position, 1.0f);
      }
    }
    jdouble p = position;
    ADXEasing *easing = JreRetainedLocalValue(((ADXMotionPaths *) nil_chk(mStartMotionPath_))->mKeyFrameEasing_);
    jfloat start = 0;
    jfloat end = JavaLangFloat_NaN;
    for (ADXMotionPaths * __strong frame in nil_chk(mMotionPaths_)) {
      if (((ADXMotionPaths *) nil_chk(frame))->mKeyFrameEasing_ != nil) {
        if (frame->time_ < position) {
          easing = frame->mKeyFrameEasing_;
          start = frame->time_;
        }
        else {
          if (JavaLangFloat_isNaNWithFloat_(end)) {
            end = frame->time_;
          }
        }
      }
    }
    if (easing != nil) {
      if (JavaLangFloat_isNaNWithFloat_(end)) {
        end = 1.0f;
      }
      jfloat offset = (position - start) / (end - start);
      offset = (jfloat) [easing getWithDouble:offset];
      p = offset * (end - start) + start;
    }
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:p withDoubleArray:mInterpolateData_];
    if (mArcSpline_ != nil) {
      if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
        [mArcSpline_ getPosWithDouble:p withDoubleArray:mInterpolateData_];
      }
    }
    [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:p withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:points withInt:i * 2];
    if (osc_x != nil) {
      JrePlusAssignFloatF(IOSFloatArray_GetRef(nil_chk(points), i * 2), [osc_x getWithFloat:position]);
    }
    else if (trans_x != nil) {
      JrePlusAssignFloatF(IOSFloatArray_GetRef(nil_chk(points), i * 2), [trans_x getWithFloat:position]);
    }
    if (osc_y != nil) {
      JrePlusAssignFloatF(IOSFloatArray_GetRef(nil_chk(points), i * 2 + 1), [osc_y getWithFloat:position]);
    }
    else if (trans_y != nil) {
      JrePlusAssignFloatF(IOSFloatArray_GetRef(nil_chk(points), i * 2 + 1), [trans_y getWithFloat:position]);
    }
  }
}

- (IOSDoubleArray *)getPosWithDouble:(jdouble)position {
  [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
  if (mArcSpline_ != nil) {
    if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
      [mArcSpline_ getPosWithDouble:position withDoubleArray:mInterpolateData_];
    }
  }
  return mInterpolateData_;
}

- (void)buildBoundsWithFloatArray:(IOSFloatArray *)bounds
                          withInt:(jint)pointCount {
  jfloat mils = 1.0f / (pointCount - 1);
  ADXSplineSet *trans_x = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXMotionKey_TRANSLATION_X];
  ADXSplineSet *trans_y = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXMotionKey_TRANSLATION_Y];
  ADXKeyCycleOscillator *osc_x = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXMotionKey_TRANSLATION_X];
  ADXKeyCycleOscillator *osc_y = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXMotionKey_TRANSLATION_Y];
  for (jint i = 0; i < pointCount; i++) {
    jfloat position = (i) * mils;
    if (mStaggerScale_ != 1.0f) {
      if (position < mStaggerOffset_) {
        position = 0;
      }
      if (position > mStaggerOffset_ && position < 1.0) {
        JreMinusAssignFloatF(&position, mStaggerOffset_);
        JreTimesAssignFloatF(&position, mStaggerScale_);
        position = JavaLangMath_minWithFloat_withFloat_(position, 1.0f);
      }
    }
    jdouble p = position;
    ADXEasing *easing = JreRetainedLocalValue(((ADXMotionPaths *) nil_chk(mStartMotionPath_))->mKeyFrameEasing_);
    jfloat start = 0;
    jfloat end = JavaLangFloat_NaN;
    for (ADXMotionPaths * __strong frame in nil_chk(mMotionPaths_)) {
      if (((ADXMotionPaths *) nil_chk(frame))->mKeyFrameEasing_ != nil) {
        if (frame->time_ < position) {
          easing = frame->mKeyFrameEasing_;
          start = frame->time_;
        }
        else {
          if (JavaLangFloat_isNaNWithFloat_(end)) {
            end = frame->time_;
          }
        }
      }
    }
    if (easing != nil) {
      if (JavaLangFloat_isNaNWithFloat_(end)) {
        end = 1.0f;
      }
      jfloat offset = (position - start) / (end - start);
      offset = (jfloat) [easing getWithDouble:offset];
      p = offset * (end - start) + start;
    }
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:p withDoubleArray:mInterpolateData_];
    if (mArcSpline_ != nil) {
      if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
        [mArcSpline_ getPosWithDouble:p withDoubleArray:mInterpolateData_];
      }
    }
    [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) getBoundsWithIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:bounds withInt:i * 2];
  }
}

- (jfloat)getPreCycleDistance {
  return ADXMotion_getPreCycleDistance(self);
}

- (ADXMotionKeyPosition *)getPositionKeyframeWithInt:(jint)layoutWidth
                                             withInt:(jint)layoutHeight
                                           withFloat:(jfloat)x
                                           withFloat:(jfloat)y {
  ADXFloatRect *start = create_ADXFloatRect_init();
  start->left_ = ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->x_;
  start->top_ = mStartMotionPath_->y_;
  start->right_ = start->left_ + mStartMotionPath_->width_;
  start->bottom_ = start->top_ + mStartMotionPath_->height_;
  ADXFloatRect *end = create_ADXFloatRect_init();
  end->left_ = ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->x_;
  end->top_ = mEndMotionPath_->y_;
  end->right_ = end->left_ + mEndMotionPath_->width_;
  end->bottom_ = end->top_ + mEndMotionPath_->height_;
  for (ADXMotionKey * __strong key in nil_chk(mKeyList_)) {
    if ([key isKindOfClass:[ADXMotionKeyPosition class]]) {
      if ([((ADXMotionKeyPosition *) nil_chk(((ADXMotionKeyPosition *) key))) intersectsWithInt:layoutWidth withInt:layoutHeight withADXFloatRect:start withADXFloatRect:end withFloat:x withFloat:y]) {
        return (ADXMotionKeyPosition *) key;
      }
    }
  }
  return nil;
}

- (jint)buildKeyFramesWithFloatArray:(IOSFloatArray *)keyFrames
                        withIntArray:(IOSIntArray *)mode
                        withIntArray:(IOSIntArray *)pos {
  if (keyFrames != nil) {
    jint count = 0;
    IOSDoubleArray *time = [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getTimePoints];
    if (mode != nil) {
      for (ADXMotionPaths * __strong keyFrame in nil_chk(mMotionPaths_)) {
        *IOSIntArray_GetRef(mode, count++) = ((ADXMotionPaths *) nil_chk(keyFrame))->mMode_;
      }
      count = 0;
    }
    if (pos != nil) {
      for (ADXMotionPaths * __strong keyFrame in nil_chk(mMotionPaths_)) {
        *IOSIntArray_GetRef(pos, count++) = JreFpToInt((100 * ((ADXMotionPaths *) nil_chk(keyFrame))->position_));
      }
      count = 0;
    }
    for (jint i = 0; i < ((IOSDoubleArray *) nil_chk(time))->size_; i++) {
      [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:IOSDoubleArray_Get(time, i) withDoubleArray:mInterpolateData_];
      [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:IOSDoubleArray_Get(time, i) withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:keyFrames withInt:count];
      count += 2;
    }
    return JreIntDiv(count, 2);
  }
  return 0;
}

- (jint)buildKeyBoundsWithFloatArray:(IOSFloatArray *)keyBounds
                        withIntArray:(IOSIntArray *)mode {
  if (keyBounds != nil) {
    jint count = 0;
    IOSDoubleArray *time = [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getTimePoints];
    if (mode != nil) {
      for (ADXMotionPaths * __strong keyFrame in nil_chk(mMotionPaths_)) {
        *IOSIntArray_GetRef(mode, count++) = ((ADXMotionPaths *) nil_chk(keyFrame))->mMode_;
      }
      count = 0;
    }
    for (jint i = 0; i < ((IOSDoubleArray *) nil_chk(time))->size_; i++) {
      [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:IOSDoubleArray_Get(time, i) withDoubleArray:mInterpolateData_];
      [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) getBoundsWithIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:keyBounds withInt:count];
      count += 2;
    }
    return JreIntDiv(count, 2);
  }
  return 0;
}

- (jint)getAttributeValuesWithNSString:(NSString *)attributeType
                        withFloatArray:(IOSFloatArray *)points
                               withInt:(jint)pointCount {
  jfloat mils = 1.0f / (pointCount - 1);
  ADXSplineSet *spline = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:attributeType]);
  if (spline == nil) {
    return -1;
  }
  for (jint j = 0; j < ((IOSFloatArray *) nil_chk(points))->size_; j++) {
    *IOSFloatArray_GetRef(points, j) = [spline getWithFloat:JreIntDiv(j, (points->size_ - 1))];
  }
  return points->size_;
}

- (void)buildRectWithFloat:(jfloat)p
            withFloatArray:(IOSFloatArray *)path
                   withInt:(jint)offset {
  p = ADXMotion_getAdjustedPositionWithFloat_withFloatArray_(self, p, nil);
  [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:p withDoubleArray:mInterpolateData_];
  [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) getRectWithIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:path withInt:offset];
}

- (void)buildRectanglesWithFloatArray:(IOSFloatArray *)path
                              withInt:(jint)pointCount {
  jfloat mils = 1.0f / (pointCount - 1);
  for (jint i = 0; i < pointCount; i++) {
    jfloat position = (i) * mils;
    position = ADXMotion_getAdjustedPositionWithFloat_withFloatArray_(self, position, nil);
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
    [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) getRectWithIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:path withInt:i * 8];
  }
}

- (jfloat)getKeyFrameParameterWithInt:(jint)type
                            withFloat:(jfloat)x
                            withFloat:(jfloat)y {
  jfloat dx = ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->x_ - ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->x_;
  jfloat dy = mEndMotionPath_->y_ - mStartMotionPath_->y_;
  jfloat startCenterX = mStartMotionPath_->x_ + mStartMotionPath_->width_ / 2;
  jfloat startCenterY = mStartMotionPath_->y_ + mStartMotionPath_->height_ / 2;
  jfloat hypotenuse = (jfloat) JavaLangMath_hypotWithDouble_withDouble_(dx, dy);
  if (hypotenuse < 0.0000001) {
    return JavaLangFloat_NaN;
  }
  jfloat vx = x - startCenterX;
  jfloat vy = y - startCenterY;
  jfloat distFromStart = (jfloat) JavaLangMath_hypotWithDouble_withDouble_(vx, vy);
  if (distFromStart == 0) {
    return 0;
  }
  jfloat pathDistance = (vx * dx + vy * dy);
  switch (type) {
    case ADXMotion_PATH_PERCENT:
    return pathDistance / hypotenuse;
    case ADXMotion_PATH_PERPENDICULAR:
    return (jfloat) JavaLangMath_sqrtWithDouble_(hypotenuse * hypotenuse - pathDistance * pathDistance);
    case ADXMotion_HORIZONTAL_PATH_X:
    return vx / dx;
    case ADXMotion_HORIZONTAL_PATH_Y:
    return vy / dx;
    case ADXMotion_VERTICAL_PATH_X:
    return vx / dy;
    case ADXMotion_VERTICAL_PATH_Y:
    return vy / dy;
  }
  return 0;
}

- (void)insertKeyWithADXMotionPaths:(ADXMotionPaths *)point {
  ADXMotion_insertKeyWithADXMotionPaths_(self, point);
}

- (void)addKeysWithJavaUtilArrayList:(JavaUtilArrayList *)list {
  [((JavaUtilArrayList *) nil_chk(mKeyList_)) addAllWithJavaUtilCollection:list];
}

- (void)addKeyWithADXMotionKey:(ADXMotionKey *)key {
  [((JavaUtilArrayList *) nil_chk(mKeyList_)) addWithId:key];
}

- (void)setPathMotionArcWithInt:(jint)arc {
  mPathMotionArc_ = arc;
}

- (void)setupWithInt:(jint)parentWidth
             withInt:(jint)parentHeight
           withFloat:(jfloat)transitionDuration
            withLong:(jlong)currentTime {
  JavaUtilHashSet *springAttributes = create_JavaUtilHashSet_init();
  JavaUtilHashSet *timeCycleAttributes = create_JavaUtilHashSet_init();
  JavaUtilHashSet *splineAttributes = create_JavaUtilHashSet_init();
  JavaUtilHashSet *cycleAttributes = create_JavaUtilHashSet_init();
  JavaUtilHashMap *interpolation = create_JavaUtilHashMap_init();
  JavaUtilArrayList *triggerList = nil;
  if (mPathMotionArc_ != ADXMotionWidget_UNSET) {
    ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->mPathMotionArc_ = mPathMotionArc_;
  }
  [((ADXMotionConstrainedPoint *) nil_chk(mStartPoint_)) differentWithADXMotionConstrainedPoint:mEndPoint_ withJavaUtilHashSet:splineAttributes];
  if (mKeyList_ != nil) {
    for (ADXMotionKey * __strong key in mKeyList_) {
      if ([key isKindOfClass:[ADXMotionKeyPosition class]]) {
        ADXMotionKeyPosition *keyPath = (ADXMotionKeyPosition *) key;
        ADXMotion_insertKeyWithADXMotionPaths_(self, create_ADXMotionPaths_initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_(parentWidth, parentHeight, keyPath, mStartMotionPath_, mEndMotionPath_));
        if (((ADXMotionKeyPosition *) nil_chk(keyPath))->mCurveFit_ != ADXMotionWidget_UNSET) {
          mCurveFitType_ = keyPath->mCurveFit_;
        }
      }
      else if ([key isKindOfClass:[ADXMotionKeyCycle class]]) {
        [((ADXMotionKey *) nil_chk(key)) getAttributeNamesWithJavaUtilHashSet:cycleAttributes];
      }
      else if ([key isKindOfClass:[ADXMotionKeyTimeCycle class]]) {
        [((ADXMotionKey *) nil_chk(key)) getAttributeNamesWithJavaUtilHashSet:timeCycleAttributes];
      }
      else if ([key isKindOfClass:[ADXMotionKeyTrigger class]]) {
        if (triggerList == nil) {
          triggerList = create_JavaUtilArrayList_init();
        }
        [triggerList addWithId:(ADXMotionKeyTrigger *) key];
      }
      else {
        [((ADXMotionKey *) nil_chk(key)) setInterpolationWithJavaUtilHashMap:interpolation];
        [key getAttributeNamesWithJavaUtilHashSet:splineAttributes];
      }
    }
  }
  if (triggerList != nil) {
    JreStrongAssign(&mKeyTriggers_, [triggerList toArrayWithNSObjectArray:[IOSObjectArray arrayWithLength:0 type:ADXMotionKeyTrigger_class_()]]);
  }
  if (![splineAttributes isEmpty]) {
    JreStrongAssignAndConsume(&mAttributesMap_, new_JavaUtilHashMap_init());
    for (NSString * __strong attribute in splineAttributes) {
      ADXSplineSet *splineSets;
      if ([((NSString *) nil_chk(attribute)) java_hasPrefix:@"CUSTOM,"]) {
        ADXKeyFrameArray_CustomVar *attrList = create_ADXKeyFrameArray_CustomVar_init();
        NSString *customAttributeName = IOSObjectArray_Get(nil_chk([attribute java_split:@","]), 1);
        for (ADXMotionKey * __strong key in nil_chk(mKeyList_)) {
          if (((ADXMotionKey *) nil_chk(key))->mCustom_ == nil) {
            continue;
          }
          ADXCustomVariable *customAttribute = JreRetainedLocalValue([key->mCustom_ getWithId:customAttributeName]);
          if (customAttribute != nil) {
            [attrList appendWithInt:key->mFramePosition_ withADXCustomVariable:customAttribute];
          }
        }
        splineSets = ADXSplineSet_makeCustomSplineSetWithNSString_withADXKeyFrameArray_CustomVar_(attribute, attrList);
      }
      else {
        splineSets = ADXSplineSet_makeSplineWithNSString_withLong_(attribute, currentTime);
      }
      if (splineSets == nil) {
        continue;
      }
      [splineSets setTypeWithNSString:attribute];
      [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) putWithId:attribute withId:splineSets];
    }
    if (mKeyList_ != nil) {
      for (ADXMotionKey * __strong key in mKeyList_) {
        if (([key isKindOfClass:[ADXMotionKeyAttributes class]])) {
          [((ADXMotionKey *) nil_chk(key)) addValuesWithJavaUtilHashMap:mAttributesMap_];
        }
      }
    }
    [((ADXMotionConstrainedPoint *) nil_chk(mStartPoint_)) addValuesWithJavaUtilHashMap:mAttributesMap_ withInt:0];
    [((ADXMotionConstrainedPoint *) nil_chk(mEndPoint_)) addValuesWithJavaUtilHashMap:mAttributesMap_ withInt:100];
    for (NSString * __strong spline in nil_chk([((JavaUtilHashMap *) nil_chk(mAttributesMap_)) keySet])) {
      jint curve = ADXCurveFit_SPLINE;
      if ([interpolation containsKeyWithId:spline]) {
        JavaLangInteger *boxedCurve = JreRetainedLocalValue([interpolation getWithId:spline]);
        if (boxedCurve != nil) {
          curve = [boxedCurve intValue];
        }
      }
      ADXSplineSet *splineSet = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:spline]);
      if (splineSet != nil) {
        [splineSet setupWithInt:curve];
      }
    }
  }
  if (![timeCycleAttributes isEmpty]) {
    if (mTimeCycleAttributesMap_ == nil) {
      JreStrongAssignAndConsume(&mTimeCycleAttributesMap_, new_JavaUtilHashMap_init());
    }
    for (NSString * __strong attribute in timeCycleAttributes) {
      if ([((JavaUtilHashMap *) nil_chk(mTimeCycleAttributesMap_)) containsKeyWithId:attribute]) {
        continue;
      }
      ADXSplineSet *splineSets = nil;
      if ([((NSString *) nil_chk(attribute)) java_hasPrefix:@"CUSTOM,"]) {
        ADXKeyFrameArray_CustomVar *attrList = create_ADXKeyFrameArray_CustomVar_init();
        NSString *customAttributeName = IOSObjectArray_Get(nil_chk([attribute java_split:@","]), 1);
        for (ADXMotionKey * __strong key in nil_chk(mKeyList_)) {
          if (((ADXMotionKey *) nil_chk(key))->mCustom_ == nil) {
            continue;
          }
          ADXCustomVariable *customAttribute = JreRetainedLocalValue([key->mCustom_ getWithId:customAttributeName]);
          if (customAttribute != nil) {
            [attrList appendWithInt:key->mFramePosition_ withADXCustomVariable:customAttribute];
          }
        }
        splineSets = ADXSplineSet_makeCustomSplineSetWithNSString_withADXKeyFrameArray_CustomVar_(attribute, attrList);
      }
      else {
        splineSets = ADXSplineSet_makeSplineWithNSString_withLong_(attribute, currentTime);
      }
      if (splineSets == nil) {
        continue;
      }
      [splineSets setTypeWithNSString:attribute];
    }
    if (mKeyList_ != nil) {
      for (ADXMotionKey * __strong key in mKeyList_) {
        if ([key isKindOfClass:[ADXMotionKeyTimeCycle class]]) {
          [((ADXMotionKeyTimeCycle *) nil_chk(((ADXMotionKeyTimeCycle *) key))) addTimeValuesWithJavaUtilHashMap:mTimeCycleAttributesMap_];
        }
      }
    }
    for (NSString * __strong spline in nil_chk([mTimeCycleAttributesMap_ keySet])) {
      jint curve = ADXCurveFit_SPLINE;
      if ([interpolation containsKeyWithId:spline]) {
        curve = [((JavaLangInteger *) nil_chk([interpolation getWithId:spline])) intValue];
      }
      [((ADXTimeCycleSplineSet *) nil_chk([((JavaUtilHashMap *) nil_chk(mTimeCycleAttributesMap_)) getWithId:spline])) setupWithInt:curve];
    }
  }
  IOSObjectArray *points = [IOSObjectArray arrayWithLength:2 + [((JavaUtilArrayList *) nil_chk(mMotionPaths_)) size] type:ADXMotionPaths_class_()];
  jint count = 1;
  IOSObjectArray_Set(points, 0, mStartMotionPath_);
  IOSObjectArray_Set(points, points->size_ - 1, mEndMotionPath_);
  if ([((JavaUtilArrayList *) nil_chk(mMotionPaths_)) size] > 0 && mCurveFitType_ == JreLoadStatic(ADXMotionKey, UNSET)) {
    mCurveFitType_ = ADXCurveFit_SPLINE;
  }
  for (ADXMotionPaths * __strong point in nil_chk(mMotionPaths_)) {
    IOSObjectArray_Set(points, count++, point);
  }
  jint variables = 18;
  JavaUtilHashSet *attributeNameSet = create_JavaUtilHashSet_init();
  for (NSString * __strong s in nil_chk([((JavaUtilHashMap *) nil_chk(((ADXMotionPaths *) nil_chk(mEndMotionPath_))->customAttributes_)) keySet])) {
    if ([((JavaUtilHashMap *) nil_chk(((ADXMotionPaths *) nil_chk(mStartMotionPath_))->customAttributes_)) containsKeyWithId:s]) {
      if (![splineAttributes containsWithId:JreStrcat("$$", @"CUSTOM,", s)]) [attributeNameSet addWithId:s];
    }
  }
  JreStrongAssign(&mAttributeNames_, [attributeNameSet toArrayWithNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]]);
  JreStrongAssignAndConsume(&mAttributeInterpolatorCount_, [IOSIntArray newArrayWithLength:((IOSObjectArray *) nil_chk(mAttributeNames_))->size_]);
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(mAttributeNames_))->size_; i++) {
    NSString *attributeName = IOSObjectArray_Get(mAttributeNames_, i);
    *IOSIntArray_GetRef(nil_chk(mAttributeInterpolatorCount_), i) = 0;
    for (jint j = 0; j < points->size_; j++) {
      if ([((JavaUtilHashMap *) nil_chk(((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, j)))->customAttributes_)) containsKeyWithId:attributeName]) {
        ADXCustomVariable *attribute = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, j)))->customAttributes_)) getWithId:attributeName]);
        if (attribute != nil) {
          *IOSIntArray_GetRef(nil_chk(mAttributeInterpolatorCount_), i) += [attribute numberOfInterpolatedValues];
          break;
        }
      }
    }
  }
  jboolean arcMode = ((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, 0)))->mPathMotionArc_ != ADXMotionWidget_UNSET;
  IOSBooleanArray *mask = [IOSBooleanArray arrayWithLength:variables + mAttributeNames_->size_];
  for (jint i = 1; i < points->size_; i++) {
    [((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, i))) differentWithADXMotionPaths:IOSObjectArray_Get(points, i - 1) withBooleanArray:mask withNSStringArray:mAttributeNames_ withBoolean:arcMode];
  }
  count = 0;
  for (jint i = 1; i < mask->size_; i++) {
    if (IOSBooleanArray_Get(mask, i)) {
      count++;
    }
  }
  JreStrongAssignAndConsume(&mInterpolateVariables_, [IOSIntArray newArrayWithLength:count]);
  jint varLen = JavaLangMath_maxWithInt_withInt_(2, count);
  JreStrongAssignAndConsume(&mInterpolateData_, [IOSDoubleArray newArrayWithLength:varLen]);
  JreStrongAssignAndConsume(&mInterpolateVelocity_, [IOSDoubleArray newArrayWithLength:varLen]);
  count = 0;
  for (jint i = 1; i < mask->size_; i++) {
    if (IOSBooleanArray_Get(mask, i)) *IOSIntArray_GetRef(nil_chk(mInterpolateVariables_), count++) = i;
  }
  IOSObjectArray *splineData = [IOSDoubleArray arrayWithDimensions:2 lengths:(jint[]){ points->size_, ((IOSIntArray *) nil_chk(mInterpolateVariables_))->size_ }];
  IOSDoubleArray *timePoint = [IOSDoubleArray arrayWithLength:points->size_];
  for (jint i = 0; i < points->size_; i++) {
    [((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, i))) fillStandardWithDoubleArray:IOSObjectArray_Get(splineData, i) withIntArray:mInterpolateVariables_];
    *IOSDoubleArray_GetRef(timePoint, i) = ((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->time_;
  }
  for (jint j = 0; j < ((IOSIntArray *) nil_chk(mInterpolateVariables_))->size_; j++) {
    jint interpolateVariable = IOSIntArray_Get(mInterpolateVariables_, j);
    if (interpolateVariable < ((IOSObjectArray *) nil_chk(JreLoadStatic(ADXMotionPaths, names)))->size_) {
      NSString *s = JreStrcat("$$", IOSObjectArray_Get(JreLoadStatic(ADXMotionPaths, names), IOSIntArray_Get(mInterpolateVariables_, j)), @" [");
      for (jint i = 0; i < points->size_; i++) {
        JreStrAppend(&s, "D", IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(splineData, i)), j));
      }
    }
  }
  JreStrongAssignAndConsume(&mSpline_, [IOSObjectArray newArrayWithLength:1 + ((IOSObjectArray *) nil_chk(mAttributeNames_))->size_ type:ADXCurveFit_class_()]);
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(mAttributeNames_))->size_; i++) {
    jint pointCount = 0;
    IOSObjectArray *splinePoints = nil;
    IOSDoubleArray *timePoints = nil;
    NSString *name = IOSObjectArray_Get(mAttributeNames_, i);
    for (jint j = 0; j < points->size_; j++) {
      if ([((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, j))) hasCustomDataWithNSString:name]) {
        if (splinePoints == nil) {
          timePoints = [IOSDoubleArray arrayWithLength:points->size_];
          splinePoints = [IOSDoubleArray arrayWithDimensions:2 lengths:(jint[]){ points->size_, [((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, j))) getCustomDataCountWithNSString:name] }];
        }
        *IOSDoubleArray_GetRef(nil_chk(timePoints), pointCount) = ((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, j)))->time_;
        [((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, j))) getCustomDataWithNSString:name withDoubleArray:IOSObjectArray_Get(splinePoints, pointCount) withInt:0];
        pointCount++;
      }
    }
    timePoints = JavaUtilArrays_copyOfWithDoubleArray_withInt_(timePoints, pointCount);
    splinePoints = JavaUtilArrays_copyOfWithNSObjectArray_withInt_(splinePoints, pointCount);
    IOSObjectArray_Set(nil_chk(mSpline_), i + 1, ADXCurveFit_getWithInt_withDoubleArray_withDoubleArray2_(mCurveFitType_, timePoints, splinePoints));
  }
  IOSObjectArray_Set(nil_chk(mSpline_), 0, ADXCurveFit_getWithInt_withDoubleArray_withDoubleArray2_(mCurveFitType_, timePoint, splineData));
  if (((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, 0)))->mPathMotionArc_ != ADXMotionWidget_UNSET) {
    jint size = points->size_;
    IOSIntArray *mode = [IOSIntArray arrayWithLength:size];
    IOSDoubleArray *time = [IOSDoubleArray arrayWithLength:size];
    IOSObjectArray *values = [IOSDoubleArray arrayWithDimensions:2 lengths:(jint[]){ size, 2 }];
    for (jint i = 0; i < size; i++) {
      *IOSIntArray_GetRef(mode, i) = ((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->mPathMotionArc_;
      *IOSDoubleArray_GetRef(time, i) = ((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->time_;
      *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(values, i)), 0) = ((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->x_;
      *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(values, i)), 1) = ((ADXMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->y_;
    }
    JreStrongAssign(&mArcSpline_, ADXCurveFit_getArcWithIntArray_withDoubleArray_withDoubleArray2_(mode, time, values));
  }
  jfloat distance = JavaLangFloat_NaN;
  JreStrongAssignAndConsume(&mCycleMap_, new_JavaUtilHashMap_init());
  if (mKeyList_ != nil) {
    for (NSString * __strong attribute in cycleAttributes) {
      ADXKeyCycleOscillator *cycle = ADXKeyCycleOscillator_makeWidgetCycleWithNSString_(attribute);
      if (cycle == nil) {
        continue;
      }
      if ([cycle variesByPath]) {
        if (JavaLangFloat_isNaNWithFloat_(distance)) {
          distance = ADXMotion_getPreCycleDistance(self);
        }
      }
      [cycle setTypeWithNSString:attribute];
      [((JavaUtilHashMap *) nil_chk(mCycleMap_)) putWithId:attribute withId:cycle];
    }
    for (ADXMotionKey * __strong key in mKeyList_) {
      if ([key isKindOfClass:[ADXMotionKeyCycle class]]) {
        [((ADXMotionKeyCycle *) nil_chk(((ADXMotionKeyCycle *) key))) addCycleValuesWithJavaUtilHashMap:mCycleMap_];
      }
    }
    for (ADXKeyCycleOscillator * __strong cycle in nil_chk([mCycleMap_ values])) {
      [((ADXKeyCycleOscillator *) nil_chk(cycle)) setupWithFloat:distance];
    }
  }
}

- (NSString *)description {
  return JreStrcat("$F$F$F$F", @" start: x: ", ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->x_, @" y: ", mStartMotionPath_->y_, @" end: x: ", ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->x_, @" y: ", mEndMotionPath_->y_);
}

- (void)readViewWithADXMotionPaths:(ADXMotionPaths *)motionPaths {
  ADXMotion_readViewWithADXMotionPaths_(self, motionPaths);
}

- (void)setViewWithADXMotionWidget:(ADXMotionWidget *)view {
  JreStrongAssign(&mView_, view);
}

- (ADXMotionWidget *)getView {
  return mView_;
}

- (void)setStartWithADXMotionWidget:(ADXMotionWidget *)mw {
  ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->time_ = 0;
  mStartMotionPath_->position_ = 0;
  [mStartMotionPath_ setBoundsWithFloat:[((ADXMotionWidget *) nil_chk(mw)) getX] withFloat:[mw getY] withFloat:[mw getWidth] withFloat:[mw getHeight]];
  [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) applyParametersWithADXMotionWidget:mw];
  [((ADXMotionConstrainedPoint *) nil_chk(mStartPoint_)) setStateWithADXMotionWidget:mw];
}

- (void)setEndWithADXMotionWidget:(ADXMotionWidget *)mw {
  ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->time_ = 1;
  mEndMotionPath_->position_ = 1;
  ADXMotion_readViewWithADXMotionPaths_(self, mEndMotionPath_);
  [((ADXMotionPaths *) nil_chk(mEndMotionPath_)) setBoundsWithFloat:[((ADXMotionWidget *) nil_chk(mw)) getLeft] withFloat:[mw getTop] withFloat:[mw getWidth] withFloat:[mw getHeight]];
  [((ADXMotionPaths *) nil_chk(mEndMotionPath_)) applyParametersWithADXMotionWidget:mw];
  [((ADXMotionConstrainedPoint *) nil_chk(mEndPoint_)) setStateWithADXMotionWidget:mw];
}

- (void)setStartStateWithADXViewState:(ADXViewState *)rect
                  withADXMotionWidget:(ADXMotionWidget *)v
                              withInt:(jint)rotation
                              withInt:(jint)preWidth
                              withInt:(jint)preHeight {
  ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->time_ = 0;
  mStartMotionPath_->position_ = 0;
  jint cx;
  jint cy;
  ADXCLRect *r = create_ADXCLRect_init();
  switch (rotation) {
    case 2:
    cx = ((ADXViewState *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    r->left_ = preHeight - JreIntDiv((cy + [rect width]), 2);
    r->top_ = JreIntDiv((cx - [rect height]), 2);
    r->right_ = r->left_ + [rect width];
    r->bottom_ = r->top_ + [rect height];
    break;
    case 1:
    cx = ((ADXViewState *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    r->left_ = JreIntDiv((cy - [rect width]), 2);
    r->top_ = preWidth - JreIntDiv((cx + [rect height]), 2);
    r->right_ = r->left_ + [rect width];
    r->bottom_ = r->top_ + [rect height];
    break;
  }
  [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) setBoundsWithFloat:r->left_ withFloat:r->top_ withFloat:[r width] withFloat:[r height]];
  [((ADXMotionConstrainedPoint *) nil_chk(mStartPoint_)) setStateWithADXCLRect:r withADXMotionWidget:v withInt:rotation withFloat:((ADXViewState *) nil_chk(rect))->rotation_];
}

- (void)rotateWithADXCLRect:(ADXCLRect *)rect
              withADXCLRect:(ADXCLRect *)outArg
                    withInt:(jint)rotation
                    withInt:(jint)preHeight
                    withInt:(jint)preWidth {
  jint cx;
  jint cy;
  switch (rotation) {
    case ADXMotionConstraintSet_ROTATE_PORTRATE_OF_LEFT:
    cx = ((ADXCLRect *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    ((ADXCLRect *) nil_chk(outArg))->left_ = preHeight - JreIntDiv((cy + [rect width]), 2);
    outArg->top_ = JreIntDiv((cx - [rect height]), 2);
    outArg->right_ = outArg->left_ + [rect width];
    outArg->bottom_ = outArg->top_ + [rect height];
    break;
    case ADXMotionConstraintSet_ROTATE_PORTRATE_OF_RIGHT:
    cx = ((ADXCLRect *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    ((ADXCLRect *) nil_chk(outArg))->left_ = JreIntDiv((cy - [rect width]), 2);
    outArg->top_ = preWidth - JreIntDiv((cx + [rect height]), 2);
    outArg->right_ = outArg->left_ + [rect width];
    outArg->bottom_ = outArg->top_ + [rect height];
    break;
    case ADXMotionConstraintSet_ROTATE_LEFT_OF_PORTRATE:
    cx = ((ADXCLRect *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->bottom_ + rect->top_;
    ((ADXCLRect *) nil_chk(outArg))->left_ = preHeight - JreIntDiv((cy + [rect width]), 2);
    outArg->top_ = JreIntDiv((cx - [rect height]), 2);
    outArg->right_ = outArg->left_ + [rect width];
    outArg->bottom_ = outArg->top_ + [rect height];
    break;
    case ADXMotionConstraintSet_ROTATE_RIGHT_OF_PORTRATE:
    cx = ((ADXCLRect *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    ((ADXCLRect *) nil_chk(outArg))->left_ = JreIntDiv([rect height], 2) + rect->top_ - JreIntDiv(cx, 2);
    outArg->top_ = preWidth - JreIntDiv((cx + [rect height]), 2);
    outArg->right_ = outArg->left_ + [rect width];
    outArg->bottom_ = outArg->top_ + [rect height];
    break;
  }
}

+ (id<ADXDifferentialInterpolator>)getInterpolatorWithInt:(jint)type
                                             withNSString:(NSString *)interpolatorString
                                                  withInt:(jint)id_ {
  return ADXMotion_getInterpolatorWithInt_withNSString_withInt_(type, interpolatorString, id_);
}

- (void)setBothStatesWithADXMotionWidget:(ADXMotionWidget *)v {
  ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->time_ = 0;
  mStartMotionPath_->position_ = 0;
  mNoMovement_ = true;
  [mStartMotionPath_ setBoundsWithFloat:[((ADXMotionWidget *) nil_chk(v)) getX] withFloat:[v getY] withFloat:[v getWidth] withFloat:[v getHeight]];
  [((ADXMotionPaths *) nil_chk(mEndMotionPath_)) setBoundsWithFloat:[v getX] withFloat:[v getY] withFloat:[v getWidth] withFloat:[v getHeight]];
  [((ADXMotionConstrainedPoint *) nil_chk(mStartPoint_)) setStateWithADXMotionWidget:v];
  [((ADXMotionConstrainedPoint *) nil_chk(mEndPoint_)) setStateWithADXMotionWidget:v];
}

- (jfloat)getAdjustedPositionWithFloat:(jfloat)position
                        withFloatArray:(IOSFloatArray *)velocity {
  return ADXMotion_getAdjustedPositionWithFloat_withFloatArray_(self, position, velocity);
}

- (void)endTriggerWithBoolean:(jboolean)start {
}

- (jboolean)interpolateWithADXMotionWidget:(ADXMotionWidget *)child
                                 withFloat:(jfloat)global_position
                                  withLong:(jlong)time
                           withADXKeyCache:(ADXKeyCache *)keyCache {
  jboolean timeAnimation = false;
  jfloat position = ADXMotion_getAdjustedPositionWithFloat_withFloatArray_(self, global_position, nil);
  if (mQuantizeMotionSteps_ != ADXMotionWidget_UNSET) {
    jfloat pin = position;
    jfloat steps = 1.0f / mQuantizeMotionSteps_;
    jfloat jump = (jfloat) JavaLangMath_floorWithDouble_(position / steps) * steps;
    jfloat section = (fmodf(position, steps)) / steps;
    if (!JavaLangFloat_isNaNWithFloat_(mQuantizeMotionPhase_)) {
      section = fmodf((section + mQuantizeMotionPhase_), 1);
    }
    if (mQuantizeMotionInterpolator_ != nil) {
      section = [mQuantizeMotionInterpolator_ getInterpolationWithFloat:section];
    }
    else {
      section = section > 0.5 ? 1 : 0;
    }
    position = section * steps + jump;
  }
  if (mAttributesMap_ != nil) {
    for (ADXSplineSet * __strong aSpline in nil_chk([mAttributesMap_ values])) {
      [((ADXSplineSet *) nil_chk(aSpline)) setPropertyWithADXTypedValues:child withFloat:position];
    }
  }
  if (mSpline_ != nil) {
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(mSpline_, 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
    if (mArcSpline_ != nil) {
      if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
        [mArcSpline_ getPosWithDouble:position withDoubleArray:mInterpolateData_];
        [((ADXCurveFit *) nil_chk(mArcSpline_)) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
      }
    }
    if (!mNoMovement_) {
      [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) setViewWithFloat:position withADXMotionWidget:child withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:nil];
    }
    if (mTransformPivotTarget_ != ADXMotionWidget_UNSET) {
      if (mTransformPivotView_ == nil) {
        ADXMotionWidget *layout = [((ADXMotionWidget *) nil_chk(child)) getParent];
        JreStrongAssign(&mTransformPivotView_, [((ADXMotionWidget *) nil_chk(layout)) findViewByIdWithInt:mTransformPivotTarget_]);
      }
      if (mTransformPivotView_ != nil) {
        jfloat cy = ([mTransformPivotView_ getTop] + [((ADXMotionWidget *) nil_chk(mTransformPivotView_)) getBottom]) / 2.0f;
        jfloat cx = ([((ADXMotionWidget *) nil_chk(mTransformPivotView_)) getLeft] + [((ADXMotionWidget *) nil_chk(mTransformPivotView_)) getRight]) / 2.0f;
        if ([((ADXMotionWidget *) nil_chk(child)) getRight] - [child getLeft] > 0 && [child getBottom] - [child getTop] > 0) {
          jfloat px = (cx - [child getLeft]);
          jfloat py = (cy - [child getTop]);
          [child setPivotXWithFloat:px];
          [child setPivotYWithFloat:py];
        }
      }
    }
    for (jint i = 1; i < ((IOSObjectArray *) nil_chk(mSpline_))->size_; i++) {
      ADXCurveFit *spline = IOSObjectArray_Get(mSpline_, i);
      [((ADXCurveFit *) nil_chk(spline)) getPosWithDouble:position withFloatArray:mValuesBuff_];
      [((ADXCustomVariable *) nil_chk([((JavaUtilHashMap *) nil_chk(((ADXMotionPaths *) nil_chk(mStartMotionPath_))->customAttributes_)) getWithId:IOSObjectArray_Get(nil_chk(mAttributeNames_), i - 1)])) setInterpolatedValueWithADXMotionWidget:child withFloatArray:mValuesBuff_];
    }
    if (((ADXMotionConstrainedPoint *) nil_chk(mStartPoint_))->mVisibilityMode_ == ADXMotionWidget_VISIBILITY_MODE_NORMAL) {
      if (position <= 0.0f) {
        [((ADXMotionWidget *) nil_chk(child)) setVisibilityWithInt:mStartPoint_->visibility_];
      }
      else if (position >= 1.0f) {
        [((ADXMotionWidget *) nil_chk(child)) setVisibilityWithInt:((ADXMotionConstrainedPoint *) nil_chk(mEndPoint_))->visibility_];
      }
      else if (((ADXMotionConstrainedPoint *) nil_chk(mEndPoint_))->visibility_ != mStartPoint_->visibility_) {
        [((ADXMotionWidget *) nil_chk(child)) setVisibilityWithInt:ADXMotionWidget_VISIBLE];
      }
    }
    if (mKeyTriggers_ != nil) {
      for (jint i = 0; i < ((IOSObjectArray *) nil_chk(mKeyTriggers_))->size_; i++) {
        [((ADXMotionKeyTrigger *) nil_chk(IOSObjectArray_Get(mKeyTriggers_, i))) conditionallyFireWithFloat:position withADXMotionWidget:child];
      }
    }
  }
  else {
    jfloat float_l = (((ADXMotionPaths *) nil_chk(mStartMotionPath_))->x_ + (((ADXMotionPaths *) nil_chk(mEndMotionPath_))->x_ - mStartMotionPath_->x_) * position);
    jfloat float_t = (mStartMotionPath_->y_ + (mEndMotionPath_->y_ - mStartMotionPath_->y_) * position);
    jfloat float_width = (mStartMotionPath_->width_ + (mEndMotionPath_->width_ - mStartMotionPath_->width_) * position);
    jfloat float_height = (mStartMotionPath_->height_ + (mEndMotionPath_->height_ - mStartMotionPath_->height_) * position);
    jint l = JreFpToInt((0.5f + float_l));
    jint t = JreFpToInt((0.5f + float_t));
    jint r = JreFpToInt((0.5f + float_l + float_width));
    jint b = JreFpToInt((0.5f + float_t + float_height));
    jint width = r - l;
    jint height = b - t;
    [((ADXMotionWidget *) nil_chk(child)) layoutWithInt:l withInt:t withInt:r withInt:b];
  }
  if (mCycleMap_ != nil) {
    for (ADXKeyCycleOscillator * __strong osc in nil_chk([mCycleMap_ values])) {
      if ([osc isKindOfClass:[ADXKeyCycleOscillator_PathRotateSet class]]) {
        [((ADXKeyCycleOscillator_PathRotateSet *) nil_chk(((ADXKeyCycleOscillator_PathRotateSet *) osc))) setPathRotateWithADXMotionWidget:child withFloat:position withDouble:IOSDoubleArray_Get(nil_chk(mInterpolateVelocity_), 0) withDouble:IOSDoubleArray_Get(mInterpolateVelocity_, 1)];
      }
      else {
        [((ADXKeyCycleOscillator *) nil_chk(osc)) setPropertyWithADXMotionWidget:child withFloat:position];
      }
    }
  }
  return false;
}

- (void)getDpDtWithFloat:(jfloat)position
               withFloat:(jfloat)locationX
               withFloat:(jfloat)locationY
          withFloatArray:(IOSFloatArray *)mAnchorDpDt {
  position = ADXMotion_getAdjustedPositionWithFloat_withFloatArray_(self, position, mVelocity_);
  if (mSpline_ != nil) {
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(mSpline_, 0))) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
    jfloat v = IOSFloatArray_Get(nil_chk(mVelocity_), 0);
    for (jint i = 0; i < ((IOSDoubleArray *) nil_chk(mInterpolateVelocity_))->size_; i++) {
      JreTimesAssignDoubleD(IOSDoubleArray_GetRef(mInterpolateVelocity_, i), v);
    }
    if (mArcSpline_ != nil) {
      if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
        [mArcSpline_ getPosWithDouble:position withDoubleArray:mInterpolateData_];
        [((ADXCurveFit *) nil_chk(mArcSpline_)) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
        [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) setDpDtWithFloat:locationX withFloat:locationY withFloatArray:mAnchorDpDt withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:mInterpolateData_];
      }
      return;
    }
    [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) setDpDtWithFloat:locationX withFloat:locationY withFloatArray:mAnchorDpDt withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:mInterpolateData_];
    return;
  }
  jfloat dleft = (((ADXMotionPaths *) nil_chk(mEndMotionPath_))->x_ - ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->x_);
  jfloat dTop = (mEndMotionPath_->y_ - mStartMotionPath_->y_);
  jfloat dWidth = (mEndMotionPath_->width_ - mStartMotionPath_->width_);
  jfloat dHeight = (mEndMotionPath_->height_ - mStartMotionPath_->height_);
  jfloat dRight = dleft + dWidth;
  jfloat dBottom = dTop + dHeight;
  *IOSFloatArray_GetRef(nil_chk(mAnchorDpDt), 0) = dleft * (1 - locationX) + dRight * (locationX);
  *IOSFloatArray_GetRef(mAnchorDpDt, 1) = dTop * (1 - locationY) + dBottom * (locationY);
}

- (void)getPostLayoutDvDpWithFloat:(jfloat)position
                           withInt:(jint)width
                           withInt:(jint)height
                         withFloat:(jfloat)locationX
                         withFloat:(jfloat)locationY
                    withFloatArray:(IOSFloatArray *)mAnchorDpDt {
  position = ADXMotion_getAdjustedPositionWithFloat_withFloatArray_(self, position, mVelocity_);
  ADXSplineSet *trans_x = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXMotionKey_TRANSLATION_X];
  ADXSplineSet *trans_y = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXMotionKey_TRANSLATION_Y];
  ADXSplineSet *rotation = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXMotionKey_ROTATION];
  ADXSplineSet *scale_x = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXMotionKey_SCALE_X];
  ADXSplineSet *scale_y = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXMotionKey_SCALE_Y];
  ADXKeyCycleOscillator *osc_x = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXMotionKey_TRANSLATION_X];
  ADXKeyCycleOscillator *osc_y = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXMotionKey_TRANSLATION_Y];
  ADXKeyCycleOscillator *osc_r = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXMotionKey_ROTATION];
  ADXKeyCycleOscillator *osc_sx = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXMotionKey_SCALE_X];
  ADXKeyCycleOscillator *osc_sy = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXMotionKey_SCALE_Y];
  ADXVelocityMatrix *vmat = create_ADXVelocityMatrix_init();
  [vmat clear];
  [vmat setRotationVelocityWithADXSplineSet:rotation withFloat:position];
  [vmat setTranslationVelocityWithADXSplineSet:trans_x withADXSplineSet:trans_y withFloat:position];
  [vmat setScaleVelocityWithADXSplineSet:scale_x withADXSplineSet:scale_y withFloat:position];
  [vmat setRotationVelocityWithADXKeyCycleOscillator:osc_r withFloat:position];
  [vmat setTranslationVelocityWithADXKeyCycleOscillator:osc_x withADXKeyCycleOscillator:osc_y withFloat:position];
  [vmat setScaleVelocityWithADXKeyCycleOscillator:osc_sx withADXKeyCycleOscillator:osc_sy withFloat:position];
  if (mArcSpline_ != nil) {
    if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
      [mArcSpline_ getPosWithDouble:position withDoubleArray:mInterpolateData_];
      [((ADXCurveFit *) nil_chk(mArcSpline_)) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
      [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) setDpDtWithFloat:locationX withFloat:locationY withFloatArray:mAnchorDpDt withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:mInterpolateData_];
    }
    [vmat applyTransformWithFloat:locationX withFloat:locationY withInt:width withInt:height withFloatArray:mAnchorDpDt];
    return;
  }
  if (mSpline_ != nil) {
    position = ADXMotion_getAdjustedPositionWithFloat_withFloatArray_(self, position, mVelocity_);
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
    jfloat v = IOSFloatArray_Get(nil_chk(mVelocity_), 0);
    for (jint i = 0; i < ((IOSDoubleArray *) nil_chk(mInterpolateVelocity_))->size_; i++) {
      JreTimesAssignDoubleD(IOSDoubleArray_GetRef(mInterpolateVelocity_, i), v);
    }
    [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) setDpDtWithFloat:locationX withFloat:locationY withFloatArray:mAnchorDpDt withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:mInterpolateData_];
    [vmat applyTransformWithFloat:locationX withFloat:locationY withInt:width withInt:height withFloatArray:mAnchorDpDt];
    return;
  }
  jfloat dleft = (((ADXMotionPaths *) nil_chk(mEndMotionPath_))->x_ - ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->x_);
  jfloat dTop = (mEndMotionPath_->y_ - mStartMotionPath_->y_);
  jfloat dWidth = (mEndMotionPath_->width_ - mStartMotionPath_->width_);
  jfloat dHeight = (mEndMotionPath_->height_ - mStartMotionPath_->height_);
  jfloat dRight = dleft + dWidth;
  jfloat dBottom = dTop + dHeight;
  *IOSFloatArray_GetRef(nil_chk(mAnchorDpDt), 0) = dleft * (1 - locationX) + dRight * (locationX);
  *IOSFloatArray_GetRef(mAnchorDpDt, 1) = dTop * (1 - locationY) + dBottom * (locationY);
  [vmat clear];
  [vmat setRotationVelocityWithADXSplineSet:rotation withFloat:position];
  [vmat setTranslationVelocityWithADXSplineSet:trans_x withADXSplineSet:trans_y withFloat:position];
  [vmat setScaleVelocityWithADXSplineSet:scale_x withADXSplineSet:scale_y withFloat:position];
  [vmat setRotationVelocityWithADXKeyCycleOscillator:osc_r withFloat:position];
  [vmat setTranslationVelocityWithADXKeyCycleOscillator:osc_x withADXKeyCycleOscillator:osc_y withFloat:position];
  [vmat setScaleVelocityWithADXKeyCycleOscillator:osc_sx withADXKeyCycleOscillator:osc_sy withFloat:position];
  [vmat applyTransformWithFloat:locationX withFloat:locationY withInt:width withInt:height withFloatArray:mAnchorDpDt];
  return;
}

- (jint)getDrawPath {
  jint mode = ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->mDrawPath_;
  for (ADXMotionPaths * __strong keyFrame in nil_chk(mMotionPaths_)) {
    mode = JavaLangMath_maxWithInt_withInt_(mode, ((ADXMotionPaths *) nil_chk(keyFrame))->mDrawPath_);
  }
  mode = JavaLangMath_maxWithInt_withInt_(mode, ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->mDrawPath_);
  return mode;
}

- (void)setDrawPathWithInt:(jint)debugMode {
  ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->mDrawPath_ = debugMode;
}

- (NSString *)name {
  return [((ADXMotionWidget *) nil_chk(mView_)) getName];
}

- (void)positionKeyframeWithADXMotionWidget:(ADXMotionWidget *)view
                   withADXMotionKeyPosition:(ADXMotionKeyPosition *)key
                                  withFloat:(jfloat)x
                                  withFloat:(jfloat)y
                          withNSStringArray:(IOSObjectArray *)attribute
                             withFloatArray:(IOSFloatArray *)value {
  ADXFloatRect *start = create_ADXFloatRect_init();
  start->left_ = ((ADXMotionPaths *) nil_chk(mStartMotionPath_))->x_;
  start->top_ = mStartMotionPath_->y_;
  start->right_ = start->left_ + mStartMotionPath_->width_;
  start->bottom_ = start->top_ + mStartMotionPath_->height_;
  ADXFloatRect *end = create_ADXFloatRect_init();
  end->left_ = ((ADXMotionPaths *) nil_chk(mEndMotionPath_))->x_;
  end->top_ = mEndMotionPath_->y_;
  end->right_ = end->left_ + mEndMotionPath_->width_;
  end->bottom_ = end->top_ + mEndMotionPath_->height_;
  [((ADXMotionKeyPosition *) nil_chk(key)) positionAttributesWithADXMotionWidget:view withADXFloatRect:start withADXFloatRect:end withFloat:x withFloat:y withNSStringArray:attribute withFloatArray:value];
}

- (jint)getKeyFramePositionsWithIntArray:(IOSIntArray *)type
                          withFloatArray:(IOSFloatArray *)pos {
  jint i = 0;
  jint count = 0;
  for (ADXMotionKey * __strong key in nil_chk(mKeyList_)) {
    *IOSIntArray_GetRef(nil_chk(type), i++) = ((ADXMotionKey *) nil_chk(key))->mFramePosition_ + 1000 * key->mType_;
    jfloat time = key->mFramePosition_ / 100.0f;
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:time withDoubleArray:mInterpolateData_];
    [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:time withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:pos withInt:count];
    count += 2;
  }
  return i;
}

- (jint)getKeyFrameInfoWithInt:(jint)type
                  withIntArray:(IOSIntArray *)info {
  jint count = 0;
  jint cursor = 0;
  IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
  jint len;
  for (ADXMotionKey * __strong key in nil_chk(mKeyList_)) {
    if (((ADXMotionKey *) nil_chk(key))->mType_ != type && type == -1) {
      continue;
    }
    len = cursor;
    *IOSIntArray_GetRef(nil_chk(info), cursor) = 0;
    *IOSIntArray_GetRef(info, ++cursor) = key->mType_;
    *IOSIntArray_GetRef(info, ++cursor) = key->mFramePosition_;
    jfloat time = key->mFramePosition_ / 100.0f;
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:time withDoubleArray:mInterpolateData_];
    [((ADXMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:time withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:pos withInt:0];
    *IOSIntArray_GetRef(info, ++cursor) = JavaLangFloat_floatToIntBitsWithFloat_(IOSFloatArray_Get(pos, 0));
    *IOSIntArray_GetRef(info, ++cursor) = JavaLangFloat_floatToIntBitsWithFloat_(IOSFloatArray_Get(pos, 1));
    if ([key isKindOfClass:[ADXMotionKeyPosition class]]) {
      ADXMotionKeyPosition *kp = (ADXMotionKeyPosition *) key;
      *IOSIntArray_GetRef(info, ++cursor) = kp->mPositionType_;
      *IOSIntArray_GetRef(info, ++cursor) = JavaLangFloat_floatToIntBitsWithFloat_(kp->mPercentX_);
      *IOSIntArray_GetRef(info, ++cursor) = JavaLangFloat_floatToIntBitsWithFloat_(kp->mPercentY_);
    }
    cursor++;
    *IOSIntArray_GetRef(info, len) = cursor - len;
    count++;
  }
  return count;
}

- (void)dealloc {
  RELEASE_(mTempRect_);
  RELEASE_(mView_);
  RELEASE_(mConstraintTag_);
  RELEASE_(mStartMotionPath_);
  RELEASE_(mEndMotionPath_);
  RELEASE_(mStartPoint_);
  RELEASE_(mEndPoint_);
  RELEASE_(mSpline_);
  RELEASE_(mArcSpline_);
  RELEASE_(mInterpolateVariables_);
  RELEASE_(mInterpolateData_);
  RELEASE_(mInterpolateVelocity_);
  RELEASE_(mAttributeNames_);
  RELEASE_(mAttributeInterpolatorCount_);
  RELEASE_(mValuesBuff_);
  RELEASE_(mMotionPaths_);
  RELEASE_(mVelocity_);
  RELEASE_(mKeyList_);
  RELEASE_(mTimeCycleAttributesMap_);
  RELEASE_(mAttributesMap_);
  RELEASE_(mCycleMap_);
  RELEASE_(mKeyTriggers_);
  RELEASE_(mTransformPivotView_);
  RELEASE_(mQuantizeMotionInterpolator_);
  RELEASE_(attributeTable_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "LADXMotionPaths;", 0x1, 2, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 3, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "[D", 0x0, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 12, 9, -1, -1, -1, -1 },
    { NULL, "F", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXMotionKeyPosition;", 0x0, 13, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 15, 16, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 17, 18, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 19, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 21, 22, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 23, 9, -1, -1, -1, -1 },
    { NULL, "F", 0x0, 24, 25, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 26, 27, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 28, 29, -1, 30, -1, -1 },
    { NULL, "V", 0x1, 31, 32, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 33, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 34, 35, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 36, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 37, 27, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 38, 3, -1, -1, -1, -1 },
    { NULL, "LADXMotionWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 39, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 40, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 41, 42, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 43, 44, -1, -1, -1, -1 },
    { NULL, "LADXDifferentialInterpolator;", 0xa, 45, 46, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 47, 3, -1, -1, -1, -1 },
    { NULL, "F", 0x2, 48, 49, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 50, 51, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 52, 53, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 54, 55, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 56, 57, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 58, 1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 59, 60, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 61, 62, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 63, 64, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(getTransformPivotTarget);
  methods[1].selector = @selector(setTransformPivotTargetWithInt:);
  methods[2].selector = @selector(getKeyFrameWithInt:);
  methods[3].selector = @selector(initWithADXMotionWidget:);
  methods[4].selector = @selector(getStartX);
  methods[5].selector = @selector(getStartY);
  methods[6].selector = @selector(getFinalX);
  methods[7].selector = @selector(getFinalY);
  methods[8].selector = @selector(getStartWidth);
  methods[9].selector = @selector(getStartHeight);
  methods[10].selector = @selector(getFinalWidth);
  methods[11].selector = @selector(getFinalHeight);
  methods[12].selector = @selector(getAnimateRelativeTo);
  methods[13].selector = @selector(setupRelativeWithADXMotion:);
  methods[14].selector = @selector(getCenterX);
  methods[15].selector = @selector(getCenterY);
  methods[16].selector = @selector(getCenterWithDouble:withFloatArray:withFloatArray:);
  methods[17].selector = @selector(buildPathWithFloatArray:withInt:);
  methods[18].selector = @selector(getPosWithDouble:);
  methods[19].selector = @selector(buildBoundsWithFloatArray:withInt:);
  methods[20].selector = @selector(getPreCycleDistance);
  methods[21].selector = @selector(getPositionKeyframeWithInt:withInt:withFloat:withFloat:);
  methods[22].selector = @selector(buildKeyFramesWithFloatArray:withIntArray:withIntArray:);
  methods[23].selector = @selector(buildKeyBoundsWithFloatArray:withIntArray:);
  methods[24].selector = @selector(getAttributeValuesWithNSString:withFloatArray:withInt:);
  methods[25].selector = @selector(buildRectWithFloat:withFloatArray:withInt:);
  methods[26].selector = @selector(buildRectanglesWithFloatArray:withInt:);
  methods[27].selector = @selector(getKeyFrameParameterWithInt:withFloat:withFloat:);
  methods[28].selector = @selector(insertKeyWithADXMotionPaths:);
  methods[29].selector = @selector(addKeysWithJavaUtilArrayList:);
  methods[30].selector = @selector(addKeyWithADXMotionKey:);
  methods[31].selector = @selector(setPathMotionArcWithInt:);
  methods[32].selector = @selector(setupWithInt:withInt:withFloat:withLong:);
  methods[33].selector = @selector(description);
  methods[34].selector = @selector(readViewWithADXMotionPaths:);
  methods[35].selector = @selector(setViewWithADXMotionWidget:);
  methods[36].selector = @selector(getView);
  methods[37].selector = @selector(setStartWithADXMotionWidget:);
  methods[38].selector = @selector(setEndWithADXMotionWidget:);
  methods[39].selector = @selector(setStartStateWithADXViewState:withADXMotionWidget:withInt:withInt:withInt:);
  methods[40].selector = @selector(rotateWithADXCLRect:withADXCLRect:withInt:withInt:withInt:);
  methods[41].selector = @selector(getInterpolatorWithInt:withNSString:withInt:);
  methods[42].selector = @selector(setBothStatesWithADXMotionWidget:);
  methods[43].selector = @selector(getAdjustedPositionWithFloat:withFloatArray:);
  methods[44].selector = @selector(endTriggerWithBoolean:);
  methods[45].selector = @selector(interpolateWithADXMotionWidget:withFloat:withLong:withADXKeyCache:);
  methods[46].selector = @selector(getDpDtWithFloat:withFloat:withFloat:withFloatArray:);
  methods[47].selector = @selector(getPostLayoutDvDpWithFloat:withInt:withInt:withFloat:withFloat:withFloatArray:);
  methods[48].selector = @selector(getDrawPath);
  methods[49].selector = @selector(setDrawPathWithInt:);
  methods[50].selector = @selector(name);
  methods[51].selector = @selector(positionKeyframeWithADXMotionWidget:withADXMotionKeyPosition:withFloat:withFloat:withNSStringArray:withFloatArray:);
  methods[52].selector = @selector(getKeyFramePositionsWithIntArray:withFloatArray:);
  methods[53].selector = @selector(getKeyFrameInfoWithInt:withIntArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "PATH_PERCENT", "I", .constantValue.asInt = ADXMotion_PATH_PERCENT, 0x19, -1, -1, -1, -1 },
    { "PATH_PERPENDICULAR", "I", .constantValue.asInt = ADXMotion_PATH_PERPENDICULAR, 0x19, -1, -1, -1, -1 },
    { "HORIZONTAL_PATH_X", "I", .constantValue.asInt = ADXMotion_HORIZONTAL_PATH_X, 0x19, -1, -1, -1, -1 },
    { "HORIZONTAL_PATH_Y", "I", .constantValue.asInt = ADXMotion_HORIZONTAL_PATH_Y, 0x19, -1, -1, -1, -1 },
    { "VERTICAL_PATH_X", "I", .constantValue.asInt = ADXMotion_VERTICAL_PATH_X, 0x19, -1, -1, -1, -1 },
    { "VERTICAL_PATH_Y", "I", .constantValue.asInt = ADXMotion_VERTICAL_PATH_Y, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_NONE", "I", .constantValue.asInt = ADXMotion_DRAW_PATH_NONE, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_BASIC", "I", .constantValue.asInt = ADXMotion_DRAW_PATH_BASIC, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_RELATIVE", "I", .constantValue.asInt = ADXMotion_DRAW_PATH_RELATIVE, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_CARTESIAN", "I", .constantValue.asInt = ADXMotion_DRAW_PATH_CARTESIAN, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_AS_CONFIGURED", "I", .constantValue.asInt = ADXMotion_DRAW_PATH_AS_CONFIGURED, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_RECTANGLE", "I", .constantValue.asInt = ADXMotion_DRAW_PATH_RECTANGLE, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_SCREEN", "I", .constantValue.asInt = ADXMotion_DRAW_PATH_SCREEN, 0x19, -1, -1, -1, -1 },
    { "ROTATION_RIGHT", "I", .constantValue.asInt = ADXMotion_ROTATION_RIGHT, 0x19, -1, -1, -1, -1 },
    { "ROTATION_LEFT", "I", .constantValue.asInt = ADXMotion_ROTATION_LEFT, 0x19, -1, -1, -1, -1 },
    { "mTempRect_", "LADXCLRect;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 65, -1, -1 },
    { "DEBUG", "Z", .constantValue.asBOOL = ADXMotion_DEBUG, 0x1a, -1, -1, -1, -1 },
    { "FAVOR_FIXED_SIZE_VIEWS", "Z", .constantValue.asBOOL = ADXMotion_FAVOR_FIXED_SIZE_VIEWS, 0x1a, -1, -1, -1, -1 },
    { "mView_", "LADXMotionWidget;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mId_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mConstraintTag_", "LNSString;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCurveFitType_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStartMotionPath_", "LADXMotionPaths;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mEndMotionPath_", "LADXMotionPaths;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStartPoint_", "LADXMotionConstrainedPoint;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mEndPoint_", "LADXMotionConstrainedPoint;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mSpline_", "[LADXCurveFit;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mArcSpline_", "LADXCurveFit;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mMotionStagger_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mStaggerOffset_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mStaggerScale_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCurrentCenterX_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCurrentCenterY_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mInterpolateVariables_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mInterpolateData_", "[D", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mInterpolateVelocity_", "[D", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAttributeNames_", "[LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAttributeInterpolatorCount_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "MAX_DIMENSION_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mValuesBuff_", "[F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mMotionPaths_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x2, -1, -1, 66, -1 },
    { "mVelocity_", "[F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mKeyList_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x2, -1, -1, 67, -1 },
    { "mTimeCycleAttributesMap_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x2, -1, -1, 68, -1 },
    { "mAttributesMap_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x2, -1, -1, 69, -1 },
    { "mCycleMap_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x2, -1, -1, 70, -1 },
    { "mKeyTriggers_", "[LADXMotionKeyTrigger;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPathMotionArc_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTransformPivotTarget_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTransformPivotView_", "LADXMotionWidget;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mQuantizeMotionSteps_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mQuantizeMotionPhase_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mQuantizeMotionInterpolator_", "LADXDifferentialInterpolator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mNoMovement_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "attributeTable_", "[LNSString;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "EASE_IN_OUT", "I", .constantValue.asInt = ADXMotion_EASE_IN_OUT, 0x18, -1, -1, -1, -1 },
    { "EASE_IN", "I", .constantValue.asInt = ADXMotion_EASE_IN, 0x18, -1, -1, -1, -1 },
    { "EASE_OUT", "I", .constantValue.asInt = ADXMotion_EASE_OUT, 0x18, -1, -1, -1, -1 },
    { "LINEAR", "I", .constantValue.asInt = ADXMotion_LINEAR, 0x18, -1, -1, -1, -1 },
    { "BOUNCE", "I", .constantValue.asInt = ADXMotion_BOUNCE, 0x18, -1, -1, -1, -1 },
    { "OVERSHOOT", "I", .constantValue.asInt = ADXMotion_OVERSHOOT, 0x18, -1, -1, -1, -1 },
    { "SPLINE_STRING", "I", .constantValue.asInt = ADXMotion_SPLINE_STRING, 0x1a, -1, -1, -1, -1 },
    { "INTERPOLATOR_REFERENCE_ID", "I", .constantValue.asInt = ADXMotion_INTERPOLATOR_REFERENCE_ID, 0x1a, -1, -1, -1, -1 },
    { "INTERPOLATOR_UNDEFINED", "I", .constantValue.asInt = ADXMotion_INTERPOLATOR_UNDEFINED, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "setTransformPivotTarget", "I", "getKeyFrame", "LADXMotionWidget;", "setupRelative", "LADXMotion;", "getCenter", "D[F[F", "buildPath", "[FI", "getPos", "D", "buildBounds", "getPositionKeyframe", "IIFF", "buildKeyFrames", "[F[I[I", "buildKeyBounds", "[F[I", "getAttributeValues", "LNSString;[FI", "buildRect", "F[FI", "buildRectangles", "getKeyFrameParameter", "IFF", "insertKey", "LADXMotionPaths;", "addKeys", "LJavaUtilArrayList;", "(Ljava/util/ArrayList<Landroidx/constraintlayout/core/motion/key/MotionKey;>;)V", "addKey", "LADXMotionKey;", "setPathMotionArc", "setup", "IIFJ", "toString", "readView", "setView", "setStart", "setEnd", "setStartState", "LADXViewState;LADXMotionWidget;III", "rotate", "LADXCLRect;LADXCLRect;III", "getInterpolator", "ILNSString;I", "setBothStates", "getAdjustedPosition", "F[F", "endTrigger", "Z", "interpolate", "LADXMotionWidget;FJLADXKeyCache;", "getDpDt", "FFF[F", "getPostLayoutDvDp", "FIIFF[F", "setDrawPath", "positionKeyframe", "LADXMotionWidget;LADXMotionKeyPosition;FF[LNSString;[F", "getKeyFramePositions", "[I[F", "getKeyFrameInfo", "I[I", &ADXMotion_TAG, "Ljava/util/ArrayList<Landroidx/constraintlayout/core/motion/MotionPaths;>;", "Ljava/util/ArrayList<Landroidx/constraintlayout/core/motion/key/MotionKey;>;", "Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/core/motion/utils/TimeCycleSplineSet;>;", "Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/core/motion/utils/SplineSet;>;", "Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/core/motion/utils/KeyCycleOscillator;>;" };
  static const J2ObjcClassInfo _ADXMotion = { "Motion", "androidx.constraintlayout.core.motion", ptrTable, methods, fields, 7, 0x1, 54, 65, -1, -1, -1, -1, -1 };
  return &_ADXMotion;
}

@end

void ADXMotion_initWithADXMotionWidget_(ADXMotion *self, ADXMotionWidget *view) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->mTempRect_, new_ADXCLRect_init());
  self->mCurveFitType_ = ADXMotionWidget_UNSET;
  JreStrongAssignAndConsume(&self->mStartMotionPath_, new_ADXMotionPaths_init());
  JreStrongAssignAndConsume(&self->mEndMotionPath_, new_ADXMotionPaths_init());
  JreStrongAssignAndConsume(&self->mStartPoint_, new_ADXMotionConstrainedPoint_initPackagePrivate());
  JreStrongAssignAndConsume(&self->mEndPoint_, new_ADXMotionConstrainedPoint_initPackagePrivate());
  self->mMotionStagger_ = JavaLangFloat_NaN;
  self->mStaggerOffset_ = 0;
  self->mStaggerScale_ = 1.0f;
  self->MAX_DIMENSION_ = 4;
  JreStrongAssignAndConsume(&self->mValuesBuff_, [IOSFloatArray newArrayWithLength:self->MAX_DIMENSION_]);
  JreStrongAssignAndConsume(&self->mMotionPaths_, new_JavaUtilArrayList_init());
  JreStrongAssignAndConsume(&self->mVelocity_, [IOSFloatArray newArrayWithLength:1]);
  JreStrongAssignAndConsume(&self->mKeyList_, new_JavaUtilArrayList_init());
  self->mPathMotionArc_ = ADXMotionWidget_UNSET;
  self->mTransformPivotTarget_ = ADXMotionWidget_UNSET;
  JreStrongAssign(&self->mTransformPivotView_, nil);
  self->mQuantizeMotionSteps_ = ADXMotionWidget_UNSET;
  self->mQuantizeMotionPhase_ = JavaLangFloat_NaN;
  JreStrongAssign(&self->mQuantizeMotionInterpolator_, nil);
  self->mNoMovement_ = false;
  [self setViewWithADXMotionWidget:view];
}

ADXMotion *new_ADXMotion_initWithADXMotionWidget_(ADXMotionWidget *view) {
  J2OBJC_NEW_IMPL(ADXMotion, initWithADXMotionWidget_, view)
}

ADXMotion *create_ADXMotion_initWithADXMotionWidget_(ADXMotionWidget *view) {
  J2OBJC_CREATE_IMPL(ADXMotion, initWithADXMotionWidget_, view)
}

jfloat ADXMotion_getPreCycleDistance(ADXMotion *self) {
  jint pointCount = 100;
  IOSFloatArray *points = [IOSFloatArray arrayWithLength:2];
  jfloat sum = 0;
  jfloat mils = 1.0f / (pointCount - 1);
  jdouble x = 0;
  jdouble y = 0;
  for (jint i = 0; i < pointCount; i++) {
    jfloat position = (i) * mils;
    jdouble p = position;
    ADXEasing *easing = JreRetainedLocalValue(((ADXMotionPaths *) nil_chk(self->mStartMotionPath_))->mKeyFrameEasing_);
    jfloat start = 0;
    jfloat end = JavaLangFloat_NaN;
    for (ADXMotionPaths * __strong frame in nil_chk(self->mMotionPaths_)) {
      if (((ADXMotionPaths *) nil_chk(frame))->mKeyFrameEasing_ != nil) {
        if (frame->time_ < position) {
          easing = frame->mKeyFrameEasing_;
          start = frame->time_;
        }
        else {
          if (JavaLangFloat_isNaNWithFloat_(end)) {
            end = frame->time_;
          }
        }
      }
    }
    if (easing != nil) {
      if (JavaLangFloat_isNaNWithFloat_(end)) {
        end = 1.0f;
      }
      jfloat offset = (position - start) / (end - start);
      offset = (jfloat) [easing getWithDouble:offset];
      p = offset * (end - start) + start;
    }
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(self->mSpline_), 0))) getPosWithDouble:p withDoubleArray:self->mInterpolateData_];
    [((ADXMotionPaths *) nil_chk(self->mStartMotionPath_)) getCenterWithDouble:p withIntArray:self->mInterpolateVariables_ withDoubleArray:self->mInterpolateData_ withFloatArray:points withInt:0];
    if (i > 0) {
      JrePlusAssignFloatD(&sum, JavaLangMath_hypotWithDouble_withDouble_(y - IOSFloatArray_Get(points, 1), x - IOSFloatArray_Get(points, 0)));
    }
    x = IOSFloatArray_Get(points, 0);
    y = IOSFloatArray_Get(points, 1);
  }
  return sum;
}

void ADXMotion_insertKeyWithADXMotionPaths_(ADXMotion *self, ADXMotionPaths *point) {
  ADXMotionPaths *redundant = nil;
  for (ADXMotionPaths * __strong p in nil_chk(self->mMotionPaths_)) {
    if (((ADXMotionPaths *) nil_chk(point))->position_ == ((ADXMotionPaths *) nil_chk(p))->position_) {
      redundant = p;
    }
  }
  if (redundant != nil) {
    [self->mMotionPaths_ removeWithId:redundant];
  }
  jint pos = JavaUtilCollections_binarySearchWithJavaUtilList_withId_(self->mMotionPaths_, point);
  if (pos == 0) {
    ADXUtils_logeWithNSString_withNSString_(ADXMotion_TAG, JreStrcat("$F$", @" KeyPath position \"", ((ADXMotionPaths *) nil_chk(point))->position_, @"\" outside of range"));
  }
  [((JavaUtilArrayList *) nil_chk(self->mMotionPaths_)) addWithInt:-pos - 1 withId:point];
}

void ADXMotion_readViewWithADXMotionPaths_(ADXMotion *self, ADXMotionPaths *motionPaths) {
  [((ADXMotionPaths *) nil_chk(motionPaths)) setBoundsWithFloat:(jint) [((ADXMotionWidget *) nil_chk(self->mView_)) getX] withFloat:(jint) [((ADXMotionWidget *) nil_chk(self->mView_)) getY] withFloat:[((ADXMotionWidget *) nil_chk(self->mView_)) getWidth] withFloat:[((ADXMotionWidget *) nil_chk(self->mView_)) getHeight]];
}

id<ADXDifferentialInterpolator> ADXMotion_getInterpolatorWithInt_withNSString_withInt_(jint type, NSString *interpolatorString, jint id_) {
  ADXMotion_initialize();
  {
    ADXEasing *easing;
    switch (type) {
      case ADXMotion_SPLINE_STRING:
      easing = ADXEasing_getInterpolatorWithNSString_(interpolatorString);
      return create_ADXMotion_1_initWithADXEasing_(easing);
    }
  }
  return nil;
}

jfloat ADXMotion_getAdjustedPositionWithFloat_withFloatArray_(ADXMotion *self, jfloat position, IOSFloatArray *velocity) {
  if (velocity != nil) {
    *IOSFloatArray_GetRef(velocity, 0) = 1;
  }
  else if (self->mStaggerScale_ != 1.0) {
    if (position < self->mStaggerOffset_) {
      position = 0;
    }
    if (position > self->mStaggerOffset_ && position < 1.0) {
      JreMinusAssignFloatF(&position, self->mStaggerOffset_);
      JreTimesAssignFloatF(&position, self->mStaggerScale_);
      position = JavaLangMath_minWithFloat_withFloat_(position, 1.0f);
    }
  }
  jfloat adjusted = position;
  ADXEasing *easing = JreRetainedLocalValue(((ADXMotionPaths *) nil_chk(self->mStartMotionPath_))->mKeyFrameEasing_);
  jfloat start = 0;
  jfloat end = JavaLangFloat_NaN;
  for (ADXMotionPaths * __strong frame in nil_chk(self->mMotionPaths_)) {
    if (((ADXMotionPaths *) nil_chk(frame))->mKeyFrameEasing_ != nil) {
      if (frame->time_ < position) {
        easing = frame->mKeyFrameEasing_;
        start = frame->time_;
      }
      else {
        if (JavaLangFloat_isNaNWithFloat_(end)) {
          end = frame->time_;
        }
      }
    }
  }
  if (easing != nil) {
    if (JavaLangFloat_isNaNWithFloat_(end)) {
      end = 1.0f;
    }
    jfloat offset = (position - start) / (end - start);
    jfloat new_offset = (jfloat) [easing getWithDouble:offset];
    adjusted = new_offset * (end - start) + start;
    if (velocity != nil) {
      *IOSFloatArray_GetRef(velocity, 0) = (jfloat) [easing getDiffWithDouble:offset];
    }
  }
  return adjusted;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXMotion)

@implementation ADXMotion_1

- (instancetype)initWithADXEasing:(ADXEasing *)capture$0 {
  ADXMotion_1_initWithADXEasing_(self, capture$0);
  return self;
}

- (jfloat)getInterpolationWithFloat:(jfloat)x {
  mX_ = x;
  return (jfloat) [((ADXEasing *) nil_chk(val$easing_)) getWithDouble:x];
}

- (jfloat)getVelocity {
  return (jfloat) [((ADXEasing *) nil_chk(val$easing_)) getDiffWithDouble:mX_];
}

- (void)dealloc {
  RELEASE_(val$easing_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "F", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADXEasing:);
  methods[1].selector = @selector(getInterpolationWithFloat:);
  methods[2].selector = @selector(getVelocity);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$easing_", "LADXEasing;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "mX_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADXEasing;", "getInterpolation", "F", "LADXMotion;", "getInterpolatorWithInt:withNSString:withInt:" };
  static const J2ObjcClassInfo _ADXMotion_1 = { "", "androidx.constraintlayout.core.motion", ptrTable, methods, fields, 7, 0x8018, 3, 2, 3, -1, 4, -1, -1 };
  return &_ADXMotion_1;
}

@end

void ADXMotion_1_initWithADXEasing_(ADXMotion_1 *self, ADXEasing *capture$0) {
  JreStrongAssign(&self->val$easing_, capture$0);
  NSObject_init(self);
}

ADXMotion_1 *new_ADXMotion_1_initWithADXEasing_(ADXEasing *capture$0) {
  J2OBJC_NEW_IMPL(ADXMotion_1, initWithADXEasing_, capture$0)
}

ADXMotion_1 *create_ADXMotion_1_initWithADXEasing_(ADXEasing *capture$0) {
  J2OBJC_CREATE_IMPL(ADXMotion_1, initWithADXEasing_, capture$0)
}
