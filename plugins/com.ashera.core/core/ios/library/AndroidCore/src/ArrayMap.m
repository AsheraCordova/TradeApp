//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroid\src\main\java\r\android\util\ArrayMap.java
//

#include "ArrayMap.h"
#include "ContainerHelpers.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "MapCollections.h"
#include "java/lang/ClassCastException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/lang/Throwable.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/Collection.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/function/BiConsumer.h"
#include "java/util/function/BiFunction.h"
#include "java/util/function/Function.h"

@protocol JavaUtilMap;


@interface ADArrayMap ()

- (void)allocArraysWithInt:(jint)size OBJC_METHOD_FAMILY_NONE;

+ (void)freeArraysWithIntArray:(IOSIntArray *)hashes
             withNSObjectArray:(IOSObjectArray *)array
                       withInt:(jint)size;

- (instancetype)initWithBoolean:(jboolean)immutable;

- (ADMapCollections *)getCollection;

@end

inline jboolean ADArrayMap_get_DEBUG(void);
#define ADArrayMap_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADArrayMap, DEBUG, jboolean)

inline NSString *ADArrayMap_get_TAG(void);
static NSString *ADArrayMap_TAG = @"ArrayMap";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADArrayMap, TAG, NSString *)

/*!
 @brief The minimum amount by which the capacity of a ArrayMap will increase.
 This is tuned to be relatively space-efficient.
 */
inline jint ADArrayMap_get_BASE_SIZE(void);
#define ADArrayMap_BASE_SIZE 4
J2OBJC_STATIC_FIELD_CONSTANT(ADArrayMap, BASE_SIZE, jint)

/*!
 @brief Maximum number of entries to have in array caches.
 */
inline jint ADArrayMap_get_CACHE_SIZE(void);
#define ADArrayMap_CACHE_SIZE 10
J2OBJC_STATIC_FIELD_CONSTANT(ADArrayMap, CACHE_SIZE, jint)

__attribute__((unused)) static void ADArrayMap_allocArraysWithInt_(ADArrayMap *self, jint size);

__attribute__((unused)) static void ADArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(IOSIntArray *hashes, IOSObjectArray *array, jint size);

__attribute__((unused)) static void ADArrayMap_initWithBoolean_(ADArrayMap *self, jboolean immutable);

__attribute__((unused)) static ADArrayMap *new_ADArrayMap_initWithBoolean_(jboolean immutable) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADArrayMap *create_ADArrayMap_initWithBoolean_(jboolean immutable);

__attribute__((unused)) static ADMapCollections *ADArrayMap_getCollection(ADArrayMap *self);

@interface ADArrayMap_ArraMapMapCollections : ADMapCollections {
 @public
  __unsafe_unretained ADArrayMap *this$0_;
}

- (instancetype)initWithADArrayMap:(ADArrayMap *)outer$;

- (jint)colGetSize;

- (id)colGetEntryWithInt:(jint)index
                 withInt:(jint)offset;

- (jint)colIndexOfKeyWithId:(id)key;

- (jint)colIndexOfValueWithId:(id)value;

- (id<JavaUtilMap>)colGetMap;

- (void)colPutWithId:(id)key
              withId:(id)value;

- (id)colSetValueWithInt:(jint)index
                  withId:(id)value;

- (void)colRemoveAtWithInt:(jint)index;

- (void)colClear;

@end

J2OBJC_EMPTY_STATIC_INIT(ADArrayMap_ArraMapMapCollections)

__attribute__((unused)) static void ADArrayMap_ArraMapMapCollections_initWithADArrayMap_(ADArrayMap_ArraMapMapCollections *self, ADArrayMap *outer$);

__attribute__((unused)) static ADArrayMap_ArraMapMapCollections *new_ADArrayMap_ArraMapMapCollections_initWithADArrayMap_(ADArrayMap *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADArrayMap_ArraMapMapCollections *create_ADArrayMap_ArraMapMapCollections_initWithADArrayMap_(ADArrayMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(ADArrayMap_ArraMapMapCollections)

J2OBJC_INITIALIZED_DEFN(ADArrayMap)

ADArrayMap *ADArrayMap_EMPTY;
IOSObjectArray *ADArrayMap_mBaseCache;
jint ADArrayMap_mBaseCacheSize;
IOSObjectArray *ADArrayMap_mTwiceBaseCache;
jint ADArrayMap_mTwiceBaseCacheSize;
IOSIntArray *ADArrayMap_EMPTY_IMMUTABLE_INTS;

@implementation ADArrayMap

- (jint)indexOfWithId:(id)key
              withInt:(jint)hash_ {
  jint N = mSize_;
  if (N == 0) {
    return ~0;
  }
  jint index = ADContainerHelpers_binarySearchWithIntArray_withInt_withInt_(mHashes_, N, hash_);
  if (index < 0) {
    return index;
  }
  if ([nil_chk(key) isEqual:IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(index, 1))]) {
    return index;
  }
  jint end;
  for (end = index + 1; end < N && IOSIntArray_Get(nil_chk(mHashes_), end) == hash_; end++) {
    if ([key isEqual:IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(end, 1))]) return end;
  }
  for (jint i = index - 1; i >= 0 && IOSIntArray_Get(nil_chk(mHashes_), i) == hash_; i--) {
    if ([key isEqual:IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(i, 1))]) return i;
  }
  return ~end;
}

- (jint)indexOfNull {
  jint N = mSize_;
  if (N == 0) {
    return ~0;
  }
  jint index = ADContainerHelpers_binarySearchWithIntArray_withInt_withInt_(mHashes_, N, 0);
  if (index < 0) {
    return index;
  }
  if (nil == IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(index, 1))) {
    return index;
  }
  jint end;
  for (end = index + 1; end < N && IOSIntArray_Get(nil_chk(mHashes_), end) == 0; end++) {
    if (nil == IOSObjectArray_Get(mArray_, JreLShift32(end, 1))) return end;
  }
  for (jint i = index - 1; i >= 0 && IOSIntArray_Get(nil_chk(mHashes_), i) == 0; i--) {
    if (nil == IOSObjectArray_Get(mArray_, JreLShift32(i, 1))) return i;
  }
  return ~end;
}

- (void)allocArraysWithInt:(jint)size {
  ADArrayMap_allocArraysWithInt_(self, size);
}

+ (void)freeArraysWithIntArray:(IOSIntArray *)hashes
             withNSObjectArray:(IOSObjectArray *)array
                       withInt:(jint)size {
  ADArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(hashes, array, size);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADArrayMap_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithInt:(jint)capacity {
  ADArrayMap_initWithInt_(self, capacity);
  return self;
}

- (instancetype)initWithBoolean:(jboolean)immutable {
  ADArrayMap_initWithBoolean_(self, immutable);
  return self;
}

- (instancetype)initWithADArrayMap:(ADArrayMap *)map {
  ADArrayMap_initWithADArrayMap_(self, map);
  return self;
}

- (void)clear {
  if (mSize_ > 0) {
    ADArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(mHashes_, mArray_, mSize_);
    JreStrongAssignAndConsume(&mHashes_, [IOSIntArray newArrayWithLength:0]);
    JreStrongAssignAndConsume(&mArray_, [IOSObjectArray newArrayWithLength:0 type:NSObject_class_()]);
    mSize_ = 0;
  }
}

- (void)erase {
  if (mSize_ > 0) {
    jint N = JreLShift32(mSize_, 1);
    IOSObjectArray *array = mArray_;
    for (jint i = 0; i < N; i++) {
      IOSObjectArray_Set(nil_chk(array), i, nil);
    }
    mSize_ = 0;
  }
}

- (void)ensureCapacityWithInt:(jint)minimumCapacity {
  if (((IOSIntArray *) nil_chk(mHashes_))->size_ < minimumCapacity) {
    IOSIntArray *ohashes = mHashes_;
    IOSObjectArray *oarray = mArray_;
    ADArrayMap_allocArraysWithInt_(self, minimumCapacity);
    if (mSize_ > 0) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ohashes, 0, mHashes_, 0, mSize_);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(oarray, 0, mArray_, 0, JreLShift32(mSize_, 1));
    }
    ADArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(ohashes, oarray, mSize_);
  }
}

- (jboolean)containsKeyWithId:(id)key {
  return [self indexOfKeyWithId:key] >= 0;
}

- (jint)indexOfKeyWithId:(id)key {
  return key == nil ? [self indexOfNull] : [self indexOfWithId:key withInt:((jint) [key hash])];
}

- (jint)indexOfValueWithId:(id)value {
  jint N = mSize_ * 2;
  IOSObjectArray *array = mArray_;
  if (value == nil) {
    for (jint i = 1; i < N; i += 2) {
      if (IOSObjectArray_Get(nil_chk(array), i) == nil) {
        return JreRShift32(i, 1);
      }
    }
  }
  else {
    for (jint i = 1; i < N; i += 2) {
      if ([value isEqual:IOSObjectArray_Get(nil_chk(array), i)]) {
        return JreRShift32(i, 1);
      }
    }
  }
  return -1;
}

- (jboolean)containsValueWithId:(id)value {
  return [self indexOfValueWithId:value] >= 0;
}

- (id)getWithId:(id)key {
  jint index = [self indexOfKeyWithId:key];
  return index >= 0 ? IOSObjectArray_Get(nil_chk(mArray_), (JreLShift32(index, 1)) + 1) : nil;
}

- (id)keyAtWithInt:(jint)index {
  return IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(index, 1));
}

- (id)valueAtWithInt:(jint)index {
  return IOSObjectArray_Get(nil_chk(mArray_), (JreLShift32(index, 1)) + 1);
}

- (id)setValueAtWithInt:(jint)index
                 withId:(id)value {
  index = (JreLShift32(index, 1)) + 1;
  id old = IOSObjectArray_Get(nil_chk(mArray_), index);
  IOSObjectArray_Set(mArray_, index, value);
  return old;
}

- (jboolean)isEmpty {
  return mSize_ <= 0;
}

- (id)putWithId:(id)key
         withId:(id)value {
  jint hash_;
  jint index;
  if (key == nil) {
    hash_ = 0;
    index = [self indexOfNull];
  }
  else {
    hash_ = ((jint) [key hash]);
    index = [self indexOfWithId:key withInt:hash_];
  }
  if (index >= 0) {
    index = (JreLShift32(index, 1)) + 1;
    id old = IOSObjectArray_Get(nil_chk(mArray_), index);
    IOSObjectArray_Set(mArray_, index, value);
    return old;
  }
  index = ~index;
  if (mSize_ >= ((IOSIntArray *) nil_chk(mHashes_))->size_) {
    jint n = mSize_ >= (ADArrayMap_BASE_SIZE * 2) ? (mSize_ + (JreRShift32(mSize_, 1))) : (mSize_ >= ADArrayMap_BASE_SIZE ? (ADArrayMap_BASE_SIZE * 2) : ADArrayMap_BASE_SIZE);
    IOSIntArray *ohashes = mHashes_;
    IOSObjectArray *oarray = mArray_;
    ADArrayMap_allocArraysWithInt_(self, n);
    if (((IOSIntArray *) nil_chk(mHashes_))->size_ > 0) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ohashes, 0, mHashes_, 0, ohashes->size_);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(oarray, 0, mArray_, 0, ((IOSObjectArray *) nil_chk(oarray))->size_);
    }
    ADArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(ohashes, oarray, mSize_);
  }
  if (index < mSize_) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mHashes_, index, mHashes_, index + 1, mSize_ - index);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mArray_, JreLShift32(index, 1), mArray_, JreLShift32((index + 1), 1), JreLShift32((mSize_ - index), 1));
  }
  *IOSIntArray_GetRef(nil_chk(mHashes_), index) = hash_;
  IOSObjectArray_Set(nil_chk(mArray_), JreLShift32(index, 1), key);
  IOSObjectArray_Set(mArray_, (JreLShift32(index, 1)) + 1, value);
  mSize_++;
  return nil;
}

- (void)appendWithId:(id)key
              withId:(id)value {
  jint index = mSize_;
  jint hash_ = key == nil ? 0 : ((jint) [key hash]);
  if (index >= ((IOSIntArray *) nil_chk(mHashes_))->size_) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Array is full");
  }
  if (index > 0 && IOSIntArray_Get(mHashes_, index - 1) > hash_) {
    JavaLangRuntimeException *e = create_JavaLangRuntimeException_initWithNSString_(@"here");
    [e fillInStackTrace];
    [self putWithId:key withId:value];
    return;
  }
  mSize_ = index + 1;
  *IOSIntArray_GetRef(mHashes_, index) = hash_;
  JreLShiftAssignInt(&index, 1);
  IOSObjectArray_Set(nil_chk(mArray_), index, key);
  IOSObjectArray_Set(mArray_, index + 1, value);
}

- (void)validate {
  jint N = mSize_;
  if (N <= 1) {
    return;
  }
  jint basehash = IOSIntArray_Get(nil_chk(mHashes_), 0);
  jint basei = 0;
  for (jint i = 1; i < N; i++) {
    jint hash_ = IOSIntArray_Get(nil_chk(mHashes_), i);
    if (hash_ != basehash) {
      basehash = hash_;
      basei = i;
      continue;
    }
    id cur = IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(i, 1));
    for (jint j = i - 1; j >= basei; j--) {
      id prev = IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(j, 1));
      if (cur == prev) {
        @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@", @"Duplicate key in ArrayMap: ", cur));
      }
      if (cur != nil && prev != nil && [cur isEqual:prev]) {
        @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@", @"Duplicate key in ArrayMap: ", cur));
      }
    }
  }
}

- (void)putAllWithADArrayMap:(ADArrayMap *)array {
  jint N = ((ADArrayMap *) nil_chk(array))->mSize_;
  [self ensureCapacityWithInt:mSize_ + N];
  if (mSize_ == 0) {
    if (N > 0) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(array->mHashes_, 0, mHashes_, 0, N);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(array->mArray_, 0, mArray_, 0, JreLShift32(N, 1));
      mSize_ = N;
    }
  }
  else {
    for (jint i = 0; i < N; i++) {
      [self putWithId:[array keyAtWithInt:i] withId:[array valueAtWithInt:i]];
    }
  }
}

- (id)removeWithId:(id)key {
  jint index = [self indexOfKeyWithId:key];
  if (index >= 0) {
    return [self removeAtWithInt:index];
  }
  return nil;
}

- (id)removeAtWithInt:(jint)index {
  id old = IOSObjectArray_Get(nil_chk(mArray_), (JreLShift32(index, 1)) + 1);
  if (mSize_ <= 1) {
    ADArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(mHashes_, mArray_, mSize_);
    JreStrongAssignAndConsume(&mHashes_, [IOSIntArray newArrayWithLength:0]);
    JreStrongAssignAndConsume(&mArray_, [IOSObjectArray newArrayWithLength:0 type:NSObject_class_()]);
    mSize_ = 0;
  }
  else {
    if (((IOSIntArray *) nil_chk(mHashes_))->size_ > (ADArrayMap_BASE_SIZE * 2) && mSize_ < JreIntDiv(mHashes_->size_, 3)) {
      jint n = mSize_ > (ADArrayMap_BASE_SIZE * 2) ? (mSize_ + (JreRShift32(mSize_, 1))) : (ADArrayMap_BASE_SIZE * 2);
      IOSIntArray *ohashes = mHashes_;
      IOSObjectArray *oarray = mArray_;
      ADArrayMap_allocArraysWithInt_(self, n);
      mSize_--;
      if (index > 0) {
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ohashes, 0, mHashes_, 0, index);
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(oarray, 0, mArray_, 0, JreLShift32(index, 1));
      }
      if (index < mSize_) {
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ohashes, index + 1, mHashes_, index, mSize_ - index);
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(oarray, JreLShift32((index + 1), 1), mArray_, JreLShift32(index, 1), JreLShift32((mSize_ - index), 1));
      }
    }
    else {
      mSize_--;
      if (index < mSize_) {
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mHashes_, index + 1, mHashes_, index, mSize_ - index);
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mArray_, JreLShift32((index + 1), 1), mArray_, JreLShift32(index, 1), JreLShift32((mSize_ - index), 1));
      }
      IOSObjectArray_Set(nil_chk(mArray_), JreLShift32(mSize_, 1), nil);
      IOSObjectArray_Set(mArray_, (JreLShift32(mSize_, 1)) + 1, nil);
    }
  }
  return old;
}

- (jint)size {
  return mSize_;
}

- (jboolean)isEqual:(id)object {
  if (self == object) {
    return true;
  }
  if ([JavaUtilMap_class_() isInstance:object]) {
    id<JavaUtilMap> map = (id<JavaUtilMap>) cast_check(object, JavaUtilMap_class_());
    if ([self size] != [((id<JavaUtilMap>) nil_chk(map)) size]) {
      return false;
    }
    @try {
      for (jint i = 0; i < mSize_; i++) {
        id key = JreRetainedLocalValue([self keyAtWithInt:i]);
        id mine = JreRetainedLocalValue([self valueAtWithInt:i]);
        id theirs = JreRetainedLocalValue([map getWithId:key]);
        if (mine == nil) {
          if (theirs != nil || ![map containsKeyWithId:key]) {
            return false;
          }
        }
        else if (![mine isEqual:theirs]) {
          return false;
        }
      }
    }
    @catch (JavaLangNullPointerException *ignored) {
      return false;
    }
    @catch (JavaLangClassCastException *ignored) {
      return false;
    }
    return true;
  }
  return false;
}

- (NSUInteger)hash {
  IOSIntArray *hashes = mHashes_;
  IOSObjectArray *array = mArray_;
  jint result = 0;
  for (jint i = 0, v = 1, s = mSize_; i < s; i++, v += 2) {
    id value = IOSObjectArray_Get(nil_chk(array), v);
    result += IOSIntArray_Get(nil_chk(hashes), i) ^ (value == nil ? 0 : ((jint) [value hash]));
  }
  return result;
}

- (NSString *)description {
  if ([self isEmpty]) {
    return @"{}";
  }
  JavaLangStringBuilder *buffer = create_JavaLangStringBuilder_initWithInt_(mSize_ * 28);
  [buffer appendWithChar:'{'];
  for (jint i = 0; i < mSize_; i++) {
    if (i > 0) {
      [buffer appendWithNSString:@", "];
    }
    id key = JreRetainedLocalValue([self keyAtWithInt:i]);
    if (key != self) {
      [buffer appendWithId:key];
    }
    else {
      [buffer appendWithNSString:@"(this Map)"];
    }
    [buffer appendWithChar:'='];
    id value = JreRetainedLocalValue([self valueAtWithInt:i]);
    if (value != self) {
      [buffer appendWithId:value];
    }
    else {
      [buffer appendWithNSString:@"(this Map)"];
    }
  }
  [buffer appendWithChar:'}'];
  return [buffer description];
}

- (ADMapCollections *)getCollection {
  return ADArrayMap_getCollection(self);
}

- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection {
  return ADMapCollections_containsAllHelperWithJavaUtilMap_withJavaUtilCollection_(self, collection);
}

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)map {
  [self ensureCapacityWithInt:mSize_ + [((id<JavaUtilMap>) nil_chk(map)) size]];
  for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([map entrySet])) {
    [self putWithId:[((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey] withId:[entry_ getValue]];
  }
}

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection {
  return ADMapCollections_removeAllHelperWithJavaUtilMap_withJavaUtilCollection_(self, collection);
}

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection {
  return ADMapCollections_retainAllHelperWithJavaUtilMap_withJavaUtilCollection_(self, collection);
}

- (id<JavaUtilSet>)entrySet {
  return [((ADMapCollections *) nil_chk(ADArrayMap_getCollection(self))) getEntrySet];
}

- (id<JavaUtilSet>)keySet {
  return [((ADMapCollections *) nil_chk(ADArrayMap_getCollection(self))) getKeySet];
}

- (id<JavaUtilCollection>)values {
  return [((ADMapCollections *) nil_chk(ADArrayMap_getCollection(self))) getValues];
}

- (id)getOrDefaultWithId:(id)arg0
                  withId:(id)arg1 {
  return JavaUtilMap_getOrDefaultWithId_withId_(self, arg0, arg1);
}

- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)arg0 {
  JavaUtilMap_forEachWithJavaUtilFunctionBiConsumer_(self, arg0);
}

- (void)replaceAllWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)arg0 {
  JavaUtilMap_replaceAllWithJavaUtilFunctionBiFunction_(self, arg0);
}

- (id)putIfAbsentWithId:(id)arg0
                 withId:(id)arg1 {
  return JavaUtilMap_putIfAbsentWithId_withId_(self, arg0, arg1);
}

- (jboolean)removeWithId:(id)arg0
                  withId:(id)arg1 {
  return JavaUtilMap_removeWithId_withId_(self, arg0, arg1);
}

- (jboolean)replaceWithId:(id)arg0
                   withId:(id)arg1
                   withId:(id)arg2 {
  return JavaUtilMap_replaceWithId_withId_withId_(self, arg0, arg1, arg2);
}

- (id)replaceWithId:(id)arg0
             withId:(id)arg1 {
  return JavaUtilMap_replaceWithId_withId_(self, arg0, arg1);
}

- (id)computeIfAbsentWithId:(id)arg0
withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg1 {
  return JavaUtilMap_computeIfAbsentWithId_withJavaUtilFunctionFunction_(self, arg0, arg1);
}

- (id)computeIfPresentWithId:(id)arg0
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)arg1 {
  return JavaUtilMap_computeIfPresentWithId_withJavaUtilFunctionBiFunction_(self, arg0, arg1);
}

- (id)computeWithId:(id)arg0
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)arg1 {
  return JavaUtilMap_computeWithId_withJavaUtilFunctionBiFunction_(self, arg0, arg1);
}

- (id)mergeWithId:(id)arg0
           withId:(id)arg1
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)arg2 {
  return JavaUtilMap_mergeWithId_withId_withJavaUtilFunctionBiFunction_(self, arg0, arg1, arg2);
}

- (void)dealloc {
  RELEASE_(mHashes_);
  RELEASE_(mArray_);
  RELEASE_(mCollections_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "I", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 4, 5, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 3, -1, -1, -1, -1 },
    { NULL, NULL, 0x2, -1, 6, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 7, -1, 8, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 12, 11, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 13, 11, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 14, 11, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 15, 11, -1, 16, -1, -1 },
    { NULL, "LNSObject;", 0x1, 17, 3, -1, 18, -1, -1 },
    { NULL, "LNSObject;", 0x1, 19, 3, -1, 20, -1, -1 },
    { NULL, "LNSObject;", 0x1, 21, 22, -1, 23, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 24, 25, -1, 26, -1, -1 },
    { NULL, "V", 0x1, 27, 25, -1, 28, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 29, 7, -1, 30, -1, -1 },
    { NULL, "LNSObject;", 0x1, 31, 11, -1, 16, -1, -1 },
    { NULL, "LNSObject;", 0x1, 32, 3, -1, 20, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 33, 11, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 34, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 35, -1, -1, -1, -1, -1 },
    { NULL, "LADMapCollections;", 0x2, -1, -1, -1, 36, -1, -1 },
    { NULL, "Z", 0x1, 37, 38, -1, 39, -1, -1 },
    { NULL, "V", 0x1, 29, 40, -1, 41, -1, -1 },
    { NULL, "Z", 0x1, 42, 38, -1, 39, -1, -1 },
    { NULL, "Z", 0x1, 43, 38, -1, 39, -1, -1 },
    { NULL, "LJavaUtilSet;", 0x1, -1, -1, -1, 44, -1, -1 },
    { NULL, "LJavaUtilSet;", 0x1, -1, -1, -1, 45, -1, -1 },
    { NULL, "LJavaUtilCollection;", 0x1, -1, -1, -1, 46, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(indexOfWithId:withInt:);
  methods[1].selector = @selector(indexOfNull);
  methods[2].selector = @selector(allocArraysWithInt:);
  methods[3].selector = @selector(freeArraysWithIntArray:withNSObjectArray:withInt:);
  methods[4].selector = @selector(init);
  methods[5].selector = @selector(initWithInt:);
  methods[6].selector = @selector(initWithBoolean:);
  methods[7].selector = @selector(initWithADArrayMap:);
  methods[8].selector = @selector(clear);
  methods[9].selector = @selector(erase);
  methods[10].selector = @selector(ensureCapacityWithInt:);
  methods[11].selector = @selector(containsKeyWithId:);
  methods[12].selector = @selector(indexOfKeyWithId:);
  methods[13].selector = @selector(indexOfValueWithId:);
  methods[14].selector = @selector(containsValueWithId:);
  methods[15].selector = @selector(getWithId:);
  methods[16].selector = @selector(keyAtWithInt:);
  methods[17].selector = @selector(valueAtWithInt:);
  methods[18].selector = @selector(setValueAtWithInt:withId:);
  methods[19].selector = @selector(isEmpty);
  methods[20].selector = @selector(putWithId:withId:);
  methods[21].selector = @selector(appendWithId:withId:);
  methods[22].selector = @selector(validate);
  methods[23].selector = @selector(putAllWithADArrayMap:);
  methods[24].selector = @selector(removeWithId:);
  methods[25].selector = @selector(removeAtWithInt:);
  methods[26].selector = @selector(size);
  methods[27].selector = @selector(isEqual:);
  methods[28].selector = @selector(hash);
  methods[29].selector = @selector(description);
  methods[30].selector = @selector(getCollection);
  methods[31].selector = @selector(containsAllWithJavaUtilCollection:);
  methods[32].selector = @selector(putAllWithJavaUtilMap:);
  methods[33].selector = @selector(removeAllWithJavaUtilCollection:);
  methods[34].selector = @selector(retainAllWithJavaUtilCollection:);
  methods[35].selector = @selector(entrySet);
  methods[36].selector = @selector(keySet);
  methods[37].selector = @selector(values);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEBUG", "Z", .constantValue.asBOOL = ADArrayMap_DEBUG, 0x1a, -1, -1, -1, -1 },
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 47, -1, -1 },
    { "BASE_SIZE", "I", .constantValue.asInt = ADArrayMap_BASE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "CACHE_SIZE", "I", .constantValue.asInt = ADArrayMap_CACHE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "EMPTY", "LADArrayMap;", .constantValue.asLong = 0, 0x19, -1, 48, -1, -1 },
    { "mBaseCache", "[LNSObject;", .constantValue.asLong = 0, 0x8, -1, 49, -1, -1 },
    { "mBaseCacheSize", "I", .constantValue.asLong = 0, 0x8, -1, 50, -1, -1 },
    { "mTwiceBaseCache", "[LNSObject;", .constantValue.asLong = 0, 0x8, -1, 51, -1, -1 },
    { "mTwiceBaseCacheSize", "I", .constantValue.asLong = 0, 0x8, -1, 52, -1, -1 },
    { "EMPTY_IMMUTABLE_INTS", "[I", .constantValue.asLong = 0, 0x18, -1, 53, -1, -1 },
    { "mHashes_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mArray_", "[LNSObject;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mSize_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCollections_", "LADMapCollections;", .constantValue.asLong = 0, 0x0, -1, -1, 54, -1 },
  };
  static const void *ptrTable[] = { "indexOf", "LNSObject;I", "allocArrays", "I", "freeArrays", "[I[LNSObject;I", "Z", "LADArrayMap;", "(Lr/android/util/ArrayMap<TK;TV;>;)V", "ensureCapacity", "containsKey", "LNSObject;", "indexOfKey", "indexOfValue", "containsValue", "get", "(Ljava/lang/Object;)TV;", "keyAt", "(I)TK;", "valueAt", "(I)TV;", "setValueAt", "ILNSObject;", "(ITV;)TV;", "put", "LNSObject;LNSObject;", "(TK;TV;)TV;", "append", "(TK;TV;)V", "putAll", "(Lr/android/util/ArrayMap<+TK;+TV;>;)V", "remove", "removeAt", "equals", "hashCode", "toString", "()Lr/android/util/MapCollections<TK;TV;>;", "containsAll", "LJavaUtilCollection;", "(Ljava/util/Collection<*>;)Z", "LJavaUtilMap;", "(Ljava/util/Map<+TK;+TV;>;)V", "removeAll", "retainAll", "()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>;", "()Ljava/util/Set<TK;>;", "()Ljava/util/Collection<TV;>;", &ADArrayMap_TAG, &ADArrayMap_EMPTY, &ADArrayMap_mBaseCache, &ADArrayMap_mBaseCacheSize, &ADArrayMap_mTwiceBaseCache, &ADArrayMap_mTwiceBaseCacheSize, &ADArrayMap_EMPTY_IMMUTABLE_INTS, "Lr/android/util/MapCollections<TK;TV;>;", "LADArrayMap_ArraMapMapCollections;", "<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map<TK;TV;>;" };
  static const J2ObjcClassInfo _ADArrayMap = { "ArrayMap", "r.android.util", ptrTable, methods, fields, 7, 0x11, 38, 14, -1, 55, -1, 56, -1 };
  return &_ADArrayMap;
}

+ (void)initialize {
  if (self == [ADArrayMap class]) {
    JreStrongAssignAndConsume(&ADArrayMap_EMPTY, new_ADArrayMap_initWithBoolean_(true));
    JreStrongAssignAndConsume(&ADArrayMap_EMPTY_IMMUTABLE_INTS, [IOSIntArray newArrayWithLength:0]);
    J2OBJC_SET_INITIALIZED(ADArrayMap)
  }
}

@end

void ADArrayMap_allocArraysWithInt_(ADArrayMap *self, jint size) {
  if (self->mHashes_ == ADArrayMap_EMPTY_IMMUTABLE_INTS) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"ArrayMap is immutable");
  }
  if (size == (ADArrayMap_BASE_SIZE * 2)) {
    @synchronized(ADArrayMap_class_()) {
      if (ADArrayMap_mTwiceBaseCache != nil) {
        IOSObjectArray *array = ADArrayMap_mTwiceBaseCache;
        JreStrongAssign(&self->mArray_, array);
        JreStrongAssign(&ADArrayMap_mTwiceBaseCache, (IOSObjectArray *) cast_check(IOSObjectArray_Get(array, 0), IOSClass_arrayType(NSObject_class_(), 1)));
        JreStrongAssign(&self->mHashes_, (IOSIntArray *) cast_chk(IOSObjectArray_Get(array, 1), [IOSIntArray class]));
        IOSObjectArray_Set(array, 0, IOSObjectArray_Set(array, 1, nil));
        ADArrayMap_mTwiceBaseCacheSize--;
        return;
      }
    }
  }
  else if (size == ADArrayMap_BASE_SIZE) {
    @synchronized(ADArrayMap_class_()) {
      if (ADArrayMap_mBaseCache != nil) {
        IOSObjectArray *array = ADArrayMap_mBaseCache;
        JreStrongAssign(&self->mArray_, array);
        JreStrongAssign(&ADArrayMap_mBaseCache, (IOSObjectArray *) cast_check(IOSObjectArray_Get(array, 0), IOSClass_arrayType(NSObject_class_(), 1)));
        JreStrongAssign(&self->mHashes_, (IOSIntArray *) cast_chk(IOSObjectArray_Get(array, 1), [IOSIntArray class]));
        IOSObjectArray_Set(array, 0, IOSObjectArray_Set(array, 1, nil));
        ADArrayMap_mBaseCacheSize--;
        return;
      }
    }
  }
  JreStrongAssignAndConsume(&self->mHashes_, [IOSIntArray newArrayWithLength:size]);
  JreStrongAssignAndConsume(&self->mArray_, [IOSObjectArray newArrayWithLength:JreLShift32(size, 1) type:NSObject_class_()]);
}

void ADArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(IOSIntArray *hashes, IOSObjectArray *array, jint size) {
  ADArrayMap_initialize();
  if (((IOSIntArray *) nil_chk(hashes))->size_ == (ADArrayMap_BASE_SIZE * 2)) {
    @synchronized(ADArrayMap_class_()) {
      if (ADArrayMap_mTwiceBaseCacheSize < ADArrayMap_CACHE_SIZE) {
        IOSObjectArray_Set(nil_chk(array), 0, ADArrayMap_mTwiceBaseCache);
        IOSObjectArray_Set(array, 1, hashes);
        for (jint i = (JreLShift32(size, 1)) - 1; i >= 2; i--) {
          IOSObjectArray_Set(array, i, nil);
        }
        JreStrongAssign(&ADArrayMap_mTwiceBaseCache, array);
        ADArrayMap_mTwiceBaseCacheSize++;
      }
    }
  }
  else if (hashes->size_ == ADArrayMap_BASE_SIZE) {
    @synchronized(ADArrayMap_class_()) {
      if (ADArrayMap_mBaseCacheSize < ADArrayMap_CACHE_SIZE) {
        IOSObjectArray_Set(nil_chk(array), 0, ADArrayMap_mBaseCache);
        IOSObjectArray_Set(array, 1, hashes);
        for (jint i = (JreLShift32(size, 1)) - 1; i >= 2; i--) {
          IOSObjectArray_Set(array, i, nil);
        }
        JreStrongAssign(&ADArrayMap_mBaseCache, array);
        ADArrayMap_mBaseCacheSize++;
      }
    }
  }
}

void ADArrayMap_init(ADArrayMap *self) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->mHashes_, [IOSIntArray newArrayWithLength:0]);
  JreStrongAssignAndConsume(&self->mArray_, [IOSObjectArray newArrayWithLength:0 type:NSObject_class_()]);
  self->mSize_ = 0;
}

ADArrayMap *new_ADArrayMap_init() {
  J2OBJC_NEW_IMPL(ADArrayMap, init)
}

ADArrayMap *create_ADArrayMap_init() {
  J2OBJC_CREATE_IMPL(ADArrayMap, init)
}

void ADArrayMap_initWithInt_(ADArrayMap *self, jint capacity) {
  NSObject_init(self);
  if (capacity == 0) {
    JreStrongAssignAndConsume(&self->mHashes_, [IOSIntArray newArrayWithLength:0]);
    JreStrongAssignAndConsume(&self->mArray_, [IOSObjectArray newArrayWithLength:0 type:NSObject_class_()]);
  }
  else {
    ADArrayMap_allocArraysWithInt_(self, capacity);
  }
  self->mSize_ = 0;
}

ADArrayMap *new_ADArrayMap_initWithInt_(jint capacity) {
  J2OBJC_NEW_IMPL(ADArrayMap, initWithInt_, capacity)
}

ADArrayMap *create_ADArrayMap_initWithInt_(jint capacity) {
  J2OBJC_CREATE_IMPL(ADArrayMap, initWithInt_, capacity)
}

void ADArrayMap_initWithBoolean_(ADArrayMap *self, jboolean immutable) {
  NSObject_init(self);
  JreStrongAssign(&self->mHashes_, immutable ? ADArrayMap_EMPTY_IMMUTABLE_INTS : [IOSIntArray arrayWithLength:0]);
  JreStrongAssignAndConsume(&self->mArray_, [IOSObjectArray newArrayWithLength:0 type:NSObject_class_()]);
  self->mSize_ = 0;
}

ADArrayMap *new_ADArrayMap_initWithBoolean_(jboolean immutable) {
  J2OBJC_NEW_IMPL(ADArrayMap, initWithBoolean_, immutable)
}

ADArrayMap *create_ADArrayMap_initWithBoolean_(jboolean immutable) {
  J2OBJC_CREATE_IMPL(ADArrayMap, initWithBoolean_, immutable)
}

void ADArrayMap_initWithADArrayMap_(ADArrayMap *self, ADArrayMap *map) {
  ADArrayMap_init(self);
  if (map != nil) {
    [self putAllWithADArrayMap:map];
  }
}

ADArrayMap *new_ADArrayMap_initWithADArrayMap_(ADArrayMap *map) {
  J2OBJC_NEW_IMPL(ADArrayMap, initWithADArrayMap_, map)
}

ADArrayMap *create_ADArrayMap_initWithADArrayMap_(ADArrayMap *map) {
  J2OBJC_CREATE_IMPL(ADArrayMap, initWithADArrayMap_, map)
}

ADMapCollections *ADArrayMap_getCollection(ADArrayMap *self) {
  if (self->mCollections_ == nil) {
    JreStrongAssignAndConsume(&self->mCollections_, new_ADArrayMap_ArraMapMapCollections_initWithADArrayMap_(self));
  }
  return self->mCollections_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADArrayMap)

@implementation ADArrayMap_ArraMapMapCollections

- (instancetype)initWithADArrayMap:(ADArrayMap *)outer$ {
  ADArrayMap_ArraMapMapCollections_initWithADArrayMap_(self, outer$);
  return self;
}

- (jint)colGetSize {
  return this$0_->mSize_;
}

- (id)colGetEntryWithInt:(jint)index
                 withInt:(jint)offset {
  return IOSObjectArray_Get(nil_chk(this$0_->mArray_), (JreLShift32(index, 1)) + offset);
}

- (jint)colIndexOfKeyWithId:(id)key {
  return [this$0_ indexOfKeyWithId:key];
}

- (jint)colIndexOfValueWithId:(id)value {
  return [this$0_ indexOfValueWithId:value];
}

- (id<JavaUtilMap>)colGetMap {
  return this$0_;
}

- (void)colPutWithId:(id)key
              withId:(id)value {
  [this$0_ putWithId:key withId:value];
}

- (id)colSetValueWithInt:(jint)index
                  withId:(id)value {
  return [this$0_ setValueAtWithInt:index withId:value];
}

- (void)colRemoveAtWithInt:(jint)index {
  [this$0_ removeAtWithInt:index];
}

- (void)colClear {
  [this$0_ clear];
}

- (void)__javaClone:(ADArrayMap_ArraMapMapCollections *)original {
  [super __javaClone:original];
  [this$0_ release];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, 0, -1, -1, -1, -1 },
    { NULL, "I", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x4, 1, 2, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 5, 4, -1, -1, -1, -1 },
    { NULL, "LJavaUtilMap;", 0x4, -1, -1, -1, 6, -1, -1 },
    { NULL, "V", 0x4, 7, 8, -1, 9, -1, -1 },
    { NULL, "LNSObject;", 0x4, 10, 11, -1, 12, -1, -1 },
    { NULL, "V", 0x4, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADArrayMap:);
  methods[1].selector = @selector(colGetSize);
  methods[2].selector = @selector(colGetEntryWithInt:withInt:);
  methods[3].selector = @selector(colIndexOfKeyWithId:);
  methods[4].selector = @selector(colIndexOfValueWithId:);
  methods[5].selector = @selector(colGetMap);
  methods[6].selector = @selector(colPutWithId:withId:);
  methods[7].selector = @selector(colSetValueWithInt:withId:);
  methods[8].selector = @selector(colRemoveAtWithInt:);
  methods[9].selector = @selector(colClear);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LADArrayMap;", .constantValue.asLong = 0, 0x1012, -1, -1, 15, -1 },
  };
  static const void *ptrTable[] = { "LADArrayMap;", "colGetEntry", "II", "colIndexOfKey", "LNSObject;", "colIndexOfValue", "()Ljava/util/Map<TK;TV;>;", "colPut", "LNSObject;LNSObject;", "(TK;TV;)V", "colSetValue", "ILNSObject;", "(ITV;)TV;", "colRemoveAt", "I", "Lr/android/util/ArrayMap<TK;TV;>;", "Lr/android/util/MapCollections<TK;TV;>;" };
  static const J2ObjcClassInfo _ADArrayMap_ArraMapMapCollections = { "ArraMapMapCollections", "r.android.util", ptrTable, methods, fields, 7, 0x12, 10, 1, 0, -1, -1, 16, -1 };
  return &_ADArrayMap_ArraMapMapCollections;
}

@end

void ADArrayMap_ArraMapMapCollections_initWithADArrayMap_(ADArrayMap_ArraMapMapCollections *self, ADArrayMap *outer$) {
  self->this$0_ = outer$;
  ADMapCollections_initPackagePrivate(self);
}

ADArrayMap_ArraMapMapCollections *new_ADArrayMap_ArraMapMapCollections_initWithADArrayMap_(ADArrayMap *outer$) {
  J2OBJC_NEW_IMPL(ADArrayMap_ArraMapMapCollections, initWithADArrayMap_, outer$)
}

ADArrayMap_ArraMapMapCollections *create_ADArrayMap_ArraMapMapCollections_initWithADArrayMap_(ADArrayMap *outer$) {
  J2OBJC_CREATE_IMPL(ADArrayMap_ArraMapMapCollections, initWithADArrayMap_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADArrayMap_ArraMapMapCollections)
