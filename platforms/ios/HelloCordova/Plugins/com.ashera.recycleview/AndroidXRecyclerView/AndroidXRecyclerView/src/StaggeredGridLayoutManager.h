//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXRecyclerView\src\main\java\androidx\recyclerview\widget\StaggeredGridLayoutManager.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_StaggeredGridLayoutManager")
#ifdef RESTRICT_StaggeredGridLayoutManager
#define INCLUDE_ALL_StaggeredGridLayoutManager 0
#else
#define INCLUDE_ALL_StaggeredGridLayoutManager 1
#endif
#undef RESTRICT_StaggeredGridLayoutManager

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ADXStaggeredGridLayoutManager_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager))
#define ADXStaggeredGridLayoutManager_

#define RESTRICT_RecyclerView 1
#define INCLUDE_ADXRecyclerView_LayoutManager 1
#include "RecyclerView.h"

@class ADRect;
@class ADView;
@class ADXOrientationHelper;
@class ADXRecyclerView;
@class ADXRecyclerView_Adapter;
@class ADXRecyclerView_LayoutParams;
@class ADXRecyclerView_Recycler;
@class ADXRecyclerView_State;
@class ADXStaggeredGridLayoutManager_AnchorInfo;
@class ADXStaggeredGridLayoutManager_LazySpanLookup;
@class IOSIntArray;
@class IOSObjectArray;
@protocol ADParcelable;
@protocol ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry;

/*!
 @brief A LayoutManager that lays out children in a staggered grid formation.
 It supports horizontal & vertical layout as well as an ability to layout children in reverse. 
 <p>
  Staggered grids are likely to have gaps at the edges of the layout. To avoid these gaps,
  StaggeredGridLayoutManager can offset spans independently or move items between spans. You can
  control this behavior via <code>setGapStrategy(int)</code>.
 */
@interface ADXStaggeredGridLayoutManager : ADXRecyclerView_LayoutManager {
 @public
  IOSObjectArray *mSpans_;
  /*!
   @brief Primary orientation is the layout's orientation, secondary orientation is the orientation
  for spans.Having both makes code much cleaner for calculations.
   */
  ADXOrientationHelper *mPrimaryOrientation_;
  ADXOrientationHelper *mSecondaryOrientation_;
  jboolean mReverseLayout_;
  /*!
   @brief Aggregated reverse layout value that takes RTL into account.
   */
  jboolean mShouldReverseLayout_;
  /*!
   @brief When LayoutManager needs to scroll to a position, it sets this variable and requests a
  layout which will check this variable and re-layout accordingly.
   */
  jint mPendingScrollPosition_;
  /*!
   @brief Used to keep the offset value when <code>scrollToPositionWithOffset(int, int)</code> is
  called.
   */
  jint mPendingScrollPositionOffset_;
  /*!
   @brief Keeps the mapping between the adapter positions and spans.This is necessary to provide
  a consistent experience when user scrolls the list.
   */
  ADXStaggeredGridLayoutManager_LazySpanLookup *mLazySpanLookup_;
}

#pragma mark Public

/*!
 @brief Constructor used when layout manager is set in XML by RecyclerView attribute
  "layoutManager".Defaults to single column and vertical.
 */
- (instancetype)initWithInt:(jint)spanCount
                    withInt:(jint)orientation;

- (void)assertNotInLayoutOrScrollWithNSString:(NSString *)message;

- (jboolean)canScrollHorizontally;

- (jboolean)canScrollVertically;

- (jboolean)checkLayoutParamsWithADXRecyclerView_LayoutParams:(ADXRecyclerView_LayoutParams *)lp;

/*!
 */
- (void)collectAdjacentPrefetchPositionsWithInt:(jint)dx
                                        withInt:(jint)dy
                      withADXRecyclerView_State:(ADXRecyclerView_State *)state
withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:(id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>)layoutPrefetchRegistry;

- (jint)computeHorizontalScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeHorizontalScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeHorizontalScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeVerticalScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeVerticalScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeVerticalScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 @brief Returns the adapter position of the first completely visible view for each span.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
  views are ignored in this method.
 @param into An array to put the results into. If you don't provide any, LayoutManager will              create a new one.
 @return The adapter position of the first fully visible item in each span. If a span does
  not have any items, <code>RecyclerView.NO_POSITION</code> is returned for that span.
 - seealso: #findFirstVisibleItemPositions(int[])
 - seealso: #findLastCompletelyVisibleItemPositions(int[])
 */
- (IOSIntArray *)findFirstCompletelyVisibleItemPositionsWithIntArray:(IOSIntArray *)into;

/*!
 @brief Returns the adapter position of the first visible view for each span.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
  views are ignored in this method.
 @param into An array to put the results into. If you don't provide any, LayoutManager will              create a new one.
 @return The adapter position of the first visible item in each span. If a span does not have
  any items, <code>RecyclerView.NO_POSITION</code> is returned for that span.
 - seealso: #findFirstCompletelyVisibleItemPositions(int[])
 - seealso: #findLastVisibleItemPositions(int[])
 */
- (IOSIntArray *)findFirstVisibleItemPositionsWithIntArray:(IOSIntArray *)into;

/*!
 @brief Returns the adapter position of the last completely visible view for each span.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
  views are ignored in this method.
 @param into An array to put the results into. If you don't provide any, LayoutManager will              create a new one.
 @return The adapter position of the last fully visible item in each span. If a span does not
  have any items, <code>RecyclerView.NO_POSITION</code> is returned for that span.
 - seealso: #findFirstCompletelyVisibleItemPositions(int[])
 - seealso: #findLastVisibleItemPositions(int[])
 */
- (IOSIntArray *)findLastCompletelyVisibleItemPositionsWithIntArray:(IOSIntArray *)into;

/*!
 @brief Returns the adapter position of the last visible view for each span.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
  views are ignored in this method.
 @param into An array to put the results into. If you don't provide any, LayoutManager will              create a new one.
 @return The adapter position of the last visible item in each span. If a span does not have
  any items, <code>RecyclerView.NO_POSITION</code> is returned for that span.
 - seealso: #findLastCompletelyVisibleItemPositions(int[])
 - seealso: #findFirstVisibleItemPositions(int[])
 */
- (IOSIntArray *)findLastVisibleItemPositionsWithIntArray:(IOSIntArray *)into;

- (ADXRecyclerView_LayoutParams *)generateDefaultLayoutParams;

/*!
 @brief Returns the current gap handling strategy for StaggeredGridLayoutManager.
 <p>
  Staggered grid may have gaps in the layout due to changes in the adapter. To avoid gaps,
  StaggeredGridLayoutManager provides 2 options. Check <code>GAP_HANDLING_NONE</code> and 
 <code>GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS</code> for details. 
 <p>
  By default, StaggeredGridLayoutManager uses <code>GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS</code>.
 @return Current gap handling strategy.
 - seealso: #setGapStrategy(int)
 - seealso: #GAP_HANDLING_NONE
 - seealso: #GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS
 */
- (jint)getGapStrategy;

- (jint)getOrientation;

/*!
 @brief Returns whether views are laid out in reverse order or not.
 <p>
  Not that this value is not affected by RecyclerView's layout direction.
 @return True if layout is reversed, false otherwise
 - seealso: #setReverseLayout(boolean)
 */
- (jboolean)getReverseLayout;

/*!
 @brief Returns the number of spans laid out by StaggeredGridLayoutManager.
 @return Number of spans in the layout
 */
- (jint)getSpanCount;

/*!
 @brief For consistency, StaggeredGridLayoutManager keeps a mapping between spans and items.
 <p>
  If you need to cancel current assignments, you can call this method which will clear all
  assignments and request a new layout.
 */
- (void)invalidateSpanAssignments;

- (jboolean)isAutoMeasureEnabled;

- (void)offsetChildrenHorizontalWithInt:(jint)dx;

- (void)offsetChildrenVerticalWithInt:(jint)dy;

- (void)onAdapterChangedWithADXRecyclerView_Adapter:(ADXRecyclerView_Adapter *)oldAdapter
                        withADXRecyclerView_Adapter:(ADXRecyclerView_Adapter *)newAdapter;

- (void)onDetachedFromWindowWithADXRecyclerView:(ADXRecyclerView *)view
                   withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler;

- (ADView *)onFocusSearchFailedWithADView:(ADView *)focused
                                  withInt:(jint)direction
             withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)onItemsAddedWithADXRecyclerView:(ADXRecyclerView *)recyclerView
                                withInt:(jint)positionStart
                                withInt:(jint)itemCount;

- (void)onItemsChangedWithADXRecyclerView:(ADXRecyclerView *)recyclerView;

- (void)onItemsMovedWithADXRecyclerView:(ADXRecyclerView *)recyclerView
                                withInt:(jint)from
                                withInt:(jint)to
                                withInt:(jint)itemCount;

- (void)onItemsRemovedWithADXRecyclerView:(ADXRecyclerView *)recyclerView
                                  withInt:(jint)positionStart
                                  withInt:(jint)itemCount;

- (void)onItemsUpdatedWithADXRecyclerView:(ADXRecyclerView *)recyclerView
                                  withInt:(jint)positionStart
                                  withInt:(jint)itemCount
                                   withId:(id)payload;

- (void)onLayoutChildrenWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                           withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)onLayoutCompletedWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)onRestoreInstanceStateWithADParcelable:(id<ADParcelable>)state;

- (id<ADParcelable>)onSaveInstanceState;

- (void)onScrollStateChangedWithInt:(jint)state;

- (jint)scrollHorizontallyByWithInt:(jint)dx
       withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
          withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)scrollToPositionWithInt:(jint)position;

/*!
 @brief Scroll to the specified adapter position with the given offset from layout start.
 <p>
  Note that scroll position change will not be reflected until the next layout call. 
 <p>
  If you are just trying to make a position visible, use <code>scrollToPosition(int)</code>.
 @param position Index (starting at 0) of the reference item.
 @param offset The distance (in pixels) between the start edge of the item view and                  start edge of the RecyclerView.
 - seealso: #setReverseLayout(boolean)
 - seealso: #scrollToPosition(int)
 */
- (void)scrollToPositionWithOffsetWithInt:(jint)position
                                  withInt:(jint)offset;

- (jint)scrollVerticallyByWithInt:(jint)dy
     withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
        withADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 @brief Sets the gap handling strategy for StaggeredGridLayoutManager.If the gapStrategy parameter
  is different than the current strategy, calling this method will trigger a layout request.
 @param gapStrategy The new gap handling strategy. Should be                     
 <code>GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS</code>  or <code>GAP_HANDLING_NONE</code>
  .
 - seealso: #getGapStrategy()
 */
- (void)setGapStrategyWithInt:(jint)gapStrategy;

- (void)setMeasuredDimensionWithADRect:(ADRect *)childrenBounds
                               withInt:(jint)wSpec
                               withInt:(jint)hSpec;

/*!
 @brief Sets the orientation of the layout.StaggeredGridLayoutManager will do its best to keep
  scroll position if this method is called after views are laid out.
 @param orientation<code>HORIZONTAL</code>  or <code>VERTICAL</code>
 */
- (void)setOrientationWithInt:(jint)orientation;

/*!
 @brief Sets whether LayoutManager should start laying out items from the end of the UI.The order
  items are traversed is not affected by this call.
 <p>
  For vertical layout, if it is set to <code>true</code>, first item will be at the bottom of
  the list. 
 <p>
  For horizontal layouts, it depends on the layout direction.
  When set to true, If <code>RecyclerView</code> is LTR, than it will layout from RTL, if 
 <code>RecyclerView</code>} is RTL, it will layout from LTR.
 @param reverseLayout Whether layout should be in reverse or not
 */
- (void)setReverseLayoutWithBoolean:(jboolean)reverseLayout;

/*!
 @brief Sets the number of spans for the layout.This will invalidate all of the span assignments
  for Views.
 <p>
  Calling this method will automatically result in a new layout request unless the spanCount
  parameter is equal to current span count.
 @param spanCount Number of spans to layout
 */
- (void)setSpanCountWithInt:(jint)spanCount;

- (jboolean)supportsPredictiveItemAnimations;

#pragma mark Package-Private

- (jboolean)areAllEndsEqual;

- (jboolean)areAllStartsEqual;

/*!
 @brief Checks for gaps in the UI that may be caused by adapter changes.
 <p>
  When a full span item is laid out in reverse direction, it sets a flag which we check when
  scroll is stopped (or re-layout happens) and re-layout after first valid item.
 */
- (jboolean)checkForGaps;

/*!
 @brief This is for internal use.Not necessarily the child closest to bottom but the first child
  we find that matches the criteria.
 This method does not do any sorting based on child's end coordinate, instead, it uses
  children order.
 */
- (ADView *)findFirstVisibleItemClosestToEndWithBoolean:(jboolean)fullyVisible;

/*!
 @brief This is for internal use.Not necessarily the child closest to start but the first child
  we find that matches the criteria.
 This method does not do any sorting based on child's start coordinate, instead, it uses
  children order.
 */
- (ADView *)findFirstVisibleItemClosestToStartWithBoolean:(jboolean)fullyVisible;

/*!
 @brief Finds the first fully visible child to be used as an anchor child if span count changes when
  state is restored.If no children is fully visible, returns a partially visible child instead
  of returning null.
 */
- (jint)findFirstVisibleItemPositionInt;

- (jint)getFirstChildPosition;

- (jint)getLastChildPosition;

/*!
 @brief Checks for gaps if we've reached to the top of the list.
 <p>
  Intermediate gaps created by full span items are tracked via mLaidOutInvalidFullSpan field.
 */
- (ADView *)hasGapsToFix;

- (jboolean)isLayoutRTL;

- (void)prepareLayoutStateForDeltaWithInt:(jint)delta
                withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)scrollByWithInt:(jint)dt
withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jboolean)updateAnchorFromPendingDataWithADXRecyclerView_State:(ADXRecyclerView_State *)state
                    withADXStaggeredGridLayoutManager_AnchorInfo:(ADXStaggeredGridLayoutManager_AnchorInfo *)anchorInfo;

- (void)updateAnchorInfoForLayoutWithADXRecyclerView_State:(ADXRecyclerView_State *)state
              withADXStaggeredGridLayoutManager_AnchorInfo:(ADXStaggeredGridLayoutManager_AnchorInfo *)anchorInfo;

- (void)updateMeasureSpecsWithInt:(jint)totalSpace;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager, mSpans_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager, mPrimaryOrientation_, ADXOrientationHelper *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager, mSecondaryOrientation_, ADXOrientationHelper *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager, mLazySpanLookup_, ADXStaggeredGridLayoutManager_LazySpanLookup *)

inline jboolean ADXStaggeredGridLayoutManager_get_DEBUG(void);
#define ADXStaggeredGridLayoutManager_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, DEBUG, jboolean)

inline jint ADXStaggeredGridLayoutManager_get_HORIZONTAL(void);
#define ADXStaggeredGridLayoutManager_HORIZONTAL 0
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, HORIZONTAL, jint)

inline jint ADXStaggeredGridLayoutManager_get_VERTICAL(void);
#define ADXStaggeredGridLayoutManager_VERTICAL 1
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, VERTICAL, jint)

/*!
 @brief Does not do anything to hide gaps.
 */
inline jint ADXStaggeredGridLayoutManager_get_GAP_HANDLING_NONE(void);
#define ADXStaggeredGridLayoutManager_GAP_HANDLING_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, GAP_HANDLING_NONE, jint)

/*!
 */
inline jint ADXStaggeredGridLayoutManager_get_GAP_HANDLING_LAZY(void);
#define ADXStaggeredGridLayoutManager_GAP_HANDLING_LAZY 1
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, GAP_HANDLING_LAZY, jint)

/*!
 @brief When scroll state is changed to <code>RecyclerView.SCROLL_STATE_IDLE</code>, StaggeredGrid will
  check if there are gaps in the because of full span items.If it finds, it will re-layout
  and move items to correct positions with animations.
 <p>
  For example, if LayoutManager ends up with the following layout due to adapter changes: 
 @code

  AAA
  _BC
  DDD 
  
@endcode
  <p>
  It will animate to the following state: 
 @code

  AAA
  BC_
  DDD 
  
@endcode
 */
inline jint ADXStaggeredGridLayoutManager_get_GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS(void);
#define ADXStaggeredGridLayoutManager_GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS 2
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS, jint)

inline jint ADXStaggeredGridLayoutManager_get_INVALID_OFFSET(void);
#define ADXStaggeredGridLayoutManager_INVALID_OFFSET ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, INVALID_OFFSET, jint)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_initWithInt_withInt_(ADXStaggeredGridLayoutManager *self, jint spanCount, jint orientation);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager *new_ADXStaggeredGridLayoutManager_initWithInt_withInt_(jint spanCount, jint orientation) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager *create_ADXStaggeredGridLayoutManager_initWithInt_withInt_(jint spanCount, jint orientation);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager)

@compatibility_alias AndroidxRecyclerviewWidgetStaggeredGridLayoutManager ADXStaggeredGridLayoutManager;

#endif

#if !defined (ADXStaggeredGridLayoutManager_LayoutParams_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_LayoutParams))
#define ADXStaggeredGridLayoutManager_LayoutParams_

#define RESTRICT_RecyclerView 1
#define INCLUDE_ADXRecyclerView_LayoutParams 1
#include "RecyclerView.h"

@class ADViewGroup_LayoutParams;
@class ADViewGroup_MarginLayoutParams;
@class ADXStaggeredGridLayoutManager_Span;

/*!
 @brief LayoutParams used by StaggeredGridLayoutManager.
 <p>
  Note that if the orientation is <code>VERTICAL</code>, the width parameter is ignored and if the
  orientation is <code>HORIZONTAL</code> the height parameter is ignored because child view is
  expected to fill all of the space given to it.
 */
@interface ADXStaggeredGridLayoutManager_LayoutParams : ADXRecyclerView_LayoutParams {
 @public
  ADXStaggeredGridLayoutManager_Span *mSpan_;
  jboolean mFullSpan_;
}

#pragma mark Public

/*!
 */
- (instancetype)initWithInt:(jint)width
                    withInt:(jint)height;

- (instancetype)initWithADViewGroup_LayoutParams:(ADViewGroup_LayoutParams *)source;

- (instancetype)initWithADXRecyclerView_LayoutParams:(ADXRecyclerView_LayoutParams *)source;

- (instancetype)initWithADViewGroup_MarginLayoutParams:(ADViewGroup_MarginLayoutParams *)source;

/*!
 @brief Returns the Span index to which this View is assigned.
 @return The Span index of the View. If View is not yet assigned to any span, returns 
 <code>INVALID_SPAN_ID</code>.
 */
- (jint)getSpanIndex;

/*!
 @brief Returns whether this View occupies all available spans or just one.
 @return True if the View occupies all spans or false otherwise.
 - seealso: #setFullSpan(boolean)
 */
- (jboolean)isFullSpan;

/*!
 @brief When set to true, the item will layout using all span area.That means, if orientation
  is vertical, the view will have full width; if orientation is horizontal, the view will
  have full height.
 @param fullSpan True if this item should traverse all spans.
 - seealso: #isFullSpan()
 */
- (void)setFullSpanWithBoolean:(jboolean)fullSpan;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_LayoutParams)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_LayoutParams, mSpan_, ADXStaggeredGridLayoutManager_Span *)

/*!
 @brief Span Id for Views that are not laid out yet.
 */
inline jint ADXStaggeredGridLayoutManager_LayoutParams_get_INVALID_SPAN_ID(void);
#define ADXStaggeredGridLayoutManager_LayoutParams_INVALID_SPAN_ID -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager_LayoutParams, INVALID_SPAN_ID, jint)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LayoutParams_initWithInt_withInt_(ADXStaggeredGridLayoutManager_LayoutParams *self, jint width, jint height);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *new_ADXStaggeredGridLayoutManager_LayoutParams_initWithInt_withInt_(jint width, jint height) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *create_ADXStaggeredGridLayoutManager_LayoutParams_initWithInt_withInt_(jint width, jint height);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_MarginLayoutParams_(ADXStaggeredGridLayoutManager_LayoutParams *self, ADViewGroup_MarginLayoutParams *source);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *new_ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_MarginLayoutParams_(ADViewGroup_MarginLayoutParams *source) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *create_ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_MarginLayoutParams_(ADViewGroup_MarginLayoutParams *source);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_LayoutParams_(ADXStaggeredGridLayoutManager_LayoutParams *self, ADViewGroup_LayoutParams *source);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *new_ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_LayoutParams_(ADViewGroup_LayoutParams *source) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *create_ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_LayoutParams_(ADViewGroup_LayoutParams *source);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LayoutParams_initWithADXRecyclerView_LayoutParams_(ADXStaggeredGridLayoutManager_LayoutParams *self, ADXRecyclerView_LayoutParams *source);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *new_ADXStaggeredGridLayoutManager_LayoutParams_initWithADXRecyclerView_LayoutParams_(ADXRecyclerView_LayoutParams *source) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *create_ADXStaggeredGridLayoutManager_LayoutParams_initWithADXRecyclerView_LayoutParams_(ADXRecyclerView_LayoutParams *source);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_LayoutParams)

#endif

#if !defined (ADXStaggeredGridLayoutManager_Span_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_Span))
#define ADXStaggeredGridLayoutManager_Span_

@class ADView;
@class ADXStaggeredGridLayoutManager;
@class ADXStaggeredGridLayoutManager_LayoutParams;
@class JavaUtilArrayList;

@interface ADXStaggeredGridLayoutManager_Span : NSObject {
 @public
  JavaUtilArrayList *mViews_;
  jint mCachedStart_;
  jint mCachedEnd_;
  jint mDeletedSize_;
  jint mIndex_;
}

#pragma mark Public

- (jint)findFirstCompletelyVisibleItemPosition;

- (jint)findFirstPartiallyVisibleItemPosition;

- (jint)findFirstVisibleItemPosition;

- (jint)findLastCompletelyVisibleItemPosition;

- (jint)findLastPartiallyVisibleItemPosition;

- (jint)findLastVisibleItemPosition;

- (jint)getDeletedSize;

/*!
 @brief Depending on the layout direction, returns the View that is after the given position.
 */
- (ADView *)getFocusableViewAfterWithInt:(jint)referenceChildPosition
                                 withInt:(jint)layoutDir;

#pragma mark Package-Private

- (instancetype)initWithADXStaggeredGridLayoutManager:(ADXStaggeredGridLayoutManager *)outer$
                                              withInt:(jint)index;

- (void)appendToSpanWithADView:(ADView *)view;

- (void)cacheReferenceLineAndClearWithBoolean:(jboolean)reverseLayout
                                      withInt:(jint)offset;

- (void)calculateCachedEnd;

- (void)calculateCachedStart;

- (void)clear;

/*!
 @brief Returns the first view within this span that is partially or fully visible.Partially
  visible refers to a view that overlaps but is not fully contained within RV's padded
  bounded area.
 This view returned can be defined to have an area of overlap strictly
  greater than zero if acceptEndPointInclusion is false. If true, the view's endpoint
  inclusion is enough to consider it partially visible. The latter case can then refer to
  an out-of-bounds view positioned right at the top (or bottom) boundaries of RV's padded
  area. This is used e.g. inside 
 <code>onFocusSearchFailed(View, int, RecyclerView.Recycler, RecyclerView.State)</code> for
  calculating the next unfocusable child to become visible on the screen.
 @param fromIndex The child position index to start the search from.
 @param toIndex The child position index to end the search at.
 @param completelyVisible True if we have to only consider completely visible views,                           false otherwise.
 @param acceptCompletelyVisible True if we can consider both partially or fully visible                                 views, false, if only a partially visible child should be
                                  returned.
 @param acceptEndPointInclusion If the view's endpoint intersection with RV's padded                                 bounded area is enough to consider it partially visible,
                                  false otherwise
 @return The adapter position of the first view that's either partially or fully visible. 
 <code>RecyclerView.NO_POSITION</code> if no such view is found.
 */
- (jint)findOnePartiallyOrCompletelyVisibleChildWithInt:(jint)fromIndex
                                                withInt:(jint)toIndex
                                            withBoolean:(jboolean)completelyVisible
                                            withBoolean:(jboolean)acceptCompletelyVisible
                                            withBoolean:(jboolean)acceptEndPointInclusion;

- (jint)findOnePartiallyVisibleChildWithInt:(jint)fromIndex
                                    withInt:(jint)toIndex
                                withBoolean:(jboolean)acceptEndPointInclusion;

- (jint)findOneVisibleChildWithInt:(jint)fromIndex
                           withInt:(jint)toIndex
                       withBoolean:(jboolean)completelyVisible;

- (jint)getEndLine;

- (jint)getEndLineWithInt:(jint)def;

- (ADXStaggeredGridLayoutManager_LayoutParams *)getLayoutParamsWithADView:(ADView *)view;

- (jint)getStartLine;

- (jint)getStartLineWithInt:(jint)def;

- (void)invalidateCache;

- (void)onOffsetWithInt:(jint)dt;

- (void)popEnd;

- (void)popStart;

- (void)prependToSpanWithADView:(ADView *)view;

- (void)setLineWithInt:(jint)line;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_Span)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_Span, mViews_, JavaUtilArrayList *)

inline jint ADXStaggeredGridLayoutManager_Span_get_INVALID_LINE(void);
#define ADXStaggeredGridLayoutManager_Span_INVALID_LINE ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager_Span, INVALID_LINE, jint)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_Span_initWithADXStaggeredGridLayoutManager_withInt_(ADXStaggeredGridLayoutManager_Span *self, ADXStaggeredGridLayoutManager *outer$, jint index);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_Span *new_ADXStaggeredGridLayoutManager_Span_initWithADXStaggeredGridLayoutManager_withInt_(ADXStaggeredGridLayoutManager *outer$, jint index) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_Span *create_ADXStaggeredGridLayoutManager_Span_initWithADXStaggeredGridLayoutManager_withInt_(ADXStaggeredGridLayoutManager *outer$, jint index);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_Span)

#endif

#if !defined (ADXStaggeredGridLayoutManager_LazySpanLookup_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_LazySpanLookup))
#define ADXStaggeredGridLayoutManager_LazySpanLookup_

@class ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem;
@class ADXStaggeredGridLayoutManager_Span;
@class IOSIntArray;
@protocol JavaUtilList;

/*!
 @brief An array of mappings from adapter position to span.
 This only grows when a write happens and it grows up to the size of the adapter.
 */
@interface ADXStaggeredGridLayoutManager_LazySpanLookup : NSObject {
 @public
  IOSIntArray *mData_;
  id<JavaUtilList> mFullSpanItems_;
}

#pragma mark Public

- (void)addFullSpanItemWithADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem:(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *)fullSpanItem;

/*!
 @param minPos inclusive
 @param maxPos exclusive
 @param gapDir if not 0, returns FSIs on in that direction
 @param hasUnwantedGapAfter If true, when full span item has unwanted gaps, it will be                         returned even if its gap direction does not match.
 */
- (ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *)getFirstFullSpanItemInRangeWithInt:(jint)minPos
                                                                                          withInt:(jint)maxPos
                                                                                          withInt:(jint)gapDir
                                                                                      withBoolean:(jboolean)hasUnwantedGapAfter;

- (ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *)getFullSpanItemWithInt:(jint)position;

#pragma mark Package-Private

- (instancetype)init;

- (void)clear;

- (void)ensureSizeWithInt:(jint)position;

/*!
 @brief Invalidates everything after this position, including full span information
 */
- (jint)forceInvalidateAfterWithInt:(jint)position;

- (jint)getSpanWithInt:(jint)position;

/*!
 @brief returns end position for invalidation.
 */
- (jint)invalidateAfterWithInt:(jint)position;

- (void)offsetForAdditionWithInt:(jint)positionStart
                         withInt:(jint)itemCount;

- (void)offsetForRemovalWithInt:(jint)positionStart
                        withInt:(jint)itemCount;

- (void)setSpanWithInt:(jint)position
withADXStaggeredGridLayoutManager_Span:(ADXStaggeredGridLayoutManager_Span *)span;

- (jint)sizeForPositionWithInt:(jint)position;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_LazySpanLookup)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_LazySpanLookup, mData_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_LazySpanLookup, mFullSpanItems_, id<JavaUtilList>)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LazySpanLookup_init(ADXStaggeredGridLayoutManager_LazySpanLookup *self);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup *new_ADXStaggeredGridLayoutManager_LazySpanLookup_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup *create_ADXStaggeredGridLayoutManager_LazySpanLookup_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_LazySpanLookup)

#endif

#if !defined (ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem))
#define ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_

#define RESTRICT_Parcelable 1
#define INCLUDE_ADParcelable 1
#include "Parcelable.h"

@class IOSIntArray;
@protocol ADParcel;

/*!
 @brief We keep information about full span items because they may create gaps in the UI.
 */
@interface ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem : NSObject < ADParcelable > {
 @public
  jint mPosition_;
  jint mGapDir_;
  IOSIntArray *mGapPerSpan_;
  jboolean mHasUnwantedGapAfter_;
}

#pragma mark Public

- (jint)describeContents;

- (NSString *)description;

- (void)writeToParcelWithADParcel:(id<ADParcel>)dest
                          withInt:(jint)flags;

#pragma mark Package-Private

- (instancetype)init;

- (instancetype)initWithADParcel:(id<ADParcel>)inArg;

- (jint)getGapForSpanWithInt:(jint)spanIndex;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem, mGapPerSpan_, IOSIntArray *)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_initWithADParcel_(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *self, id<ADParcel> inArg);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *new_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_initWithADParcel_(id<ADParcel> inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *create_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_initWithADParcel_(id<ADParcel> inArg);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_init(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *self);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *new_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *create_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem)

#endif

#if !defined (ADXStaggeredGridLayoutManager_SavedState_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_SavedState))
#define ADXStaggeredGridLayoutManager_SavedState_

#define RESTRICT_Parcelable 1
#define INCLUDE_ADParcelable 1
#include "Parcelable.h"

@class IOSIntArray;
@protocol ADParcel;
@protocol JavaUtilList;

/*!
 */
@interface ADXStaggeredGridLayoutManager_SavedState : NSObject < ADParcelable > {
 @public
  jint mAnchorPosition_;
  jint mVisibleAnchorPosition_;
  jint mSpanOffsetsSize_;
  IOSIntArray *mSpanOffsets_;
  jint mSpanLookupSize_;
  IOSIntArray *mSpanLookup_;
  id<JavaUtilList> mFullSpanItems_;
  jboolean mReverseLayout_;
  jboolean mAnchorLayoutFromEnd_;
  jboolean mLastLayoutRTL_;
}

#pragma mark Public

- (instancetype)init;

- (instancetype)initWithADXStaggeredGridLayoutManager_SavedState:(ADXStaggeredGridLayoutManager_SavedState *)other;

- (jint)describeContents;

- (void)writeToParcelWithADParcel:(id<ADParcel>)dest
                          withInt:(jint)flags;

#pragma mark Package-Private

- (instancetype)initWithADParcel:(id<ADParcel>)inArg;

- (void)invalidateAnchorPositionInfo;

- (void)invalidateSpanInfo;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_SavedState)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_SavedState, mSpanOffsets_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_SavedState, mSpanLookup_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_SavedState, mFullSpanItems_, id<JavaUtilList>)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_SavedState_init(ADXStaggeredGridLayoutManager_SavedState *self);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *new_ADXStaggeredGridLayoutManager_SavedState_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *create_ADXStaggeredGridLayoutManager_SavedState_init(void);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_SavedState_initWithADParcel_(ADXStaggeredGridLayoutManager_SavedState *self, id<ADParcel> inArg);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *new_ADXStaggeredGridLayoutManager_SavedState_initWithADParcel_(id<ADParcel> inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *create_ADXStaggeredGridLayoutManager_SavedState_initWithADParcel_(id<ADParcel> inArg);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_SavedState_initWithADXStaggeredGridLayoutManager_SavedState_(ADXStaggeredGridLayoutManager_SavedState *self, ADXStaggeredGridLayoutManager_SavedState *other);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *new_ADXStaggeredGridLayoutManager_SavedState_initWithADXStaggeredGridLayoutManager_SavedState_(ADXStaggeredGridLayoutManager_SavedState *other) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *create_ADXStaggeredGridLayoutManager_SavedState_initWithADXStaggeredGridLayoutManager_SavedState_(ADXStaggeredGridLayoutManager_SavedState *other);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_SavedState)

#endif

#if !defined (ADXStaggeredGridLayoutManager_AnchorInfo_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_AnchorInfo))
#define ADXStaggeredGridLayoutManager_AnchorInfo_

@class ADXStaggeredGridLayoutManager;
@class IOSIntArray;
@class IOSObjectArray;

/*!
 @brief Data class to hold the information about an anchor position which is used in onLayout call.
 */
@interface ADXStaggeredGridLayoutManager_AnchorInfo : NSObject {
 @public
  jint mPosition_;
  jint mOffset_;
  jboolean mLayoutFromEnd_;
  jboolean mInvalidateOffsets_;
  jboolean mValid_;
  IOSIntArray *mSpanReferenceLines_;
}

#pragma mark Package-Private

- (instancetype)initWithADXStaggeredGridLayoutManager:(ADXStaggeredGridLayoutManager *)outer$;

- (void)assignCoordinateFromPadding;

- (void)assignCoordinateFromPaddingWithInt:(jint)addedDistance;

- (void)reset;

- (void)saveSpanReferenceLinesWithADXStaggeredGridLayoutManager_SpanArray:(IOSObjectArray *)spans;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_AnchorInfo)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_AnchorInfo, mSpanReferenceLines_, IOSIntArray *)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_AnchorInfo_initWithADXStaggeredGridLayoutManager_(ADXStaggeredGridLayoutManager_AnchorInfo *self, ADXStaggeredGridLayoutManager *outer$);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_AnchorInfo *new_ADXStaggeredGridLayoutManager_AnchorInfo_initWithADXStaggeredGridLayoutManager_(ADXStaggeredGridLayoutManager *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_AnchorInfo *create_ADXStaggeredGridLayoutManager_AnchorInfo_initWithADXStaggeredGridLayoutManager_(ADXStaggeredGridLayoutManager *outer$);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_AnchorInfo)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_StaggeredGridLayoutManager")
