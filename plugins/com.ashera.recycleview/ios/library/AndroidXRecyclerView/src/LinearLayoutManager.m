//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXRecyclerView\src\main\java\androidx\recyclerview\widget\LinearLayoutManager.java
//

#include "Context.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "LinearLayoutManager.h"
#include "Log.h"
#include "OrientationHelper.h"
#include "Parcel.h"
#include "Parcelable.h"
#include "RecyclerView.h"
#include "ScrollbarHelper.h"
#include "View.h"
#include "ViewBoundsCheck.h"
#include "ViewCompat.h"
#include "ViewGroup.h"
#include "java/lang/Deprecated.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/annotation/Annotation.h"
#include "java/util/List.h"


@interface ADXLinearLayoutManager () {
 @public
  /*!
   @brief Helper class that keeps temporary layout state.
   It does not keep state after layout is complete but we still keep a reference to re-use
  the same object.
   */
  ADXLinearLayoutManager_LayoutState *mLayoutState_;
  /*!
   @brief We need to track this so that we can ignore current position when it changes.
   */
  jboolean mLastStackFromEnd_;
  /*!
   @brief Defines if layout should be calculated from end to start.
   - seealso: #mShouldReverseLayout
   */
  jboolean mReverseLayout_;
  /*!
   @brief Works the same way as <code>r.android.widget.AbsListView.setStackFromBottom(boolean)</code> and
  it supports both orientations.
   see <code>r.android.widget.AbsListView.setStackFromBottom(boolean)</code>
   */
  jboolean mStackFromEnd_;
  /*!
   @brief Works the same way as <code>r.android.widget.AbsListView.setSmoothScrollbarEnabled(boolean)</code>.
   see <code>r.android.widget.AbsListView.setSmoothScrollbarEnabled(boolean)</code>
   */
  jboolean mSmoothScrollbarEnabled_;
  jboolean mRecycleChildrenOnDetach_;
  /*!
   @brief Stashed to avoid allocation, currently only used in #fill()
   */
  ADXLinearLayoutManager_LayoutChunkResult *mLayoutChunkResult_;
  /*!
   @brief Number of items to prefetch when first coming on screen with new data.
   */
  jint mInitialPrefetchItemCount_;
  IOSIntArray *mReusableIntPair_;
}

/*!
 @brief Calculates the view layout order.
 (e.g. from end to start or start to end)
  RTL layout support is applied automatically. So if layout is RTL and 
 <code>getReverseLayout()</code> is <code>true</code>, elements will be laid out starting from left.
 */
- (void)resolveShouldLayoutReverse;

/*!
 @brief If necessary, layouts new items for predictive animations
 */
- (void)layoutForPredictiveAnimationsWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                        withADXRecyclerView_State:(ADXRecyclerView_State *)state
                                                          withInt:(jint)startOffset
                                                          withInt:(jint)endOffset;

- (void)updateAnchorInfoForLayoutWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                    withADXRecyclerView_State:(ADXRecyclerView_State *)state
                        withADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo;

/*!
 @brief Finds an anchor child from existing Views.Most of the time, this is the view closest to
  start or end that has a valid position (e.g. not removed).
 <p>
  If a child has focus, it is given priority.
 */
- (jboolean)updateAnchorFromChildrenWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                       withADXRecyclerView_State:(ADXRecyclerView_State *)state
                           withADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo;

/*!
 @brief If there is a pending scroll position or saved states, updates the anchor info from that
  data and returns true
 */
- (jboolean)updateAnchorFromPendingDataWithADXRecyclerView_State:(ADXRecyclerView_State *)state
                           withADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo;

/*!
 @return The final offset amount for children
 */
- (jint)fixLayoutEndGapWithInt:(jint)endOffset
  withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
     withADXRecyclerView_State:(ADXRecyclerView_State *)state
                   withBoolean:(jboolean)canOffsetChildren;

/*!
 @return The final offset amount for children
 */
- (jint)fixLayoutStartGapWithInt:(jint)startOffset
    withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
       withADXRecyclerView_State:(ADXRecyclerView_State *)state
                     withBoolean:(jboolean)canOffsetChildren;

- (void)updateLayoutStateToFillEndWithADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo;

- (void)updateLayoutStateToFillEndWithInt:(jint)itemPosition
                                  withInt:(jint)offset;

- (void)updateLayoutStateToFillStartWithADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo;

- (void)updateLayoutStateToFillStartWithInt:(jint)itemPosition
                                    withInt:(jint)offset;

- (jint)computeScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (jint)computeScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)updateLayoutStateWithInt:(jint)layoutDirection
                         withInt:(jint)requiredSpace
                     withBoolean:(jboolean)canUseExistingSpace
       withADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 @brief Recycles children between given indices.
 @param startIndex inclusive
 @param endIndex exclusive
 */
- (void)recycleChildrenWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                            withInt:(jint)startIndex
                                            withInt:(jint)endIndex;

/*!
 @brief Recycles views that went out of bounds after scrolling towards the end of the layout.
 <p>
  Checks both layout position and visible position to guarantee that the view is not visible.
 @param recycler Recycler instance of <code>RecyclerView</code>
 @param scrollingOffset This can be used to add additional padding to the visible area. This                         is used to detect children that will go out of bounds after scrolling,
                          without actually moving them.
 @param noRecycleSpace Extra space that should be excluded from recycling. This is the space                         from 
 <code>extraLayoutSpace[0]</code> , calculated in <code>calculateExtraLayoutSpace</code>
  .
 */
- (void)recycleViewsFromStartWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                                  withInt:(jint)scrollingOffset
                                                  withInt:(jint)noRecycleSpace;

/*!
 @brief Recycles views that went out of bounds after scrolling towards the start of the layout.
 <p>
  Checks both layout position and visible position to guarantee that the view is not visible.
 @param recycler Recycler instance of <code>RecyclerView</code>
 @param scrollingOffset This can be used to add additional padding to the visible area. This                         is used to detect children that will go out of bounds after scrolling,
                          without actually moving them.
 @param noRecycleSpace Extra space that should be excluded from recycling. This is the space                         from 
 <code>extraLayoutSpace[1]</code> , calculated in <code>calculateExtraLayoutSpace</code>
  .
 */
- (void)recycleViewsFromEndWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                                withInt:(jint)scrollingOffset
                                                withInt:(jint)noRecycleSpace;

/*!
 @brief Helper method to call appropriate recycle method depending on current layout direction
 @param recycler Current recycler that is attached to RecyclerView
 @param layoutState Current layout state. Right now, this object does not change but                     we may consider moving it out of this view so passing around as a
                      parameter for now, rather than accessing 
 <code>mLayoutState</code>
 - seealso: #recycleViewsFromStart(RecyclerView.Recycler, int, int)
 - seealso: #recycleViewsFromEnd(RecyclerView.Recycler, int, int)
 - seealso: LinearLayoutManager.LayoutState#mLayoutDirection
 */
- (void)recycleByLayoutStateWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                  withADXLinearLayoutManager_LayoutState:(ADXLinearLayoutManager_LayoutState *)layoutState;

/*!
 @brief Convenience method to find the child closes to start.Caller should check it has enough
  children.
 @return The child closes to start of the layout from user's perspective.
 */
- (ADView *)getChildClosestToStart;

/*!
 @brief Convenience method to find the child closes to end.Caller should check it has enough
  children.
 @return The child closes to end of the layout from user's perspective.
 */
- (ADView *)getChildClosestToEnd;

- (ADView *)findPartiallyOrCompletelyInvisibleChildClosestToEnd;

- (ADView *)findPartiallyOrCompletelyInvisibleChildClosestToStart;

- (ADView *)findFirstPartiallyOrCompletelyInvisibleChild;

- (ADView *)findLastPartiallyOrCompletelyInvisibleChild;

/*!
 @brief Used for debugging.
 Logs the internal representation of children to default logger.
 */
- (void)logChildren;

@end

J2OBJC_FIELD_SETTER(ADXLinearLayoutManager, mLayoutState_, ADXLinearLayoutManager_LayoutState *)
J2OBJC_FIELD_SETTER(ADXLinearLayoutManager, mLayoutChunkResult_, ADXLinearLayoutManager_LayoutChunkResult *)
J2OBJC_FIELD_SETTER(ADXLinearLayoutManager, mReusableIntPair_, IOSIntArray *)

inline NSString *ADXLinearLayoutManager_get_TAG(void);
static NSString *ADXLinearLayoutManager_TAG = @"LinearLayoutManager";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADXLinearLayoutManager, TAG, NSString *)

/*!
 @brief While trying to find next view to focus, LayoutManager will not try to scroll more
  than this factor times the total space of the list.If layout is vertical, total space is the
  height minus padding, if layout is horizontal, total space is the width minus padding.
 */
inline jfloat ADXLinearLayoutManager_get_MAX_SCROLL_FACTOR(void);
#define ADXLinearLayoutManager_MAX_SCROLL_FACTOR 0.33333334f
J2OBJC_STATIC_FIELD_CONSTANT(ADXLinearLayoutManager, MAX_SCROLL_FACTOR, jfloat)

__attribute__((unused)) static void ADXLinearLayoutManager_resolveShouldLayoutReverse(ADXLinearLayoutManager *self);

__attribute__((unused)) static void ADXLinearLayoutManager_layoutForPredictiveAnimationsWithADXRecyclerView_Recycler_withADXRecyclerView_State_withInt_withInt_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, jint startOffset, jint endOffset);

__attribute__((unused)) static void ADXLinearLayoutManager_updateAnchorInfoForLayoutWithADXRecyclerView_Recycler_withADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, ADXLinearLayoutManager_AnchorInfo *anchorInfo);

__attribute__((unused)) static jboolean ADXLinearLayoutManager_updateAnchorFromChildrenWithADXRecyclerView_Recycler_withADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, ADXLinearLayoutManager_AnchorInfo *anchorInfo);

__attribute__((unused)) static jboolean ADXLinearLayoutManager_updateAnchorFromPendingDataWithADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXRecyclerView_State *state, ADXLinearLayoutManager_AnchorInfo *anchorInfo);

__attribute__((unused)) static jint ADXLinearLayoutManager_fixLayoutEndGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(ADXLinearLayoutManager *self, jint endOffset, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, jboolean canOffsetChildren);

__attribute__((unused)) static jint ADXLinearLayoutManager_fixLayoutStartGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(ADXLinearLayoutManager *self, jint startOffset, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, jboolean canOffsetChildren);

__attribute__((unused)) static void ADXLinearLayoutManager_updateLayoutStateToFillEndWithADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXLinearLayoutManager_AnchorInfo *anchorInfo);

__attribute__((unused)) static void ADXLinearLayoutManager_updateLayoutStateToFillEndWithInt_withInt_(ADXLinearLayoutManager *self, jint itemPosition, jint offset);

__attribute__((unused)) static void ADXLinearLayoutManager_updateLayoutStateToFillStartWithADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXLinearLayoutManager_AnchorInfo *anchorInfo);

__attribute__((unused)) static void ADXLinearLayoutManager_updateLayoutStateToFillStartWithInt_withInt_(ADXLinearLayoutManager *self, jint itemPosition, jint offset);

__attribute__((unused)) static jint ADXLinearLayoutManager_computeScrollOffsetWithADXRecyclerView_State_(ADXLinearLayoutManager *self, ADXRecyclerView_State *state);

__attribute__((unused)) static jint ADXLinearLayoutManager_computeScrollExtentWithADXRecyclerView_State_(ADXLinearLayoutManager *self, ADXRecyclerView_State *state);

__attribute__((unused)) static jint ADXLinearLayoutManager_computeScrollRangeWithADXRecyclerView_State_(ADXLinearLayoutManager *self, ADXRecyclerView_State *state);

__attribute__((unused)) static void ADXLinearLayoutManager_updateLayoutStateWithInt_withInt_withBoolean_withADXRecyclerView_State_(ADXLinearLayoutManager *self, jint layoutDirection, jint requiredSpace, jboolean canUseExistingSpace, ADXRecyclerView_State *state);

__attribute__((unused)) static void ADXLinearLayoutManager_recycleChildrenWithADXRecyclerView_Recycler_withInt_withInt_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, jint startIndex, jint endIndex);

__attribute__((unused)) static void ADXLinearLayoutManager_recycleViewsFromStartWithADXRecyclerView_Recycler_withInt_withInt_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, jint scrollingOffset, jint noRecycleSpace);

__attribute__((unused)) static void ADXLinearLayoutManager_recycleViewsFromEndWithADXRecyclerView_Recycler_withInt_withInt_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, jint scrollingOffset, jint noRecycleSpace);

__attribute__((unused)) static void ADXLinearLayoutManager_recycleByLayoutStateWithADXRecyclerView_Recycler_withADXLinearLayoutManager_LayoutState_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, ADXLinearLayoutManager_LayoutState *layoutState);

__attribute__((unused)) static ADView *ADXLinearLayoutManager_getChildClosestToStart(ADXLinearLayoutManager *self);

__attribute__((unused)) static ADView *ADXLinearLayoutManager_getChildClosestToEnd(ADXLinearLayoutManager *self);

__attribute__((unused)) static ADView *ADXLinearLayoutManager_findPartiallyOrCompletelyInvisibleChildClosestToEnd(ADXLinearLayoutManager *self);

__attribute__((unused)) static ADView *ADXLinearLayoutManager_findPartiallyOrCompletelyInvisibleChildClosestToStart(ADXLinearLayoutManager *self);

__attribute__((unused)) static ADView *ADXLinearLayoutManager_findFirstPartiallyOrCompletelyInvisibleChild(ADXLinearLayoutManager *self);

__attribute__((unused)) static ADView *ADXLinearLayoutManager_findLastPartiallyOrCompletelyInvisibleChild(ADXLinearLayoutManager *self);

__attribute__((unused)) static void ADXLinearLayoutManager_logChildren(ADXLinearLayoutManager *self);

__attribute__((unused)) static IOSObjectArray *ADXLinearLayoutManager__Annotations$0(void);

@interface ADXLinearLayoutManager_LayoutState ()

/*!
 @brief Returns the next item from the scrap list.
 <p>
  Upon finding a valid VH, sets current item position to VH.itemPosition + mItemDirection
 @return View if an item in the current position or direction exists if not null.
 */
- (ADView *)nextViewFromScrapList;

@end

__attribute__((unused)) static ADView *ADXLinearLayoutManager_LayoutState_nextViewFromScrapList(ADXLinearLayoutManager_LayoutState *self);

@implementation ADXLinearLayoutManager

- (instancetype)initWithADContext:(ADContext *)context {
  ADXLinearLayoutManager_initWithADContext_(self, context);
  return self;
}

- (instancetype)initWithADContext:(ADContext *)context
                          withInt:(jint)orientation
                      withBoolean:(jboolean)reverseLayout {
  ADXLinearLayoutManager_initWithADContext_withInt_withBoolean_(self, context, orientation, reverseLayout);
  return self;
}

- (jboolean)isAutoMeasureEnabled {
  return true;
}

- (ADXRecyclerView_LayoutParams *)generateDefaultLayoutParams {
  return create_ADXRecyclerView_LayoutParams_initWithInt_withInt_(ADViewGroup_LayoutParams_WRAP_CONTENT, ADViewGroup_LayoutParams_WRAP_CONTENT);
}

- (jboolean)getRecycleChildrenOnDetach {
  return mRecycleChildrenOnDetach_;
}

- (void)setRecycleChildrenOnDetachWithBoolean:(jboolean)recycleChildrenOnDetach {
  mRecycleChildrenOnDetach_ = recycleChildrenOnDetach;
}

- (void)onDetachedFromWindowWithADXRecyclerView:(ADXRecyclerView *)view
                   withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler {
  [super onDetachedFromWindowWithADXRecyclerView:view withADXRecyclerView_Recycler:recycler];
  if (mRecycleChildrenOnDetach_) {
    [self removeAndRecycleAllViewsWithADXRecyclerView_Recycler:recycler];
    [((ADXRecyclerView_Recycler *) nil_chk(recycler)) clear];
  }
}

- (id<ADParcelable>)onSaveInstanceState {
  if (mPendingSavedState_ != nil) {
    return create_ADXLinearLayoutManager_SavedState_initWithADXLinearLayoutManager_SavedState_(mPendingSavedState_);
  }
  ADXLinearLayoutManager_SavedState *state = create_ADXLinearLayoutManager_SavedState_init();
  if ([self getChildCount] > 0) {
    [self ensureLayoutState];
    jboolean didLayoutFromEnd = mLastStackFromEnd_ ^ mShouldReverseLayout_;
    state->mAnchorLayoutFromEnd_ = didLayoutFromEnd;
    if (didLayoutFromEnd) {
      ADView *refChild = ADXLinearLayoutManager_getChildClosestToEnd(self);
      state->mAnchorOffset_ = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] - [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedEndWithADView:refChild];
      state->mAnchorPosition_ = [self getPositionWithADView:refChild];
    }
    else {
      ADView *refChild = ADXLinearLayoutManager_getChildClosestToStart(self);
      state->mAnchorPosition_ = [self getPositionWithADView:refChild];
      state->mAnchorOffset_ = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:refChild] - [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getStartAfterPadding];
    }
  }
  else {
    [state invalidateAnchor];
  }
  return state;
}

- (void)onRestoreInstanceStateWithADParcelable:(id<ADParcelable>)state {
  if ([state isKindOfClass:[ADXLinearLayoutManager_SavedState class]]) {
    JreStrongAssign(&mPendingSavedState_, (ADXLinearLayoutManager_SavedState *) state);
    if (mPendingScrollPosition_ != ADXRecyclerView_NO_POSITION) {
      [((ADXLinearLayoutManager_SavedState *) nil_chk(mPendingSavedState_)) invalidateAnchor];
    }
    [self requestLayout];
  }
}

- (jboolean)canScrollHorizontally {
  return mOrientation_ == ADXLinearLayoutManager_HORIZONTAL;
}

- (jboolean)canScrollVertically {
  return mOrientation_ == ADXLinearLayoutManager_VERTICAL;
}

- (void)setStackFromEndWithBoolean:(jboolean)stackFromEnd {
  [self assertNotInLayoutOrScrollWithNSString:nil];
  if (mStackFromEnd_ == stackFromEnd) {
    return;
  }
  mStackFromEnd_ = stackFromEnd;
  [self requestLayout];
}

- (jboolean)getStackFromEnd {
  return mStackFromEnd_;
}

- (jint)getOrientation {
  return mOrientation_;
}

- (void)setOrientationWithInt:(jint)orientation {
  if (orientation != ADXLinearLayoutManager_HORIZONTAL && orientation != ADXLinearLayoutManager_VERTICAL) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"invalid orientation:", orientation));
  }
  [self assertNotInLayoutOrScrollWithNSString:nil];
  if (orientation != mOrientation_ || mOrientationHelper_ == nil) {
    JreStrongAssign(&mOrientationHelper_, ADXOrientationHelper_createOrientationHelperWithADXRecyclerView_LayoutManager_withInt_(self, orientation));
    JreStrongAssign(&((ADXLinearLayoutManager_AnchorInfo *) nil_chk(mAnchorInfo_))->mOrientationHelper_, mOrientationHelper_);
    mOrientation_ = orientation;
    [self requestLayout];
  }
}

- (void)resolveShouldLayoutReverse {
  ADXLinearLayoutManager_resolveShouldLayoutReverse(self);
}

- (jboolean)getReverseLayout {
  return mReverseLayout_;
}

- (void)setReverseLayoutWithBoolean:(jboolean)reverseLayout {
  [self assertNotInLayoutOrScrollWithNSString:nil];
  if (reverseLayout == mReverseLayout_) {
    return;
  }
  mReverseLayout_ = reverseLayout;
  [self requestLayout];
}

- (ADView *)findViewByPositionWithInt:(jint)position {
  jint childCount = [self getChildCount];
  if (childCount == 0) {
    return nil;
  }
  jint firstChild = [self getPositionWithADView:[self getChildAtWithInt:0]];
  jint viewPosition = position - firstChild;
  if (viewPosition >= 0 && viewPosition < childCount) {
    ADView *child = [self getChildAtWithInt:viewPosition];
    if ([self getPositionWithADView:child] == position) {
      return child;
    }
  }
  return [super findViewByPositionWithInt:position];
}

- (jint)getExtraLayoutSpaceWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  if ([((ADXRecyclerView_State *) nil_chk(state)) hasTargetScrollPosition]) {
    return [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getTotalSpace];
  }
  else {
    return 0;
  }
}

- (void)calculateExtraLayoutSpaceWithADXRecyclerView_State:(ADXRecyclerView_State *)state
                                              withIntArray:(IOSIntArray *)extraLayoutSpace {
  jint extraLayoutSpaceStart = 0;
  jint extraLayoutSpaceEnd = 0;
  jint extraScrollSpace = [self getExtraLayoutSpaceWithADXRecyclerView_State:state];
  if (((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mLayoutDirection_ == ADXLinearLayoutManager_LayoutState_LAYOUT_START) {
    extraLayoutSpaceStart = extraScrollSpace;
  }
  else {
    extraLayoutSpaceEnd = extraScrollSpace;
  }
  *IOSIntArray_GetRef(nil_chk(extraLayoutSpace), 0) = extraLayoutSpaceStart;
  *IOSIntArray_GetRef(extraLayoutSpace, 1) = extraLayoutSpaceEnd;
}

- (void)onLayoutChildrenWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                           withADXRecyclerView_State:(ADXRecyclerView_State *)state {
  if (mPendingSavedState_ != nil || mPendingScrollPosition_ != ADXRecyclerView_NO_POSITION) {
    if ([((ADXRecyclerView_State *) nil_chk(state)) getItemCount] == 0) {
      [self removeAndRecycleAllViewsWithADXRecyclerView_Recycler:recycler];
      return;
    }
  }
  if (mPendingSavedState_ != nil && [mPendingSavedState_ hasValidAnchor]) {
    mPendingScrollPosition_ = mPendingSavedState_->mAnchorPosition_;
  }
  [self ensureLayoutState];
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mRecycle_ = false;
  ADXLinearLayoutManager_resolveShouldLayoutReverse(self);
  ADView *focused = nil;
  if (!((ADXLinearLayoutManager_AnchorInfo *) nil_chk(mAnchorInfo_))->mValid_ || mPendingScrollPosition_ != ADXRecyclerView_NO_POSITION || mPendingSavedState_ != nil) {
    [mAnchorInfo_ reset];
    mAnchorInfo_->mLayoutFromEnd_ = (mShouldReverseLayout_ ^ mStackFromEnd_);
    ADXLinearLayoutManager_updateAnchorInfoForLayoutWithADXRecyclerView_Recycler_withADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(self, recycler, state, mAnchorInfo_);
    mAnchorInfo_->mValid_ = true;
  }
  else if (focused != nil && ([((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:focused] >= [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] || [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedEndWithADView:focused] <= [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getStartAfterPadding])) {
    [mAnchorInfo_ assignFromViewAndKeepVisibleRectWithADView:focused withInt:[self getPositionWithADView:focused]];
  }
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mLayoutDirection_ = mLayoutState_->mLastScrollDelta_ >= 0 ? ADXLinearLayoutManager_LayoutState_LAYOUT_END : ADXLinearLayoutManager_LayoutState_LAYOUT_START;
  *IOSIntArray_GetRef(nil_chk(mReusableIntPair_), 0) = 0;
  *IOSIntArray_GetRef(mReusableIntPair_, 1) = 0;
  [self calculateExtraLayoutSpaceWithADXRecyclerView_State:state withIntArray:mReusableIntPair_];
  jint extraForStart = JavaLangMath_maxWithInt_withInt_(0, IOSIntArray_Get(nil_chk(mReusableIntPair_), 0)) + [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getStartAfterPadding];
  jint extraForEnd = JavaLangMath_maxWithInt_withInt_(0, IOSIntArray_Get(nil_chk(mReusableIntPair_), 1)) + [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndPadding];
  if ([((ADXRecyclerView_State *) nil_chk(state)) isPreLayout] && mPendingScrollPosition_ != ADXRecyclerView_NO_POSITION && mPendingScrollPositionOffset_ != ADXLinearLayoutManager_INVALID_OFFSET) {
    ADView *existing = [self findViewByPositionWithInt:mPendingScrollPosition_];
    if (existing != nil) {
      jint current;
      jint upcomingOffset;
      if (mShouldReverseLayout_) {
        current = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] - [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedEndWithADView:existing];
        upcomingOffset = current - mPendingScrollPositionOffset_;
      }
      else {
        current = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:existing] - [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getStartAfterPadding];
        upcomingOffset = mPendingScrollPositionOffset_ - current;
      }
      if (upcomingOffset > 0) {
        extraForStart += upcomingOffset;
      }
      else {
        extraForEnd -= upcomingOffset;
      }
    }
  }
  jint startOffset;
  jint endOffset;
  jint firstLayoutDirection;
  if (mAnchorInfo_->mLayoutFromEnd_) {
    firstLayoutDirection = mShouldReverseLayout_ ? ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL : ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD;
  }
  else {
    firstLayoutDirection = mShouldReverseLayout_ ? ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD : ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL;
  }
  [self onAnchorReadyWithADXRecyclerView_Recycler:recycler withADXRecyclerView_State:state withADXLinearLayoutManager_AnchorInfo:mAnchorInfo_ withInt:firstLayoutDirection];
  [self detachAndScrapAttachedViewsWithADXRecyclerView_Recycler:recycler];
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mInfinite_ = [self resolveIsInfinite];
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mIsPreLayout_ = [state isPreLayout];
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mNoRecycleSpace_ = 0;
  if (mAnchorInfo_->mLayoutFromEnd_) {
    ADXLinearLayoutManager_updateLayoutStateToFillStartWithADXLinearLayoutManager_AnchorInfo_(self, mAnchorInfo_);
    ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mExtraFillSpace_ = extraForStart;
    [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:mLayoutState_ withADXRecyclerView_State:state withBoolean:false];
    startOffset = ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mOffset_;
    jint firstElement = mLayoutState_->mCurrentPosition_;
    if (mLayoutState_->mAvailable_ > 0) {
      extraForEnd += mLayoutState_->mAvailable_;
    }
    ADXLinearLayoutManager_updateLayoutStateToFillEndWithADXLinearLayoutManager_AnchorInfo_(self, mAnchorInfo_);
    ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mExtraFillSpace_ = extraForEnd;
    mLayoutState_->mCurrentPosition_ += mLayoutState_->mItemDirection_;
    [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:mLayoutState_ withADXRecyclerView_State:state withBoolean:false];
    endOffset = ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mOffset_;
    if (mLayoutState_->mAvailable_ > 0) {
      extraForStart = mLayoutState_->mAvailable_;
      ADXLinearLayoutManager_updateLayoutStateToFillStartWithInt_withInt_(self, firstElement, startOffset);
      ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mExtraFillSpace_ = extraForStart;
      [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:mLayoutState_ withADXRecyclerView_State:state withBoolean:false];
      startOffset = ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mOffset_;
    }
  }
  else {
    ADXLinearLayoutManager_updateLayoutStateToFillEndWithADXLinearLayoutManager_AnchorInfo_(self, mAnchorInfo_);
    ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mExtraFillSpace_ = extraForEnd;
    [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:mLayoutState_ withADXRecyclerView_State:state withBoolean:false];
    endOffset = ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mOffset_;
    jint lastElement = mLayoutState_->mCurrentPosition_;
    if (mLayoutState_->mAvailable_ > 0) {
      extraForStart += mLayoutState_->mAvailable_;
    }
    ADXLinearLayoutManager_updateLayoutStateToFillStartWithADXLinearLayoutManager_AnchorInfo_(self, mAnchorInfo_);
    ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mExtraFillSpace_ = extraForStart;
    mLayoutState_->mCurrentPosition_ += mLayoutState_->mItemDirection_;
    [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:mLayoutState_ withADXRecyclerView_State:state withBoolean:false];
    startOffset = ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mOffset_;
    if (mLayoutState_->mAvailable_ > 0) {
      extraForEnd = mLayoutState_->mAvailable_;
      ADXLinearLayoutManager_updateLayoutStateToFillEndWithInt_withInt_(self, lastElement, endOffset);
      ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mExtraFillSpace_ = extraForEnd;
      [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:mLayoutState_ withADXRecyclerView_State:state withBoolean:false];
      endOffset = ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mOffset_;
    }
  }
  if ([self getChildCount] > 0) {
    if (mShouldReverseLayout_ ^ mStackFromEnd_) {
      jint fixOffset = ADXLinearLayoutManager_fixLayoutEndGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(self, endOffset, recycler, state, true);
      startOffset += fixOffset;
      endOffset += fixOffset;
      fixOffset = ADXLinearLayoutManager_fixLayoutStartGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(self, startOffset, recycler, state, false);
      startOffset += fixOffset;
      endOffset += fixOffset;
    }
    else {
      jint fixOffset = ADXLinearLayoutManager_fixLayoutStartGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(self, startOffset, recycler, state, true);
      startOffset += fixOffset;
      endOffset += fixOffset;
      fixOffset = ADXLinearLayoutManager_fixLayoutEndGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(self, endOffset, recycler, state, false);
      startOffset += fixOffset;
      endOffset += fixOffset;
    }
  }
  ADXLinearLayoutManager_layoutForPredictiveAnimationsWithADXRecyclerView_Recycler_withADXRecyclerView_State_withInt_withInt_(self, recycler, state, startOffset, endOffset);
  if (![state isPreLayout]) {
    [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) onLayoutComplete];
  }
  else {
    [mAnchorInfo_ reset];
  }
  mLastStackFromEnd_ = mStackFromEnd_;
}

- (void)onLayoutCompletedWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  [super onLayoutCompletedWithADXRecyclerView_State:state];
  JreStrongAssign(&mPendingSavedState_, nil);
  mPendingScrollPosition_ = ADXRecyclerView_NO_POSITION;
  mPendingScrollPositionOffset_ = ADXLinearLayoutManager_INVALID_OFFSET;
  [((ADXLinearLayoutManager_AnchorInfo *) nil_chk(mAnchorInfo_)) reset];
}

- (void)onAnchorReadyWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                        withADXRecyclerView_State:(ADXRecyclerView_State *)state
            withADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo
                                          withInt:(jint)firstLayoutItemDirection {
}

- (void)layoutForPredictiveAnimationsWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                        withADXRecyclerView_State:(ADXRecyclerView_State *)state
                                                          withInt:(jint)startOffset
                                                          withInt:(jint)endOffset {
  ADXLinearLayoutManager_layoutForPredictiveAnimationsWithADXRecyclerView_Recycler_withADXRecyclerView_State_withInt_withInt_(self, recycler, state, startOffset, endOffset);
}

- (void)updateAnchorInfoForLayoutWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                    withADXRecyclerView_State:(ADXRecyclerView_State *)state
                        withADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo {
  ADXLinearLayoutManager_updateAnchorInfoForLayoutWithADXRecyclerView_Recycler_withADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(self, recycler, state, anchorInfo);
}

- (jboolean)updateAnchorFromChildrenWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                       withADXRecyclerView_State:(ADXRecyclerView_State *)state
                           withADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo {
  return ADXLinearLayoutManager_updateAnchorFromChildrenWithADXRecyclerView_Recycler_withADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(self, recycler, state, anchorInfo);
}

- (jboolean)updateAnchorFromPendingDataWithADXRecyclerView_State:(ADXRecyclerView_State *)state
                           withADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo {
  return ADXLinearLayoutManager_updateAnchorFromPendingDataWithADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(self, state, anchorInfo);
}

- (jint)fixLayoutEndGapWithInt:(jint)endOffset
  withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
     withADXRecyclerView_State:(ADXRecyclerView_State *)state
                   withBoolean:(jboolean)canOffsetChildren {
  return ADXLinearLayoutManager_fixLayoutEndGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(self, endOffset, recycler, state, canOffsetChildren);
}

- (jint)fixLayoutStartGapWithInt:(jint)startOffset
    withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
       withADXRecyclerView_State:(ADXRecyclerView_State *)state
                     withBoolean:(jboolean)canOffsetChildren {
  return ADXLinearLayoutManager_fixLayoutStartGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(self, startOffset, recycler, state, canOffsetChildren);
}

- (void)updateLayoutStateToFillEndWithADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo {
  ADXLinearLayoutManager_updateLayoutStateToFillEndWithADXLinearLayoutManager_AnchorInfo_(self, anchorInfo);
}

- (void)updateLayoutStateToFillEndWithInt:(jint)itemPosition
                                  withInt:(jint)offset {
  ADXLinearLayoutManager_updateLayoutStateToFillEndWithInt_withInt_(self, itemPosition, offset);
}

- (void)updateLayoutStateToFillStartWithADXLinearLayoutManager_AnchorInfo:(ADXLinearLayoutManager_AnchorInfo *)anchorInfo {
  ADXLinearLayoutManager_updateLayoutStateToFillStartWithADXLinearLayoutManager_AnchorInfo_(self, anchorInfo);
}

- (void)updateLayoutStateToFillStartWithInt:(jint)itemPosition
                                    withInt:(jint)offset {
  ADXLinearLayoutManager_updateLayoutStateToFillStartWithInt_withInt_(self, itemPosition, offset);
}

- (jboolean)isLayoutRTL {
  return [self getLayoutDirection] == ADXViewCompat_LAYOUT_DIRECTION_RTL;
}

- (void)ensureLayoutState {
  if (mLayoutState_ == nil) {
    JreStrongAssign(&mLayoutState_, [self createLayoutState]);
  }
}

- (ADXLinearLayoutManager_LayoutState *)createLayoutState {
  return create_ADXLinearLayoutManager_LayoutState_init();
}

- (void)scrollToPositionWithInt:(jint)position {
  mPendingScrollPosition_ = position;
  mPendingScrollPositionOffset_ = ADXLinearLayoutManager_INVALID_OFFSET;
  if (mPendingSavedState_ != nil) {
    [mPendingSavedState_ invalidateAnchor];
  }
  [self requestLayout];
}

- (void)scrollToPositionWithOffsetWithInt:(jint)position
                                  withInt:(jint)offset {
  mPendingScrollPosition_ = position;
  mPendingScrollPositionOffset_ = offset;
  if (mPendingSavedState_ != nil) {
    [mPendingSavedState_ invalidateAnchor];
  }
  [self requestLayout];
}

- (jint)scrollHorizontallyByWithInt:(jint)dx
       withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
          withADXRecyclerView_State:(ADXRecyclerView_State *)state {
  if (mOrientation_ == ADXLinearLayoutManager_VERTICAL) {
    return 0;
  }
  return [self scrollByWithInt:dx withADXRecyclerView_Recycler:recycler withADXRecyclerView_State:state];
}

- (jint)scrollVerticallyByWithInt:(jint)dy
     withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
        withADXRecyclerView_State:(ADXRecyclerView_State *)state {
  if (mOrientation_ == ADXLinearLayoutManager_HORIZONTAL) {
    return 0;
  }
  return [self scrollByWithInt:dy withADXRecyclerView_Recycler:recycler withADXRecyclerView_State:state];
}

- (jint)computeHorizontalScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return ADXLinearLayoutManager_computeScrollOffsetWithADXRecyclerView_State_(self, state);
}

- (jint)computeVerticalScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return ADXLinearLayoutManager_computeScrollOffsetWithADXRecyclerView_State_(self, state);
}

- (jint)computeHorizontalScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return ADXLinearLayoutManager_computeScrollExtentWithADXRecyclerView_State_(self, state);
}

- (jint)computeVerticalScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return ADXLinearLayoutManager_computeScrollExtentWithADXRecyclerView_State_(self, state);
}

- (jint)computeHorizontalScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return ADXLinearLayoutManager_computeScrollRangeWithADXRecyclerView_State_(self, state);
}

- (jint)computeVerticalScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return ADXLinearLayoutManager_computeScrollRangeWithADXRecyclerView_State_(self, state);
}

- (jint)computeScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return ADXLinearLayoutManager_computeScrollOffsetWithADXRecyclerView_State_(self, state);
}

- (jint)computeScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return ADXLinearLayoutManager_computeScrollExtentWithADXRecyclerView_State_(self, state);
}

- (jint)computeScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return ADXLinearLayoutManager_computeScrollRangeWithADXRecyclerView_State_(self, state);
}

- (void)setSmoothScrollbarEnabledWithBoolean:(jboolean)enabled {
  mSmoothScrollbarEnabled_ = enabled;
}

- (jboolean)isSmoothScrollbarEnabled {
  return mSmoothScrollbarEnabled_;
}

- (void)updateLayoutStateWithInt:(jint)layoutDirection
                         withInt:(jint)requiredSpace
                     withBoolean:(jboolean)canUseExistingSpace
       withADXRecyclerView_State:(ADXRecyclerView_State *)state {
  ADXLinearLayoutManager_updateLayoutStateWithInt_withInt_withBoolean_withADXRecyclerView_State_(self, layoutDirection, requiredSpace, canUseExistingSpace, state);
}

- (jboolean)resolveIsInfinite {
  return [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getMode] == ADView_MeasureSpec_UNSPECIFIED && [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEnd] == 0;
}

- (void)collectPrefetchPositionsForLayoutStateWithADXRecyclerView_State:(ADXRecyclerView_State *)state
                                 withADXLinearLayoutManager_LayoutState:(ADXLinearLayoutManager_LayoutState *)layoutState
               withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:(id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>)layoutPrefetchRegistry {
  jint pos = ((ADXLinearLayoutManager_LayoutState *) nil_chk(layoutState))->mCurrentPosition_;
  if (pos >= 0 && pos < [((ADXRecyclerView_State *) nil_chk(state)) getItemCount]) {
    [((id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>) nil_chk(layoutPrefetchRegistry)) addPositionWithInt:pos withInt:JavaLangMath_maxWithInt_withInt_(0, layoutState->mScrollingOffset_)];
  }
}

- (void)collectInitialPrefetchPositionsWithInt:(jint)adapterItemCount
withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:(id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>)layoutPrefetchRegistry {
  jboolean fromEnd;
  jint anchorPos;
  if (mPendingSavedState_ != nil && [mPendingSavedState_ hasValidAnchor]) {
    fromEnd = mPendingSavedState_->mAnchorLayoutFromEnd_;
    anchorPos = mPendingSavedState_->mAnchorPosition_;
  }
  else {
    ADXLinearLayoutManager_resolveShouldLayoutReverse(self);
    fromEnd = mShouldReverseLayout_;
    if (mPendingScrollPosition_ == ADXRecyclerView_NO_POSITION) {
      anchorPos = fromEnd ? adapterItemCount - 1 : 0;
    }
    else {
      anchorPos = mPendingScrollPosition_;
    }
  }
  jint direction = fromEnd ? ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD : ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL;
  jint targetPos = anchorPos;
  for (jint i = 0; i < mInitialPrefetchItemCount_; i++) {
    if (targetPos >= 0 && targetPos < adapterItemCount) {
      [((id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>) nil_chk(layoutPrefetchRegistry)) addPositionWithInt:targetPos withInt:0];
    }
    else {
      break;
    }
    targetPos += direction;
  }
}

- (void)setInitialPrefetchItemCountWithInt:(jint)itemCount {
  mInitialPrefetchItemCount_ = itemCount;
}

- (jint)getInitialPrefetchItemCount {
  return mInitialPrefetchItemCount_;
}

- (void)collectAdjacentPrefetchPositionsWithInt:(jint)dx
                                        withInt:(jint)dy
                      withADXRecyclerView_State:(ADXRecyclerView_State *)state
withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:(id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>)layoutPrefetchRegistry {
  jint delta = (mOrientation_ == ADXLinearLayoutManager_HORIZONTAL) ? dx : dy;
  if ([self getChildCount] == 0 || delta == 0) {
    return;
  }
  [self ensureLayoutState];
  jint layoutDirection = delta > 0 ? ADXLinearLayoutManager_LayoutState_LAYOUT_END : ADXLinearLayoutManager_LayoutState_LAYOUT_START;
  jint absDelta = JavaLangMath_absWithInt_(delta);
  ADXLinearLayoutManager_updateLayoutStateWithInt_withInt_withBoolean_withADXRecyclerView_State_(self, layoutDirection, absDelta, true, state);
  [self collectPrefetchPositionsForLayoutStateWithADXRecyclerView_State:state withADXLinearLayoutManager_LayoutState:mLayoutState_ withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:layoutPrefetchRegistry];
}

- (jint)scrollByWithInt:(jint)delta
withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
withADXRecyclerView_State:(ADXRecyclerView_State *)state {
  if ([self getChildCount] == 0 || delta == 0) {
    return 0;
  }
  [self ensureLayoutState];
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mRecycle_ = true;
  jint layoutDirection = delta > 0 ? ADXLinearLayoutManager_LayoutState_LAYOUT_END : ADXLinearLayoutManager_LayoutState_LAYOUT_START;
  jint absDelta = JavaLangMath_absWithInt_(delta);
  ADXLinearLayoutManager_updateLayoutStateWithInt_withInt_withBoolean_withADXRecyclerView_State_(self, layoutDirection, absDelta, true, state);
  jint consumed = ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mScrollingOffset_ + [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:mLayoutState_ withADXRecyclerView_State:state withBoolean:false];
  if (consumed < 0) {
    return 0;
  }
  jint scrolled = absDelta > consumed ? layoutDirection * consumed : delta;
  [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) offsetChildrenWithInt:-scrolled];
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mLastScrollDelta_ = scrolled;
  return scrolled;
}

- (void)assertNotInLayoutOrScrollWithNSString:(NSString *)message {
  if (mPendingSavedState_ == nil) {
    [super assertNotInLayoutOrScrollWithNSString:message];
  }
}

- (void)recycleChildrenWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                            withInt:(jint)startIndex
                                            withInt:(jint)endIndex {
  ADXLinearLayoutManager_recycleChildrenWithADXRecyclerView_Recycler_withInt_withInt_(self, recycler, startIndex, endIndex);
}

- (void)recycleViewsFromStartWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                                  withInt:(jint)scrollingOffset
                                                  withInt:(jint)noRecycleSpace {
  ADXLinearLayoutManager_recycleViewsFromStartWithADXRecyclerView_Recycler_withInt_withInt_(self, recycler, scrollingOffset, noRecycleSpace);
}

- (void)recycleViewsFromEndWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                                withInt:(jint)scrollingOffset
                                                withInt:(jint)noRecycleSpace {
  ADXLinearLayoutManager_recycleViewsFromEndWithADXRecyclerView_Recycler_withInt_withInt_(self, recycler, scrollingOffset, noRecycleSpace);
}

- (void)recycleByLayoutStateWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                  withADXLinearLayoutManager_LayoutState:(ADXLinearLayoutManager_LayoutState *)layoutState {
  ADXLinearLayoutManager_recycleByLayoutStateWithADXRecyclerView_Recycler_withADXLinearLayoutManager_LayoutState_(self, recycler, layoutState);
}

- (jint)fillWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
  withADXLinearLayoutManager_LayoutState:(ADXLinearLayoutManager_LayoutState *)layoutState
               withADXRecyclerView_State:(ADXRecyclerView_State *)state
                             withBoolean:(jboolean)stopOnFocusable {
  jint start = ((ADXLinearLayoutManager_LayoutState *) nil_chk(layoutState))->mAvailable_;
  if (layoutState->mScrollingOffset_ != ADXLinearLayoutManager_LayoutState_SCROLLING_OFFSET_NaN) {
    if (layoutState->mAvailable_ < 0) {
      layoutState->mScrollingOffset_ += layoutState->mAvailable_;
    }
    ADXLinearLayoutManager_recycleByLayoutStateWithADXRecyclerView_Recycler_withADXLinearLayoutManager_LayoutState_(self, recycler, layoutState);
  }
  jint remainingSpace = layoutState->mAvailable_ + layoutState->mExtraFillSpace_;
  ADXLinearLayoutManager_LayoutChunkResult *layoutChunkResult = JreRetainedLocalValue(mLayoutChunkResult_);
  while ((layoutState->mInfinite_ || remainingSpace > 0) && [layoutState hasMoreWithADXRecyclerView_State:state]) {
    [((ADXLinearLayoutManager_LayoutChunkResult *) nil_chk(layoutChunkResult)) resetInternal];
    [self layoutChunkWithADXRecyclerView_Recycler:recycler withADXRecyclerView_State:state withADXLinearLayoutManager_LayoutState:layoutState withADXLinearLayoutManager_LayoutChunkResult:layoutChunkResult];
    if (layoutChunkResult->mFinished_) {
      break;
    }
    layoutState->mOffset_ += layoutChunkResult->mConsumed_ * layoutState->mLayoutDirection_;
    if (!layoutChunkResult->mIgnoreConsumed_ || layoutState->mScrapList_ != nil || ![((ADXRecyclerView_State *) nil_chk(state)) isPreLayout]) {
      layoutState->mAvailable_ -= layoutChunkResult->mConsumed_;
      remainingSpace -= layoutChunkResult->mConsumed_;
    }
    if (layoutState->mScrollingOffset_ != ADXLinearLayoutManager_LayoutState_SCROLLING_OFFSET_NaN) {
      layoutState->mScrollingOffset_ += layoutChunkResult->mConsumed_;
      if (layoutState->mAvailable_ < 0) {
        layoutState->mScrollingOffset_ += layoutState->mAvailable_;
      }
      ADXLinearLayoutManager_recycleByLayoutStateWithADXRecyclerView_Recycler_withADXLinearLayoutManager_LayoutState_(self, recycler, layoutState);
    }
    if (stopOnFocusable && layoutChunkResult->mFocusable_) {
      break;
    }
  }
  return start - layoutState->mAvailable_;
}

- (void)layoutChunkWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                      withADXRecyclerView_State:(ADXRecyclerView_State *)state
         withADXLinearLayoutManager_LayoutState:(ADXLinearLayoutManager_LayoutState *)layoutState
   withADXLinearLayoutManager_LayoutChunkResult:(ADXLinearLayoutManager_LayoutChunkResult *)result {
  ADView *view = JreRetainedLocalValue([((ADXLinearLayoutManager_LayoutState *) nil_chk(layoutState)) nextWithADXRecyclerView_Recycler:recycler]);
  if (view == nil) {
    ((ADXLinearLayoutManager_LayoutChunkResult *) nil_chk(result))->mFinished_ = true;
    return;
  }
  ADXRecyclerView_LayoutParams *params = (ADXRecyclerView_LayoutParams *) cast_chk([view getLayoutParams], [ADXRecyclerView_LayoutParams class]);
  if (layoutState->mScrapList_ == nil) {
    if (mShouldReverseLayout_ == (layoutState->mLayoutDirection_ == ADXLinearLayoutManager_LayoutState_LAYOUT_START)) {
      [self addViewWithADView:view];
    }
    else {
      [self addViewWithADView:view withInt:0];
    }
  }
  else {
    if (mShouldReverseLayout_ == (layoutState->mLayoutDirection_ == ADXLinearLayoutManager_LayoutState_LAYOUT_START)) {
      [self addDisappearingViewWithADView:view];
    }
    else {
      [self addDisappearingViewWithADView:view withInt:0];
    }
  }
  [self measureChildWithMarginsWithADView:view withInt:0 withInt:0];
  ((ADXLinearLayoutManager_LayoutChunkResult *) nil_chk(result))->mConsumed_ = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedMeasurementWithADView:view];
  jint left;
  jint top;
  jint right;
  jint bottom;
  if (mOrientation_ == ADXLinearLayoutManager_VERTICAL) {
    if ([self isLayoutRTL]) {
      right = [self getWidth] - [self getPaddingRight];
      left = right - [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedMeasurementInOtherWithADView:view];
    }
    else {
      left = [self getPaddingLeft];
      right = left + [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedMeasurementInOtherWithADView:view];
    }
    if (layoutState->mLayoutDirection_ == ADXLinearLayoutManager_LayoutState_LAYOUT_START) {
      bottom = layoutState->mOffset_;
      top = layoutState->mOffset_ - result->mConsumed_;
    }
    else {
      top = layoutState->mOffset_;
      bottom = layoutState->mOffset_ + result->mConsumed_;
    }
  }
  else {
    top = [self getPaddingTop];
    bottom = top + [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedMeasurementInOtherWithADView:view];
    if (layoutState->mLayoutDirection_ == ADXLinearLayoutManager_LayoutState_LAYOUT_START) {
      right = layoutState->mOffset_;
      left = layoutState->mOffset_ - result->mConsumed_;
    }
    else {
      left = layoutState->mOffset_;
      right = layoutState->mOffset_ + result->mConsumed_;
    }
  }
  [self layoutDecoratedWithMarginsWithADView:view withInt:left withInt:top withInt:right withInt:bottom];
  if ([((ADXRecyclerView_LayoutParams *) nil_chk(params)) isItemRemoved] || [params isItemChanged]) {
    result->mIgnoreConsumed_ = true;
  }
}

- (jboolean)shouldMeasureTwice {
  return [self getHeightMode] != ADView_MeasureSpec_EXACTLY && [self getWidthMode] != ADView_MeasureSpec_EXACTLY && [self hasFlexibleChildInBothOrientations];
}

- (jint)convertFocusDirectionToLayoutDirectionWithInt:(jint)focusDirection {
  switch (focusDirection) {
    case ADView_FOCUS_BACKWARD:
    if (mOrientation_ == ADXLinearLayoutManager_VERTICAL) {
      return ADXLinearLayoutManager_LayoutState_LAYOUT_START;
    }
    else if ([self isLayoutRTL]) {
      return ADXLinearLayoutManager_LayoutState_LAYOUT_END;
    }
    else {
      return ADXLinearLayoutManager_LayoutState_LAYOUT_START;
    }
    case ADView_FOCUS_FORWARD:
    if (mOrientation_ == ADXLinearLayoutManager_VERTICAL) {
      return ADXLinearLayoutManager_LayoutState_LAYOUT_END;
    }
    else if ([self isLayoutRTL]) {
      return ADXLinearLayoutManager_LayoutState_LAYOUT_START;
    }
    else {
      return ADXLinearLayoutManager_LayoutState_LAYOUT_END;
    }
    case ADView_FOCUS_UP:
    return mOrientation_ == ADXLinearLayoutManager_VERTICAL ? ADXLinearLayoutManager_LayoutState_LAYOUT_START : ADXLinearLayoutManager_LayoutState_INVALID_LAYOUT;
    case ADView_FOCUS_DOWN:
    return mOrientation_ == ADXLinearLayoutManager_VERTICAL ? ADXLinearLayoutManager_LayoutState_LAYOUT_END : ADXLinearLayoutManager_LayoutState_INVALID_LAYOUT;
    case ADView_FOCUS_LEFT:
    return mOrientation_ == ADXLinearLayoutManager_HORIZONTAL ? ADXLinearLayoutManager_LayoutState_LAYOUT_START : ADXLinearLayoutManager_LayoutState_INVALID_LAYOUT;
    case ADView_FOCUS_RIGHT:
    return mOrientation_ == ADXLinearLayoutManager_HORIZONTAL ? ADXLinearLayoutManager_LayoutState_LAYOUT_END : ADXLinearLayoutManager_LayoutState_INVALID_LAYOUT;
    default:
    return ADXLinearLayoutManager_LayoutState_INVALID_LAYOUT;
  }
}

- (ADView *)getChildClosestToStart {
  return ADXLinearLayoutManager_getChildClosestToStart(self);
}

- (ADView *)getChildClosestToEnd {
  return ADXLinearLayoutManager_getChildClosestToEnd(self);
}

- (ADView *)findFirstVisibleChildClosestToStartWithBoolean:(jboolean)completelyVisible
                                               withBoolean:(jboolean)acceptPartiallyVisible {
  if (mShouldReverseLayout_) {
    return [self findOneVisibleChildWithInt:[self getChildCount] - 1 withInt:-1 withBoolean:completelyVisible withBoolean:acceptPartiallyVisible];
  }
  else {
    return [self findOneVisibleChildWithInt:0 withInt:[self getChildCount] withBoolean:completelyVisible withBoolean:acceptPartiallyVisible];
  }
}

- (ADView *)findFirstVisibleChildClosestToEndWithBoolean:(jboolean)completelyVisible
                                             withBoolean:(jboolean)acceptPartiallyVisible {
  if (mShouldReverseLayout_) {
    return [self findOneVisibleChildWithInt:0 withInt:[self getChildCount] withBoolean:completelyVisible withBoolean:acceptPartiallyVisible];
  }
  else {
    return [self findOneVisibleChildWithInt:[self getChildCount] - 1 withInt:-1 withBoolean:completelyVisible withBoolean:acceptPartiallyVisible];
  }
}

- (ADView *)findReferenceChildWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                                 withADXRecyclerView_State:(ADXRecyclerView_State *)state
                                               withBoolean:(jboolean)layoutFromEnd
                                               withBoolean:(jboolean)traverseChildrenInReverseOrder {
  [self ensureLayoutState];
  jint start = 0;
  jint end = [self getChildCount];
  jint diff = 1;
  if (traverseChildrenInReverseOrder) {
    start = [self getChildCount] - 1;
    end = -1;
    diff = -1;
  }
  jint itemCount = [((ADXRecyclerView_State *) nil_chk(state)) getItemCount];
  jint boundsStart = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getStartAfterPadding];
  jint boundsEnd = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding];
  ADView *invalidMatch = nil;
  ADView *bestFirstFind = nil;
  ADView *bestSecondFind = nil;
  for (jint i = start; i != end; i += diff) {
    ADView *view = [self getChildAtWithInt:i];
    jint position = [self getPositionWithADView:view];
    jint childStart = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:view];
    jint childEnd = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedEndWithADView:view];
    if (position >= 0 && position < itemCount) {
      if ([((ADXRecyclerView_LayoutParams *) nil_chk(((ADXRecyclerView_LayoutParams *) cast_chk([((ADView *) nil_chk(view)) getLayoutParams], [ADXRecyclerView_LayoutParams class])))) isItemRemoved]) {
        if (invalidMatch == nil) {
          invalidMatch = view;
        }
      }
      else {
        jboolean outOfBoundsBefore = childEnd <= boundsStart && childStart < boundsStart;
        jboolean outOfBoundsAfter = childStart >= boundsEnd && childEnd > boundsEnd;
        if (outOfBoundsBefore || outOfBoundsAfter) {
          if (layoutFromEnd) {
            if (outOfBoundsAfter) {
              bestFirstFind = view;
            }
            else if (bestSecondFind == nil) {
              bestSecondFind = view;
            }
          }
          else {
            if (outOfBoundsBefore) {
              bestFirstFind = view;
            }
            else if (bestSecondFind == nil) {
              bestSecondFind = view;
            }
          }
        }
        else {
          return view;
        }
      }
    }
  }
  return bestSecondFind != nil ? bestSecondFind : (bestFirstFind != nil ? bestFirstFind : invalidMatch);
}

- (ADView *)findPartiallyOrCompletelyInvisibleChildClosestToEnd {
  return ADXLinearLayoutManager_findPartiallyOrCompletelyInvisibleChildClosestToEnd(self);
}

- (ADView *)findPartiallyOrCompletelyInvisibleChildClosestToStart {
  return ADXLinearLayoutManager_findPartiallyOrCompletelyInvisibleChildClosestToStart(self);
}

- (ADView *)findFirstPartiallyOrCompletelyInvisibleChild {
  return ADXLinearLayoutManager_findFirstPartiallyOrCompletelyInvisibleChild(self);
}

- (ADView *)findLastPartiallyOrCompletelyInvisibleChild {
  return ADXLinearLayoutManager_findLastPartiallyOrCompletelyInvisibleChild(self);
}

- (jint)findFirstVisibleItemPosition {
  ADView *child = [self findOneVisibleChildWithInt:0 withInt:[self getChildCount] withBoolean:false withBoolean:true];
  return child == nil ? ADXRecyclerView_NO_POSITION : [self getPositionWithADView:child];
}

- (jint)findFirstCompletelyVisibleItemPosition {
  ADView *child = [self findOneVisibleChildWithInt:0 withInt:[self getChildCount] withBoolean:true withBoolean:false];
  return child == nil ? ADXRecyclerView_NO_POSITION : [self getPositionWithADView:child];
}

- (jint)findLastVisibleItemPosition {
  ADView *child = [self findOneVisibleChildWithInt:[self getChildCount] - 1 withInt:-1 withBoolean:false withBoolean:true];
  return child == nil ? ADXRecyclerView_NO_POSITION : [self getPositionWithADView:child];
}

- (jint)findLastCompletelyVisibleItemPosition {
  ADView *child = [self findOneVisibleChildWithInt:[self getChildCount] - 1 withInt:-1 withBoolean:true withBoolean:false];
  return child == nil ? ADXRecyclerView_NO_POSITION : [self getPositionWithADView:child];
}

- (ADView *)findOneVisibleChildWithInt:(jint)fromIndex
                               withInt:(jint)toIndex
                           withBoolean:(jboolean)completelyVisible
                           withBoolean:(jboolean)acceptPartiallyVisible {
  [self ensureLayoutState];
  jint preferredBoundsFlag = 0;
  jint acceptableBoundsFlag = 0;
  if (completelyVisible) {
    preferredBoundsFlag = (ADXViewBoundsCheck_FLAG_CVS_GT_PVS | ADXViewBoundsCheck_FLAG_CVS_EQ_PVS | ADXViewBoundsCheck_FLAG_CVE_LT_PVE | ADXViewBoundsCheck_FLAG_CVE_EQ_PVE);
  }
  else {
    preferredBoundsFlag = (ADXViewBoundsCheck_FLAG_CVS_LT_PVE | ADXViewBoundsCheck_FLAG_CVE_GT_PVS);
  }
  if (acceptPartiallyVisible) {
    acceptableBoundsFlag = (ADXViewBoundsCheck_FLAG_CVS_LT_PVE | ADXViewBoundsCheck_FLAG_CVE_GT_PVS);
  }
  return (mOrientation_ == ADXLinearLayoutManager_HORIZONTAL) ? [((ADXViewBoundsCheck *) nil_chk(mHorizontalBoundCheck_)) findOneViewWithinBoundFlagsWithInt:fromIndex withInt:toIndex withInt:preferredBoundsFlag withInt:acceptableBoundsFlag] : [((ADXViewBoundsCheck *) nil_chk(mVerticalBoundCheck_)) findOneViewWithinBoundFlagsWithInt:fromIndex withInt:toIndex withInt:preferredBoundsFlag withInt:acceptableBoundsFlag];
}

- (ADView *)findOnePartiallyOrCompletelyInvisibleChildWithInt:(jint)fromIndex
                                                      withInt:(jint)toIndex {
  [self ensureLayoutState];
  jint next = toIndex > fromIndex ? 1 : (toIndex < fromIndex ? -1 : 0);
  if (next == 0) {
    return [self getChildAtWithInt:fromIndex];
  }
  jint preferredBoundsFlag = 0;
  jint acceptableBoundsFlag = 0;
  if ([((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:[self getChildAtWithInt:fromIndex]] < [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getStartAfterPadding]) {
    preferredBoundsFlag = (ADXViewBoundsCheck_FLAG_CVS_LT_PVS | ADXViewBoundsCheck_FLAG_CVE_LT_PVE | ADXViewBoundsCheck_FLAG_CVE_GT_PVS);
    acceptableBoundsFlag = (ADXViewBoundsCheck_FLAG_CVS_LT_PVS | ADXViewBoundsCheck_FLAG_CVE_LT_PVE);
  }
  else {
    preferredBoundsFlag = (ADXViewBoundsCheck_FLAG_CVE_GT_PVE | ADXViewBoundsCheck_FLAG_CVS_GT_PVS | ADXViewBoundsCheck_FLAG_CVS_LT_PVE);
    acceptableBoundsFlag = (ADXViewBoundsCheck_FLAG_CVE_GT_PVE | ADXViewBoundsCheck_FLAG_CVS_GT_PVS);
  }
  return (mOrientation_ == ADXLinearLayoutManager_HORIZONTAL) ? [((ADXViewBoundsCheck *) nil_chk(mHorizontalBoundCheck_)) findOneViewWithinBoundFlagsWithInt:fromIndex withInt:toIndex withInt:preferredBoundsFlag withInt:acceptableBoundsFlag] : [((ADXViewBoundsCheck *) nil_chk(mVerticalBoundCheck_)) findOneViewWithinBoundFlagsWithInt:fromIndex withInt:toIndex withInt:preferredBoundsFlag withInt:acceptableBoundsFlag];
}

- (ADView *)onFocusSearchFailedWithADView:(ADView *)focused
                                  withInt:(jint)direction
             withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                withADXRecyclerView_State:(ADXRecyclerView_State *)state {
  ADXLinearLayoutManager_resolveShouldLayoutReverse(self);
  if ([self getChildCount] == 0) {
    return nil;
  }
  jint layoutDir = [self convertFocusDirectionToLayoutDirectionWithInt:direction];
  if (layoutDir == ADXLinearLayoutManager_LayoutState_INVALID_LAYOUT) {
    return nil;
  }
  [self ensureLayoutState];
  jint maxScroll = JreFpToInt((ADXLinearLayoutManager_MAX_SCROLL_FACTOR * [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getTotalSpace]));
  ADXLinearLayoutManager_updateLayoutStateWithInt_withInt_withBoolean_withADXRecyclerView_State_(self, layoutDir, maxScroll, false, state);
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(mLayoutState_))->mScrollingOffset_ = ADXLinearLayoutManager_LayoutState_SCROLLING_OFFSET_NaN;
  mLayoutState_->mRecycle_ = false;
  [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:mLayoutState_ withADXRecyclerView_State:state withBoolean:true];
  ADView *nextCandidate;
  if (layoutDir == ADXLinearLayoutManager_LayoutState_LAYOUT_START) {
    nextCandidate = ADXLinearLayoutManager_findPartiallyOrCompletelyInvisibleChildClosestToStart(self);
  }
  else {
    nextCandidate = ADXLinearLayoutManager_findPartiallyOrCompletelyInvisibleChildClosestToEnd(self);
  }
  ADView *nextFocus;
  if (layoutDir == ADXLinearLayoutManager_LayoutState_LAYOUT_START) {
    nextFocus = ADXLinearLayoutManager_getChildClosestToStart(self);
  }
  else {
    nextFocus = ADXLinearLayoutManager_getChildClosestToEnd(self);
  }
  return nextCandidate;
}

- (void)logChildren {
  ADXLinearLayoutManager_logChildren(self);
}

- (void)validateChildOrder {
  ADLog_dWithNSString_withNSString_(ADXLinearLayoutManager_TAG, JreStrcat("$I", @"validating child count ", [self getChildCount]));
  if ([self getChildCount] < 1) {
    return;
  }
  jint lastPos = [self getPositionWithADView:[self getChildAtWithInt:0]];
  jint lastScreenLoc = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:[self getChildAtWithInt:0]];
  if (mShouldReverseLayout_) {
    for (jint i = 1; i < [self getChildCount]; i++) {
      ADView *child = JreRetainedLocalValue([self getChildAtWithInt:i]);
      jint pos = [self getPositionWithADView:child];
      jint screenLoc = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:child];
      if (pos < lastPos) {
        ADXLinearLayoutManager_logChildren(self);
        @throw create_JavaLangRuntimeException_initWithNSString_(JreStrcat("$Z", @"detected invalid position. loc invalid? ", (screenLoc < lastScreenLoc)));
      }
      if (screenLoc > lastScreenLoc) {
        ADXLinearLayoutManager_logChildren(self);
        @throw create_JavaLangRuntimeException_initWithNSString_(@"detected invalid location");
      }
    }
  }
  else {
    for (jint i = 1; i < [self getChildCount]; i++) {
      ADView *child = JreRetainedLocalValue([self getChildAtWithInt:i]);
      jint pos = [self getPositionWithADView:child];
      jint screenLoc = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:child];
      if (pos < lastPos) {
        ADXLinearLayoutManager_logChildren(self);
        @throw create_JavaLangRuntimeException_initWithNSString_(JreStrcat("$Z", @"detected invalid position. loc invalid? ", (screenLoc < lastScreenLoc)));
      }
      if (screenLoc < lastScreenLoc) {
        ADXLinearLayoutManager_logChildren(self);
        @throw create_JavaLangRuntimeException_initWithNSString_(@"detected invalid location");
      }
    }
  }
}

- (jboolean)supportsPredictiveItemAnimations {
  return mPendingSavedState_ == nil && mLastStackFromEnd_ == mStackFromEnd_;
}

- (void)prepareForDropWithADView:(ADView *)view
                      withADView:(ADView *)target
                         withInt:(jint)x
                         withInt:(jint)y {
  [self assertNotInLayoutOrScrollWithNSString:@"Cannot drop a view during a scroll or layout calculation"];
  [self ensureLayoutState];
  ADXLinearLayoutManager_resolveShouldLayoutReverse(self);
  jint myPos = [self getPositionWithADView:view];
  jint targetPos = [self getPositionWithADView:target];
  jint dropDirection = myPos < targetPos ? ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL : ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD;
  if (mShouldReverseLayout_) {
    if (dropDirection == ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL) {
      [self scrollToPositionWithOffsetWithInt:targetPos withInt:[((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] - ([((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:target] + [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedMeasurementWithADView:view])];
    }
    else {
      [self scrollToPositionWithOffsetWithInt:targetPos withInt:[((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] - [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedEndWithADView:target]];
    }
  }
  else {
    if (dropDirection == ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD) {
      [self scrollToPositionWithOffsetWithInt:targetPos withInt:[((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:target]];
    }
    else {
      [self scrollToPositionWithOffsetWithInt:targetPos withInt:[((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedEndWithADView:target] - [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedMeasurementWithADView:view]];
    }
  }
}

- (void)dealloc {
  RELEASE_(mLayoutState_);
  RELEASE_(mOrientationHelper_);
  RELEASE_(mPendingSavedState_);
  RELEASE_(mAnchorInfo_);
  RELEASE_(mLayoutChunkResult_);
  RELEASE_(mReusableIntPair_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXRecyclerView_LayoutParams;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "LADParcelable;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 3, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x1, 12, 10, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 13, 14, -1, -1, 15, -1 },
    { NULL, "V", 0x4, 16, 17, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 18, 19, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 20, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 21, 22, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 23, 24, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 25, 26, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 27, 26, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 28, 29, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 30, 31, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 32, 31, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 33, 34, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 33, 35, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 36, 34, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 36, 35, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXLinearLayoutManager_LayoutState;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 37, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 38, 35, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 39, 40, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 41, 40, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 42, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 43, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 44, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 45, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 46, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 47, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 48, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 49, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 50, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 51, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 52, 53, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 54, 55, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 56, 57, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 58, 10, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 59, 60, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 61, 40, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 62, 63, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 64, 65, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 66, 65, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 67, 65, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 68, 69, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 70, 71, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 72, 73, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 74, 10, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x0, 75, 76, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x0, 77, 76, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x0, 78, 79, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x0, 80, 81, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x0, 82, 35, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x1, 83, 84, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 85, 86, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADContext:);
  methods[1].selector = @selector(initWithADContext:withInt:withBoolean:);
  methods[2].selector = @selector(isAutoMeasureEnabled);
  methods[3].selector = @selector(generateDefaultLayoutParams);
  methods[4].selector = @selector(getRecycleChildrenOnDetach);
  methods[5].selector = @selector(setRecycleChildrenOnDetachWithBoolean:);
  methods[6].selector = @selector(onDetachedFromWindowWithADXRecyclerView:withADXRecyclerView_Recycler:);
  methods[7].selector = @selector(onSaveInstanceState);
  methods[8].selector = @selector(onRestoreInstanceStateWithADParcelable:);
  methods[9].selector = @selector(canScrollHorizontally);
  methods[10].selector = @selector(canScrollVertically);
  methods[11].selector = @selector(setStackFromEndWithBoolean:);
  methods[12].selector = @selector(getStackFromEnd);
  methods[13].selector = @selector(getOrientation);
  methods[14].selector = @selector(setOrientationWithInt:);
  methods[15].selector = @selector(resolveShouldLayoutReverse);
  methods[16].selector = @selector(getReverseLayout);
  methods[17].selector = @selector(setReverseLayoutWithBoolean:);
  methods[18].selector = @selector(findViewByPositionWithInt:);
  methods[19].selector = @selector(getExtraLayoutSpaceWithADXRecyclerView_State:);
  methods[20].selector = @selector(calculateExtraLayoutSpaceWithADXRecyclerView_State:withIntArray:);
  methods[21].selector = @selector(onLayoutChildrenWithADXRecyclerView_Recycler:withADXRecyclerView_State:);
  methods[22].selector = @selector(onLayoutCompletedWithADXRecyclerView_State:);
  methods[23].selector = @selector(onAnchorReadyWithADXRecyclerView_Recycler:withADXRecyclerView_State:withADXLinearLayoutManager_AnchorInfo:withInt:);
  methods[24].selector = @selector(layoutForPredictiveAnimationsWithADXRecyclerView_Recycler:withADXRecyclerView_State:withInt:withInt:);
  methods[25].selector = @selector(updateAnchorInfoForLayoutWithADXRecyclerView_Recycler:withADXRecyclerView_State:withADXLinearLayoutManager_AnchorInfo:);
  methods[26].selector = @selector(updateAnchorFromChildrenWithADXRecyclerView_Recycler:withADXRecyclerView_State:withADXLinearLayoutManager_AnchorInfo:);
  methods[27].selector = @selector(updateAnchorFromPendingDataWithADXRecyclerView_State:withADXLinearLayoutManager_AnchorInfo:);
  methods[28].selector = @selector(fixLayoutEndGapWithInt:withADXRecyclerView_Recycler:withADXRecyclerView_State:withBoolean:);
  methods[29].selector = @selector(fixLayoutStartGapWithInt:withADXRecyclerView_Recycler:withADXRecyclerView_State:withBoolean:);
  methods[30].selector = @selector(updateLayoutStateToFillEndWithADXLinearLayoutManager_AnchorInfo:);
  methods[31].selector = @selector(updateLayoutStateToFillEndWithInt:withInt:);
  methods[32].selector = @selector(updateLayoutStateToFillStartWithADXLinearLayoutManager_AnchorInfo:);
  methods[33].selector = @selector(updateLayoutStateToFillStartWithInt:withInt:);
  methods[34].selector = @selector(isLayoutRTL);
  methods[35].selector = @selector(ensureLayoutState);
  methods[36].selector = @selector(createLayoutState);
  methods[37].selector = @selector(scrollToPositionWithInt:);
  methods[38].selector = @selector(scrollToPositionWithOffsetWithInt:withInt:);
  methods[39].selector = @selector(scrollHorizontallyByWithInt:withADXRecyclerView_Recycler:withADXRecyclerView_State:);
  methods[40].selector = @selector(scrollVerticallyByWithInt:withADXRecyclerView_Recycler:withADXRecyclerView_State:);
  methods[41].selector = @selector(computeHorizontalScrollOffsetWithADXRecyclerView_State:);
  methods[42].selector = @selector(computeVerticalScrollOffsetWithADXRecyclerView_State:);
  methods[43].selector = @selector(computeHorizontalScrollExtentWithADXRecyclerView_State:);
  methods[44].selector = @selector(computeVerticalScrollExtentWithADXRecyclerView_State:);
  methods[45].selector = @selector(computeHorizontalScrollRangeWithADXRecyclerView_State:);
  methods[46].selector = @selector(computeVerticalScrollRangeWithADXRecyclerView_State:);
  methods[47].selector = @selector(computeScrollOffsetWithADXRecyclerView_State:);
  methods[48].selector = @selector(computeScrollExtentWithADXRecyclerView_State:);
  methods[49].selector = @selector(computeScrollRangeWithADXRecyclerView_State:);
  methods[50].selector = @selector(setSmoothScrollbarEnabledWithBoolean:);
  methods[51].selector = @selector(isSmoothScrollbarEnabled);
  methods[52].selector = @selector(updateLayoutStateWithInt:withInt:withBoolean:withADXRecyclerView_State:);
  methods[53].selector = @selector(resolveIsInfinite);
  methods[54].selector = @selector(collectPrefetchPositionsForLayoutStateWithADXRecyclerView_State:withADXLinearLayoutManager_LayoutState:withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:);
  methods[55].selector = @selector(collectInitialPrefetchPositionsWithInt:withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:);
  methods[56].selector = @selector(setInitialPrefetchItemCountWithInt:);
  methods[57].selector = @selector(getInitialPrefetchItemCount);
  methods[58].selector = @selector(collectAdjacentPrefetchPositionsWithInt:withInt:withADXRecyclerView_State:withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:);
  methods[59].selector = @selector(scrollByWithInt:withADXRecyclerView_Recycler:withADXRecyclerView_State:);
  methods[60].selector = @selector(assertNotInLayoutOrScrollWithNSString:);
  methods[61].selector = @selector(recycleChildrenWithADXRecyclerView_Recycler:withInt:withInt:);
  methods[62].selector = @selector(recycleViewsFromStartWithADXRecyclerView_Recycler:withInt:withInt:);
  methods[63].selector = @selector(recycleViewsFromEndWithADXRecyclerView_Recycler:withInt:withInt:);
  methods[64].selector = @selector(recycleByLayoutStateWithADXRecyclerView_Recycler:withADXLinearLayoutManager_LayoutState:);
  methods[65].selector = @selector(fillWithADXRecyclerView_Recycler:withADXLinearLayoutManager_LayoutState:withADXRecyclerView_State:withBoolean:);
  methods[66].selector = @selector(layoutChunkWithADXRecyclerView_Recycler:withADXRecyclerView_State:withADXLinearLayoutManager_LayoutState:withADXLinearLayoutManager_LayoutChunkResult:);
  methods[67].selector = @selector(shouldMeasureTwice);
  methods[68].selector = @selector(convertFocusDirectionToLayoutDirectionWithInt:);
  methods[69].selector = @selector(getChildClosestToStart);
  methods[70].selector = @selector(getChildClosestToEnd);
  methods[71].selector = @selector(findFirstVisibleChildClosestToStartWithBoolean:withBoolean:);
  methods[72].selector = @selector(findFirstVisibleChildClosestToEndWithBoolean:withBoolean:);
  methods[73].selector = @selector(findReferenceChildWithADXRecyclerView_Recycler:withADXRecyclerView_State:withBoolean:withBoolean:);
  methods[74].selector = @selector(findPartiallyOrCompletelyInvisibleChildClosestToEnd);
  methods[75].selector = @selector(findPartiallyOrCompletelyInvisibleChildClosestToStart);
  methods[76].selector = @selector(findFirstPartiallyOrCompletelyInvisibleChild);
  methods[77].selector = @selector(findLastPartiallyOrCompletelyInvisibleChild);
  methods[78].selector = @selector(findFirstVisibleItemPosition);
  methods[79].selector = @selector(findFirstCompletelyVisibleItemPosition);
  methods[80].selector = @selector(findLastVisibleItemPosition);
  methods[81].selector = @selector(findLastCompletelyVisibleItemPosition);
  methods[82].selector = @selector(findOneVisibleChildWithInt:withInt:withBoolean:withBoolean:);
  methods[83].selector = @selector(findOnePartiallyOrCompletelyInvisibleChildWithInt:withInt:);
  methods[84].selector = @selector(onFocusSearchFailedWithADView:withInt:withADXRecyclerView_Recycler:withADXRecyclerView_State:);
  methods[85].selector = @selector(logChildren);
  methods[86].selector = @selector(validateChildOrder);
  methods[87].selector = @selector(supportsPredictiveItemAnimations);
  methods[88].selector = @selector(prepareForDropWithADView:withADView:withInt:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 87, -1, -1 },
    { "DEBUG", "Z", .constantValue.asBOOL = ADXLinearLayoutManager_DEBUG, 0x18, -1, -1, -1, -1 },
    { "HORIZONTAL", "I", .constantValue.asInt = ADXLinearLayoutManager_HORIZONTAL, 0x19, -1, -1, -1, -1 },
    { "VERTICAL", "I", .constantValue.asInt = ADXLinearLayoutManager_VERTICAL, 0x19, -1, -1, -1, -1 },
    { "INVALID_OFFSET", "I", .constantValue.asInt = ADXLinearLayoutManager_INVALID_OFFSET, 0x19, -1, -1, -1, -1 },
    { "MAX_SCROLL_FACTOR", "F", .constantValue.asFloat = ADXLinearLayoutManager_MAX_SCROLL_FACTOR, 0x1a, -1, -1, -1, -1 },
    { "mOrientation_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mLayoutState_", "LADXLinearLayoutManager_LayoutState;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mOrientationHelper_", "LADXOrientationHelper;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mLastStackFromEnd_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mReverseLayout_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mShouldReverseLayout_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mStackFromEnd_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mSmoothScrollbarEnabled_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPendingScrollPosition_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mPendingScrollPositionOffset_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mRecycleChildrenOnDetach_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPendingSavedState_", "LADXLinearLayoutManager_SavedState;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mAnchorInfo_", "LADXLinearLayoutManager_AnchorInfo;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "mLayoutChunkResult_", "LADXLinearLayoutManager_LayoutChunkResult;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mInitialPrefetchItemCount_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mReusableIntPair_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADContext;", "LADContext;IZ", "setRecycleChildrenOnDetach", "Z", "onDetachedFromWindow", "LADXRecyclerView;LADXRecyclerView_Recycler;", "onRestoreInstanceState", "LADParcelable;", "setStackFromEnd", "setOrientation", "I", "setReverseLayout", "findViewByPosition", "getExtraLayoutSpace", "LADXRecyclerView_State;", (void *)&ADXLinearLayoutManager__Annotations$0, "calculateExtraLayoutSpace", "LADXRecyclerView_State;[I", "onLayoutChildren", "LADXRecyclerView_Recycler;LADXRecyclerView_State;", "onLayoutCompleted", "onAnchorReady", "LADXRecyclerView_Recycler;LADXRecyclerView_State;LADXLinearLayoutManager_AnchorInfo;I", "layoutForPredictiveAnimations", "LADXRecyclerView_Recycler;LADXRecyclerView_State;II", "updateAnchorInfoForLayout", "LADXRecyclerView_Recycler;LADXRecyclerView_State;LADXLinearLayoutManager_AnchorInfo;", "updateAnchorFromChildren", "updateAnchorFromPendingData", "LADXRecyclerView_State;LADXLinearLayoutManager_AnchorInfo;", "fixLayoutEndGap", "ILADXRecyclerView_Recycler;LADXRecyclerView_State;Z", "fixLayoutStartGap", "updateLayoutStateToFillEnd", "LADXLinearLayoutManager_AnchorInfo;", "II", "updateLayoutStateToFillStart", "scrollToPosition", "scrollToPositionWithOffset", "scrollHorizontallyBy", "ILADXRecyclerView_Recycler;LADXRecyclerView_State;", "scrollVerticallyBy", "computeHorizontalScrollOffset", "computeVerticalScrollOffset", "computeHorizontalScrollExtent", "computeVerticalScrollExtent", "computeHorizontalScrollRange", "computeVerticalScrollRange", "computeScrollOffset", "computeScrollExtent", "computeScrollRange", "setSmoothScrollbarEnabled", "updateLayoutState", "IIZLADXRecyclerView_State;", "collectPrefetchPositionsForLayoutState", "LADXRecyclerView_State;LADXLinearLayoutManager_LayoutState;LADXRecyclerView_LayoutManager_LayoutPrefetchRegistry;", "collectInitialPrefetchPositions", "ILADXRecyclerView_LayoutManager_LayoutPrefetchRegistry;", "setInitialPrefetchItemCount", "collectAdjacentPrefetchPositions", "IILADXRecyclerView_State;LADXRecyclerView_LayoutManager_LayoutPrefetchRegistry;", "scrollBy", "assertNotInLayoutOrScroll", "LNSString;", "recycleChildren", "LADXRecyclerView_Recycler;II", "recycleViewsFromStart", "recycleViewsFromEnd", "recycleByLayoutState", "LADXRecyclerView_Recycler;LADXLinearLayoutManager_LayoutState;", "fill", "LADXRecyclerView_Recycler;LADXLinearLayoutManager_LayoutState;LADXRecyclerView_State;Z", "layoutChunk", "LADXRecyclerView_Recycler;LADXRecyclerView_State;LADXLinearLayoutManager_LayoutState;LADXLinearLayoutManager_LayoutChunkResult;", "convertFocusDirectionToLayoutDirection", "findFirstVisibleChildClosestToStart", "ZZ", "findFirstVisibleChildClosestToEnd", "findReferenceChild", "LADXRecyclerView_Recycler;LADXRecyclerView_State;ZZ", "findOneVisibleChild", "IIZZ", "findOnePartiallyOrCompletelyInvisibleChild", "onFocusSearchFailed", "LADView;ILADXRecyclerView_Recycler;LADXRecyclerView_State;", "prepareForDrop", "LADView;LADView;II", &ADXLinearLayoutManager_TAG, "LADXLinearLayoutManager_LayoutState;LADXLinearLayoutManager_SavedState;LADXLinearLayoutManager_AnchorInfo;LADXLinearLayoutManager_LayoutChunkResult;" };
  static const J2ObjcClassInfo _ADXLinearLayoutManager = { "LinearLayoutManager", "androidx.recyclerview.widget", ptrTable, methods, fields, 7, 0x1, 89, 22, -1, 88, -1, -1, -1 };
  return &_ADXLinearLayoutManager;
}

@end

void ADXLinearLayoutManager_initWithADContext_(ADXLinearLayoutManager *self, ADContext *context) {
  ADXLinearLayoutManager_initWithADContext_withInt_withBoolean_(self, context, ADXRecyclerView_DEFAULT_ORIENTATION, false);
}

ADXLinearLayoutManager *new_ADXLinearLayoutManager_initWithADContext_(ADContext *context) {
  J2OBJC_NEW_IMPL(ADXLinearLayoutManager, initWithADContext_, context)
}

ADXLinearLayoutManager *create_ADXLinearLayoutManager_initWithADContext_(ADContext *context) {
  J2OBJC_CREATE_IMPL(ADXLinearLayoutManager, initWithADContext_, context)
}

void ADXLinearLayoutManager_initWithADContext_withInt_withBoolean_(ADXLinearLayoutManager *self, ADContext *context, jint orientation, jboolean reverseLayout) {
  ADXRecyclerView_LayoutManager_init(self);
  self->mOrientation_ = ADXRecyclerView_DEFAULT_ORIENTATION;
  self->mReverseLayout_ = false;
  self->mShouldReverseLayout_ = false;
  self->mStackFromEnd_ = false;
  self->mSmoothScrollbarEnabled_ = true;
  self->mPendingScrollPosition_ = ADXRecyclerView_NO_POSITION;
  self->mPendingScrollPositionOffset_ = ADXLinearLayoutManager_INVALID_OFFSET;
  JreStrongAssign(&self->mPendingSavedState_, nil);
  JreStrongAssignAndConsume(&self->mAnchorInfo_, new_ADXLinearLayoutManager_AnchorInfo_init());
  JreStrongAssignAndConsume(&self->mLayoutChunkResult_, new_ADXLinearLayoutManager_LayoutChunkResult_init());
  self->mInitialPrefetchItemCount_ = 2;
  JreStrongAssignAndConsume(&self->mReusableIntPair_, [IOSIntArray newArrayWithLength:2]);
  [self setOrientationWithInt:orientation];
  [self setReverseLayoutWithBoolean:reverseLayout];
}

ADXLinearLayoutManager *new_ADXLinearLayoutManager_initWithADContext_withInt_withBoolean_(ADContext *context, jint orientation, jboolean reverseLayout) {
  J2OBJC_NEW_IMPL(ADXLinearLayoutManager, initWithADContext_withInt_withBoolean_, context, orientation, reverseLayout)
}

ADXLinearLayoutManager *create_ADXLinearLayoutManager_initWithADContext_withInt_withBoolean_(ADContext *context, jint orientation, jboolean reverseLayout) {
  J2OBJC_CREATE_IMPL(ADXLinearLayoutManager, initWithADContext_withInt_withBoolean_, context, orientation, reverseLayout)
}

void ADXLinearLayoutManager_resolveShouldLayoutReverse(ADXLinearLayoutManager *self) {
  if (self->mOrientation_ == ADXLinearLayoutManager_VERTICAL || ![self isLayoutRTL]) {
    self->mShouldReverseLayout_ = self->mReverseLayout_;
  }
  else {
    self->mShouldReverseLayout_ = !self->mReverseLayout_;
  }
}

void ADXLinearLayoutManager_layoutForPredictiveAnimationsWithADXRecyclerView_Recycler_withADXRecyclerView_State_withInt_withInt_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, jint startOffset, jint endOffset) {
  if (![((ADXRecyclerView_State *) nil_chk(state)) willRunPredictiveAnimations] || [self getChildCount] == 0 || [state isPreLayout] || ![self supportsPredictiveItemAnimations]) {
    return;
  }
  jint scrapExtraStart = 0;
  jint scrapExtraEnd = 0;
  id<JavaUtilList> scrapList = [((ADXRecyclerView_Recycler *) nil_chk(recycler)) getScrapList];
  jint scrapSize = [((id<JavaUtilList>) nil_chk(scrapList)) size];
  jint firstChildPos = [self getPositionWithADView:[self getChildAtWithInt:0]];
  for (jint i = 0; i < scrapSize; i++) {
    ADXRecyclerView_ViewHolder *scrap = JreRetainedLocalValue([scrapList getWithInt:i]);
    if ([((ADXRecyclerView_ViewHolder *) nil_chk(scrap)) isRemoved]) {
      continue;
    }
    jint position = [scrap getLayoutPosition];
    jint direction = position < firstChildPos != self->mShouldReverseLayout_ ? ADXLinearLayoutManager_LayoutState_LAYOUT_START : ADXLinearLayoutManager_LayoutState_LAYOUT_END;
    if (direction == ADXLinearLayoutManager_LayoutState_LAYOUT_START) {
      scrapExtraStart += [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedMeasurementWithADView:scrap->itemView_];
    }
    else {
      scrapExtraEnd += [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedMeasurementWithADView:scrap->itemView_];
    }
  }
  JreStrongAssign(&((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mScrapList_, scrapList);
  if (scrapExtraStart > 0) {
    ADView *anchor = ADXLinearLayoutManager_getChildClosestToStart(self);
    ADXLinearLayoutManager_updateLayoutStateToFillStartWithInt_withInt_(self, [self getPositionWithADView:anchor], startOffset);
    ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mExtraFillSpace_ = scrapExtraStart;
    self->mLayoutState_->mAvailable_ = 0;
    [self->mLayoutState_ assignPositionFromScrapList];
    [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:self->mLayoutState_ withADXRecyclerView_State:state withBoolean:false];
  }
  if (scrapExtraEnd > 0) {
    ADView *anchor = ADXLinearLayoutManager_getChildClosestToEnd(self);
    ADXLinearLayoutManager_updateLayoutStateToFillEndWithInt_withInt_(self, [self getPositionWithADView:anchor], endOffset);
    ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mExtraFillSpace_ = scrapExtraEnd;
    self->mLayoutState_->mAvailable_ = 0;
    [self->mLayoutState_ assignPositionFromScrapList];
    [self fillWithADXRecyclerView_Recycler:recycler withADXLinearLayoutManager_LayoutState:self->mLayoutState_ withADXRecyclerView_State:state withBoolean:false];
  }
  JreStrongAssign(&((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mScrapList_, nil);
}

void ADXLinearLayoutManager_updateAnchorInfoForLayoutWithADXRecyclerView_Recycler_withADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, ADXLinearLayoutManager_AnchorInfo *anchorInfo) {
  if (ADXLinearLayoutManager_updateAnchorFromPendingDataWithADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(self, state, anchorInfo)) {
    return;
  }
  if (ADXLinearLayoutManager_updateAnchorFromChildrenWithADXRecyclerView_Recycler_withADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(self, recycler, state, anchorInfo)) {
    return;
  }
  [((ADXLinearLayoutManager_AnchorInfo *) nil_chk(anchorInfo)) assignCoordinateFromPadding];
  anchorInfo->mPosition_ = self->mStackFromEnd_ ? [((ADXRecyclerView_State *) nil_chk(state)) getItemCount] - 1 : 0;
}

jboolean ADXLinearLayoutManager_updateAnchorFromChildrenWithADXRecyclerView_Recycler_withADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, ADXLinearLayoutManager_AnchorInfo *anchorInfo) {
  if ([self getChildCount] == 0) {
    return false;
  }
  ADView *focused = nil;
  if (focused != nil && [((ADXLinearLayoutManager_AnchorInfo *) nil_chk(anchorInfo)) isViewValidAsAnchorWithADView:focused withADXRecyclerView_State:state]) {
    [((ADXLinearLayoutManager_AnchorInfo *) nil_chk(anchorInfo)) assignFromViewAndKeepVisibleRectWithADView:focused withInt:[self getPositionWithADView:focused]];
    return true;
  }
  if (self->mLastStackFromEnd_ != self->mStackFromEnd_) {
    return false;
  }
  ADView *referenceChild = JreRetainedLocalValue([self findReferenceChildWithADXRecyclerView_Recycler:recycler withADXRecyclerView_State:state withBoolean:((ADXLinearLayoutManager_AnchorInfo *) nil_chk(anchorInfo))->mLayoutFromEnd_ withBoolean:self->mStackFromEnd_]);
  if (referenceChild != nil) {
    [anchorInfo assignFromViewWithADView:referenceChild withInt:[self getPositionWithADView:referenceChild]];
    if (![((ADXRecyclerView_State *) nil_chk(state)) isPreLayout] && [self supportsPredictiveItemAnimations]) {
      jint childStart = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedStartWithADView:referenceChild];
      jint childEnd = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedEndWithADView:referenceChild];
      jint boundsStart = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding];
      jint boundsEnd = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndAfterPadding];
      jboolean outOfBoundsBefore = childEnd <= boundsStart && childStart < boundsStart;
      jboolean outOfBoundsAfter = childStart >= boundsEnd && childEnd > boundsEnd;
      if (outOfBoundsBefore || outOfBoundsAfter) {
        anchorInfo->mCoordinate_ = anchorInfo->mLayoutFromEnd_ ? boundsEnd : boundsStart;
      }
    }
    return true;
  }
  return false;
}

jboolean ADXLinearLayoutManager_updateAnchorFromPendingDataWithADXRecyclerView_State_withADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXRecyclerView_State *state, ADXLinearLayoutManager_AnchorInfo *anchorInfo) {
  if ([((ADXRecyclerView_State *) nil_chk(state)) isPreLayout] || self->mPendingScrollPosition_ == ADXRecyclerView_NO_POSITION) {
    return false;
  }
  if (self->mPendingScrollPosition_ < 0 || self->mPendingScrollPosition_ >= [state getItemCount]) {
    self->mPendingScrollPosition_ = ADXRecyclerView_NO_POSITION;
    self->mPendingScrollPositionOffset_ = ADXLinearLayoutManager_INVALID_OFFSET;
    return false;
  }
  ((ADXLinearLayoutManager_AnchorInfo *) nil_chk(anchorInfo))->mPosition_ = self->mPendingScrollPosition_;
  if (self->mPendingSavedState_ != nil && [self->mPendingSavedState_ hasValidAnchor]) {
    anchorInfo->mLayoutFromEnd_ = self->mPendingSavedState_->mAnchorLayoutFromEnd_;
    if (anchorInfo->mLayoutFromEnd_) {
      anchorInfo->mCoordinate_ = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndAfterPadding] - ((ADXLinearLayoutManager_SavedState *) nil_chk(self->mPendingSavedState_))->mAnchorOffset_;
    }
    else {
      anchorInfo->mCoordinate_ = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding] + ((ADXLinearLayoutManager_SavedState *) nil_chk(self->mPendingSavedState_))->mAnchorOffset_;
    }
    return true;
  }
  if (self->mPendingScrollPositionOffset_ == ADXLinearLayoutManager_INVALID_OFFSET) {
    ADView *child = JreRetainedLocalValue([self findViewByPositionWithInt:self->mPendingScrollPosition_]);
    if (child != nil) {
      jint childSize = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedMeasurementWithADView:child];
      if (childSize > [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getTotalSpace]) {
        [anchorInfo assignCoordinateFromPadding];
        return true;
      }
      jint startGap = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedStartWithADView:child] - [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding];
      if (startGap < 0) {
        anchorInfo->mCoordinate_ = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding];
        anchorInfo->mLayoutFromEnd_ = false;
        return true;
      }
      jint endGap = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndAfterPadding] - [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedEndWithADView:child];
      if (endGap < 0) {
        anchorInfo->mCoordinate_ = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndAfterPadding];
        anchorInfo->mLayoutFromEnd_ = true;
        return true;
      }
      anchorInfo->mCoordinate_ = anchorInfo->mLayoutFromEnd_ ? ([((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedEndWithADView:child] + [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getTotalSpaceChange]) : [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedStartWithADView:child];
    }
    else {
      if ([self getChildCount] > 0) {
        jint pos = [self getPositionWithADView:[self getChildAtWithInt:0]];
        anchorInfo->mLayoutFromEnd_ = (self->mPendingScrollPosition_ < pos == self->mShouldReverseLayout_);
      }
      [anchorInfo assignCoordinateFromPadding];
    }
    return true;
  }
  anchorInfo->mLayoutFromEnd_ = self->mShouldReverseLayout_;
  if (self->mShouldReverseLayout_) {
    anchorInfo->mCoordinate_ = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndAfterPadding] - self->mPendingScrollPositionOffset_;
  }
  else {
    anchorInfo->mCoordinate_ = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding] + self->mPendingScrollPositionOffset_;
  }
  return true;
}

jint ADXLinearLayoutManager_fixLayoutEndGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(ADXLinearLayoutManager *self, jint endOffset, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, jboolean canOffsetChildren) {
  jint gap = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndAfterPadding] - endOffset;
  jint fixOffset = 0;
  if (gap > 0) {
    fixOffset = -[self scrollByWithInt:-gap withADXRecyclerView_Recycler:recycler withADXRecyclerView_State:state];
  }
  else {
    return 0;
  }
  endOffset += fixOffset;
  if (canOffsetChildren) {
    gap = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndAfterPadding] - endOffset;
    if (gap > 0) {
      [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) offsetChildrenWithInt:gap];
      return gap + fixOffset;
    }
  }
  return fixOffset;
}

jint ADXLinearLayoutManager_fixLayoutStartGapWithInt_withADXRecyclerView_Recycler_withADXRecyclerView_State_withBoolean_(ADXLinearLayoutManager *self, jint startOffset, ADXRecyclerView_Recycler *recycler, ADXRecyclerView_State *state, jboolean canOffsetChildren) {
  jint gap = startOffset - [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding];
  jint fixOffset = 0;
  if (gap > 0) {
    fixOffset = -[self scrollByWithInt:gap withADXRecyclerView_Recycler:recycler withADXRecyclerView_State:state];
  }
  else {
    return 0;
  }
  startOffset += fixOffset;
  if (canOffsetChildren) {
    gap = startOffset - [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding];
    if (gap > 0) {
      [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) offsetChildrenWithInt:-gap];
      return fixOffset - gap;
    }
  }
  return fixOffset;
}

void ADXLinearLayoutManager_updateLayoutStateToFillEndWithADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXLinearLayoutManager_AnchorInfo *anchorInfo) {
  ADXLinearLayoutManager_updateLayoutStateToFillEndWithInt_withInt_(self, ((ADXLinearLayoutManager_AnchorInfo *) nil_chk(anchorInfo))->mPosition_, anchorInfo->mCoordinate_);
}

void ADXLinearLayoutManager_updateLayoutStateToFillEndWithInt_withInt_(ADXLinearLayoutManager *self, jint itemPosition, jint offset) {
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mAvailable_ = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndAfterPadding] - offset;
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mItemDirection_ = self->mShouldReverseLayout_ ? ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD : ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL;
  self->mLayoutState_->mCurrentPosition_ = itemPosition;
  self->mLayoutState_->mLayoutDirection_ = ADXLinearLayoutManager_LayoutState_LAYOUT_END;
  self->mLayoutState_->mOffset_ = offset;
  self->mLayoutState_->mScrollingOffset_ = ADXLinearLayoutManager_LayoutState_SCROLLING_OFFSET_NaN;
}

void ADXLinearLayoutManager_updateLayoutStateToFillStartWithADXLinearLayoutManager_AnchorInfo_(ADXLinearLayoutManager *self, ADXLinearLayoutManager_AnchorInfo *anchorInfo) {
  ADXLinearLayoutManager_updateLayoutStateToFillStartWithInt_withInt_(self, ((ADXLinearLayoutManager_AnchorInfo *) nil_chk(anchorInfo))->mPosition_, anchorInfo->mCoordinate_);
}

void ADXLinearLayoutManager_updateLayoutStateToFillStartWithInt_withInt_(ADXLinearLayoutManager *self, jint itemPosition, jint offset) {
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mAvailable_ = offset - [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding];
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mCurrentPosition_ = itemPosition;
  self->mLayoutState_->mItemDirection_ = self->mShouldReverseLayout_ ? ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL : ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD;
  self->mLayoutState_->mLayoutDirection_ = ADXLinearLayoutManager_LayoutState_LAYOUT_START;
  self->mLayoutState_->mOffset_ = offset;
  self->mLayoutState_->mScrollingOffset_ = ADXLinearLayoutManager_LayoutState_SCROLLING_OFFSET_NaN;
}

jint ADXLinearLayoutManager_computeScrollOffsetWithADXRecyclerView_State_(ADXLinearLayoutManager *self, ADXRecyclerView_State *state) {
  if ([self getChildCount] == 0) {
    return 0;
  }
  [self ensureLayoutState];
  return ADXScrollbarHelper_computeScrollOffsetWithADXRecyclerView_State_withADXOrientationHelper_withADView_withADView_withADXRecyclerView_LayoutManager_withBoolean_withBoolean_(state, self->mOrientationHelper_, [self findFirstVisibleChildClosestToStartWithBoolean:!self->mSmoothScrollbarEnabled_ withBoolean:true], [self findFirstVisibleChildClosestToEndWithBoolean:!self->mSmoothScrollbarEnabled_ withBoolean:true], self, self->mSmoothScrollbarEnabled_, self->mShouldReverseLayout_);
}

jint ADXLinearLayoutManager_computeScrollExtentWithADXRecyclerView_State_(ADXLinearLayoutManager *self, ADXRecyclerView_State *state) {
  if ([self getChildCount] == 0) {
    return 0;
  }
  [self ensureLayoutState];
  return ADXScrollbarHelper_computeScrollExtentWithADXRecyclerView_State_withADXOrientationHelper_withADView_withADView_withADXRecyclerView_LayoutManager_withBoolean_(state, self->mOrientationHelper_, [self findFirstVisibleChildClosestToStartWithBoolean:!self->mSmoothScrollbarEnabled_ withBoolean:true], [self findFirstVisibleChildClosestToEndWithBoolean:!self->mSmoothScrollbarEnabled_ withBoolean:true], self, self->mSmoothScrollbarEnabled_);
}

jint ADXLinearLayoutManager_computeScrollRangeWithADXRecyclerView_State_(ADXLinearLayoutManager *self, ADXRecyclerView_State *state) {
  if ([self getChildCount] == 0) {
    return 0;
  }
  [self ensureLayoutState];
  return ADXScrollbarHelper_computeScrollRangeWithADXRecyclerView_State_withADXOrientationHelper_withADView_withADView_withADXRecyclerView_LayoutManager_withBoolean_(state, self->mOrientationHelper_, [self findFirstVisibleChildClosestToStartWithBoolean:!self->mSmoothScrollbarEnabled_ withBoolean:true], [self findFirstVisibleChildClosestToEndWithBoolean:!self->mSmoothScrollbarEnabled_ withBoolean:true], self, self->mSmoothScrollbarEnabled_);
}

void ADXLinearLayoutManager_updateLayoutStateWithInt_withInt_withBoolean_withADXRecyclerView_State_(ADXLinearLayoutManager *self, jint layoutDirection, jint requiredSpace, jboolean canUseExistingSpace, ADXRecyclerView_State *state) {
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mInfinite_ = [self resolveIsInfinite];
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mLayoutDirection_ = layoutDirection;
  *IOSIntArray_GetRef(nil_chk(self->mReusableIntPair_), 0) = 0;
  *IOSIntArray_GetRef(self->mReusableIntPair_, 1) = 0;
  [self calculateExtraLayoutSpaceWithADXRecyclerView_State:state withIntArray:self->mReusableIntPair_];
  jint extraForStart = JavaLangMath_maxWithInt_withInt_(0, IOSIntArray_Get(nil_chk(self->mReusableIntPair_), 0));
  jint extraForEnd = JavaLangMath_maxWithInt_withInt_(0, IOSIntArray_Get(nil_chk(self->mReusableIntPair_), 1));
  jboolean layoutToEnd = layoutDirection == ADXLinearLayoutManager_LayoutState_LAYOUT_END;
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mExtraFillSpace_ = layoutToEnd ? extraForEnd : extraForStart;
  self->mLayoutState_->mNoRecycleSpace_ = layoutToEnd ? extraForStart : extraForEnd;
  jint scrollingOffset;
  if (layoutToEnd) {
    self->mLayoutState_->mExtraFillSpace_ += [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndPadding];
    ADView *child = ADXLinearLayoutManager_getChildClosestToEnd(self);
    ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mItemDirection_ = self->mShouldReverseLayout_ ? ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD : ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL;
    self->mLayoutState_->mCurrentPosition_ = [self getPositionWithADView:child] + ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mItemDirection_;
    self->mLayoutState_->mOffset_ = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedEndWithADView:child];
    scrollingOffset = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedEndWithADView:child] - [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEndAfterPadding];
  }
  else {
    ADView *child = ADXLinearLayoutManager_getChildClosestToStart(self);
    ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mExtraFillSpace_ += [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding];
    ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mItemDirection_ = self->mShouldReverseLayout_ ? ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL : ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD;
    self->mLayoutState_->mCurrentPosition_ = [self getPositionWithADView:child] + ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mItemDirection_;
    self->mLayoutState_->mOffset_ = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedStartWithADView:child];
    scrollingOffset = -[((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedStartWithADView:child] + [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getStartAfterPadding];
  }
  ((ADXLinearLayoutManager_LayoutState *) nil_chk(self->mLayoutState_))->mAvailable_ = requiredSpace;
  if (canUseExistingSpace) {
    self->mLayoutState_->mAvailable_ -= scrollingOffset;
  }
  self->mLayoutState_->mScrollingOffset_ = scrollingOffset;
}

void ADXLinearLayoutManager_recycleChildrenWithADXRecyclerView_Recycler_withInt_withInt_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, jint startIndex, jint endIndex) {
  if (startIndex == endIndex) {
    return;
  }
  if (endIndex > startIndex) {
    for (jint i = endIndex - 1; i >= startIndex; i--) {
      [self removeAndRecycleViewAtWithInt:i withADXRecyclerView_Recycler:recycler];
    }
  }
  else {
    for (jint i = startIndex; i > endIndex; i--) {
      [self removeAndRecycleViewAtWithInt:i withADXRecyclerView_Recycler:recycler];
    }
  }
}

void ADXLinearLayoutManager_recycleViewsFromStartWithADXRecyclerView_Recycler_withInt_withInt_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, jint scrollingOffset, jint noRecycleSpace) {
  if (scrollingOffset < 0) {
    return;
  }
  jint limit = scrollingOffset - noRecycleSpace;
  jint childCount = [self getChildCount];
  if (self->mShouldReverseLayout_) {
    for (jint i = childCount - 1; i >= 0; i--) {
      ADView *child = JreRetainedLocalValue([self getChildAtWithInt:i]);
      if ([((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedEndWithADView:child] > limit || [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getTransformedEndWithDecorationWithADView:child] > limit) {
        ADXLinearLayoutManager_recycleChildrenWithADXRecyclerView_Recycler_withInt_withInt_(self, recycler, childCount - 1, i);
        return;
      }
    }
  }
  else {
    for (jint i = 0; i < childCount; i++) {
      ADView *child = JreRetainedLocalValue([self getChildAtWithInt:i]);
      if ([((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedEndWithADView:child] > limit || [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getTransformedEndWithDecorationWithADView:child] > limit) {
        ADXLinearLayoutManager_recycleChildrenWithADXRecyclerView_Recycler_withInt_withInt_(self, recycler, 0, i);
        return;
      }
    }
  }
}

void ADXLinearLayoutManager_recycleViewsFromEndWithADXRecyclerView_Recycler_withInt_withInt_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, jint scrollingOffset, jint noRecycleSpace) {
  jint childCount = [self getChildCount];
  if (scrollingOffset < 0) {
    return;
  }
  jint limit = [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getEnd] - scrollingOffset + noRecycleSpace;
  if (self->mShouldReverseLayout_) {
    for (jint i = 0; i < childCount; i++) {
      ADView *child = JreRetainedLocalValue([self getChildAtWithInt:i]);
      if ([((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedStartWithADView:child] < limit || [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getTransformedStartWithDecorationWithADView:child] < limit) {
        ADXLinearLayoutManager_recycleChildrenWithADXRecyclerView_Recycler_withInt_withInt_(self, recycler, 0, i);
        return;
      }
    }
  }
  else {
    for (jint i = childCount - 1; i >= 0; i--) {
      ADView *child = JreRetainedLocalValue([self getChildAtWithInt:i]);
      if ([((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedStartWithADView:child] < limit || [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getTransformedStartWithDecorationWithADView:child] < limit) {
        ADXLinearLayoutManager_recycleChildrenWithADXRecyclerView_Recycler_withInt_withInt_(self, recycler, childCount - 1, i);
        return;
      }
    }
  }
}

void ADXLinearLayoutManager_recycleByLayoutStateWithADXRecyclerView_Recycler_withADXLinearLayoutManager_LayoutState_(ADXLinearLayoutManager *self, ADXRecyclerView_Recycler *recycler, ADXLinearLayoutManager_LayoutState *layoutState) {
  if (!((ADXLinearLayoutManager_LayoutState *) nil_chk(layoutState))->mRecycle_ || layoutState->mInfinite_) {
    return;
  }
  jint scrollingOffset = layoutState->mScrollingOffset_;
  jint noRecycleSpace = layoutState->mNoRecycleSpace_;
  if (layoutState->mLayoutDirection_ == ADXLinearLayoutManager_LayoutState_LAYOUT_START) {
    ADXLinearLayoutManager_recycleViewsFromEndWithADXRecyclerView_Recycler_withInt_withInt_(self, recycler, scrollingOffset, noRecycleSpace);
  }
  else {
    ADXLinearLayoutManager_recycleViewsFromStartWithADXRecyclerView_Recycler_withInt_withInt_(self, recycler, scrollingOffset, noRecycleSpace);
  }
}

ADView *ADXLinearLayoutManager_getChildClosestToStart(ADXLinearLayoutManager *self) {
  return [self getChildAtWithInt:self->mShouldReverseLayout_ ? [self getChildCount] - 1 : 0];
}

ADView *ADXLinearLayoutManager_getChildClosestToEnd(ADXLinearLayoutManager *self) {
  return [self getChildAtWithInt:self->mShouldReverseLayout_ ? 0 : [self getChildCount] - 1];
}

ADView *ADXLinearLayoutManager_findPartiallyOrCompletelyInvisibleChildClosestToEnd(ADXLinearLayoutManager *self) {
  return self->mShouldReverseLayout_ ? ADXLinearLayoutManager_findFirstPartiallyOrCompletelyInvisibleChild(self) : ADXLinearLayoutManager_findLastPartiallyOrCompletelyInvisibleChild(self);
}

ADView *ADXLinearLayoutManager_findPartiallyOrCompletelyInvisibleChildClosestToStart(ADXLinearLayoutManager *self) {
  return self->mShouldReverseLayout_ ? ADXLinearLayoutManager_findLastPartiallyOrCompletelyInvisibleChild(self) : ADXLinearLayoutManager_findFirstPartiallyOrCompletelyInvisibleChild(self);
}

ADView *ADXLinearLayoutManager_findFirstPartiallyOrCompletelyInvisibleChild(ADXLinearLayoutManager *self) {
  return [self findOnePartiallyOrCompletelyInvisibleChildWithInt:0 withInt:[self getChildCount]];
}

ADView *ADXLinearLayoutManager_findLastPartiallyOrCompletelyInvisibleChild(ADXLinearLayoutManager *self) {
  return [self findOnePartiallyOrCompletelyInvisibleChildWithInt:[self getChildCount] - 1 withInt:-1];
}

void ADXLinearLayoutManager_logChildren(ADXLinearLayoutManager *self) {
  ADLog_dWithNSString_withNSString_(ADXLinearLayoutManager_TAG, @"internal representation of views on the screen");
  for (jint i = 0; i < [self getChildCount]; i++) {
    ADView *child = JreRetainedLocalValue([self getChildAtWithInt:i]);
    ADLog_dWithNSString_withNSString_(ADXLinearLayoutManager_TAG, JreStrcat("$I$I", @"item ", [self getPositionWithADView:child], @", coord:", [((ADXOrientationHelper *) nil_chk(self->mOrientationHelper_)) getDecoratedStartWithADView:child]));
  }
  ADLog_dWithNSString_withNSString_(ADXLinearLayoutManager_TAG, @"==============");
}

IOSObjectArray *ADXLinearLayoutManager__Annotations$0() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXLinearLayoutManager)

NSString *ADXLinearLayoutManager_LayoutState_TAG = @"LLM#LayoutState";

@implementation ADXLinearLayoutManager_LayoutState

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXLinearLayoutManager_LayoutState_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (jboolean)hasMoreWithADXRecyclerView_State:(ADXRecyclerView_State *)state {
  return mCurrentPosition_ >= 0 && mCurrentPosition_ < [((ADXRecyclerView_State *) nil_chk(state)) getItemCount];
}

- (ADView *)nextWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler {
  if (mScrapList_ != nil) {
    return ADXLinearLayoutManager_LayoutState_nextViewFromScrapList(self);
  }
  ADView *view = [((ADXRecyclerView_Recycler *) nil_chk(recycler)) getViewForPositionWithInt:mCurrentPosition_];
  mCurrentPosition_ += mItemDirection_;
  return view;
}

- (ADView *)nextViewFromScrapList {
  return ADXLinearLayoutManager_LayoutState_nextViewFromScrapList(self);
}

- (void)assignPositionFromScrapList {
  [self assignPositionFromScrapListWithADView:nil];
}

- (void)assignPositionFromScrapListWithADView:(ADView *)ignore {
  ADView *closest = [self nextViewInLimitedListWithADView:ignore];
  if (closest == nil) {
    mCurrentPosition_ = ADXRecyclerView_NO_POSITION;
  }
  else {
    mCurrentPosition_ = [((ADXRecyclerView_LayoutParams *) nil_chk(((ADXRecyclerView_LayoutParams *) cast_chk([closest getLayoutParams], [ADXRecyclerView_LayoutParams class])))) getViewLayoutPosition];
  }
}

- (ADView *)nextViewInLimitedListWithADView:(ADView *)ignore {
  jint size = [((id<JavaUtilList>) nil_chk(mScrapList_)) size];
  ADView *closest = nil;
  jint closestDistance = JavaLangInteger_MAX_VALUE;
  for (jint i = 0; i < size; i++) {
    ADView *view = JreRetainedLocalValue(((ADXRecyclerView_ViewHolder *) nil_chk([((id<JavaUtilList>) nil_chk(mScrapList_)) getWithInt:i]))->itemView_);
    ADXRecyclerView_LayoutParams *lp = (ADXRecyclerView_LayoutParams *) cast_chk([((ADView *) nil_chk(view)) getLayoutParams], [ADXRecyclerView_LayoutParams class]);
    if (view == ignore || [((ADXRecyclerView_LayoutParams *) nil_chk(lp)) isItemRemoved]) {
      continue;
    }
    jint distance = ([((ADXRecyclerView_LayoutParams *) nil_chk(lp)) getViewLayoutPosition] - mCurrentPosition_) * mItemDirection_;
    if (distance < 0) {
      continue;
    }
    if (distance < closestDistance) {
      closest = view;
      closestDistance = distance;
      if (distance == 0) {
        break;
      }
    }
  }
  return closest;
}

- (void)log {
  ADLog_dWithNSString_withNSString_(ADXLinearLayoutManager_LayoutState_TAG, JreStrcat("$I$I$I$I$I", @"avail:", mAvailable_, @", ind:", mCurrentPosition_, @", dir:", mItemDirection_, @", offset:", mOffset_, @", layoutDir:", mLayoutDirection_));
}

- (void)dealloc {
  RELEASE_(mScrapList_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x0, 2, 3, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x1, 6, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(hasMoreWithADXRecyclerView_State:);
  methods[2].selector = @selector(nextWithADXRecyclerView_Recycler:);
  methods[3].selector = @selector(nextViewFromScrapList);
  methods[4].selector = @selector(assignPositionFromScrapList);
  methods[5].selector = @selector(assignPositionFromScrapListWithADView:);
  methods[6].selector = @selector(nextViewInLimitedListWithADView:);
  methods[7].selector = @selector(log);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x18, -1, 7, -1, -1 },
    { "LAYOUT_START", "I", .constantValue.asInt = ADXLinearLayoutManager_LayoutState_LAYOUT_START, 0x18, -1, -1, -1, -1 },
    { "LAYOUT_END", "I", .constantValue.asInt = ADXLinearLayoutManager_LayoutState_LAYOUT_END, 0x18, -1, -1, -1, -1 },
    { "INVALID_LAYOUT", "I", .constantValue.asInt = ADXLinearLayoutManager_LayoutState_INVALID_LAYOUT, 0x18, -1, -1, -1, -1 },
    { "ITEM_DIRECTION_HEAD", "I", .constantValue.asInt = ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_HEAD, 0x18, -1, -1, -1, -1 },
    { "ITEM_DIRECTION_TAIL", "I", .constantValue.asInt = ADXLinearLayoutManager_LayoutState_ITEM_DIRECTION_TAIL, 0x18, -1, -1, -1, -1 },
    { "SCROLLING_OFFSET_NaN", "I", .constantValue.asInt = ADXLinearLayoutManager_LayoutState_SCROLLING_OFFSET_NaN, 0x18, -1, -1, -1, -1 },
    { "mRecycle_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mOffset_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mAvailable_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCurrentPosition_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mItemDirection_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mLayoutDirection_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mScrollingOffset_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mExtraFillSpace_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mNoRecycleSpace_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mIsPreLayout_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mLastScrollDelta_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mScrapList_", "LJavaUtilList;", .constantValue.asLong = 0, 0x0, -1, -1, 8, -1 },
    { "mInfinite_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "hasMore", "LADXRecyclerView_State;", "next", "LADXRecyclerView_Recycler;", "assignPositionFromScrapList", "LADView;", "nextViewInLimitedList", &ADXLinearLayoutManager_LayoutState_TAG, "Ljava/util/List<Landroidx/recyclerview/widget/RecyclerView$ViewHolder;>;", "LADXLinearLayoutManager;" };
  static const J2ObjcClassInfo _ADXLinearLayoutManager_LayoutState = { "LayoutState", "androidx.recyclerview.widget", ptrTable, methods, fields, 7, 0x8, 8, 20, 9, -1, -1, -1, -1 };
  return &_ADXLinearLayoutManager_LayoutState;
}

@end

void ADXLinearLayoutManager_LayoutState_init(ADXLinearLayoutManager_LayoutState *self) {
  NSObject_init(self);
  self->mRecycle_ = true;
  self->mExtraFillSpace_ = 0;
  self->mNoRecycleSpace_ = 0;
  self->mIsPreLayout_ = false;
  JreStrongAssign(&self->mScrapList_, nil);
}

ADXLinearLayoutManager_LayoutState *new_ADXLinearLayoutManager_LayoutState_init() {
  J2OBJC_NEW_IMPL(ADXLinearLayoutManager_LayoutState, init)
}

ADXLinearLayoutManager_LayoutState *create_ADXLinearLayoutManager_LayoutState_init() {
  J2OBJC_CREATE_IMPL(ADXLinearLayoutManager_LayoutState, init)
}

ADView *ADXLinearLayoutManager_LayoutState_nextViewFromScrapList(ADXLinearLayoutManager_LayoutState *self) {
  jint size = [((id<JavaUtilList>) nil_chk(self->mScrapList_)) size];
  for (jint i = 0; i < size; i++) {
    ADView *view = ((ADXRecyclerView_ViewHolder *) nil_chk([((id<JavaUtilList>) nil_chk(self->mScrapList_)) getWithInt:i]))->itemView_;
    ADXRecyclerView_LayoutParams *lp = (ADXRecyclerView_LayoutParams *) cast_chk([((ADView *) nil_chk(view)) getLayoutParams], [ADXRecyclerView_LayoutParams class]);
    if ([((ADXRecyclerView_LayoutParams *) nil_chk(lp)) isItemRemoved]) {
      continue;
    }
    if (self->mCurrentPosition_ == [lp getViewLayoutPosition]) {
      [self assignPositionFromScrapListWithADView:view];
      return view;
    }
  }
  return nil;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXLinearLayoutManager_LayoutState)

@implementation ADXLinearLayoutManager_SavedState

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXLinearLayoutManager_SavedState_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithADParcel:(id<ADParcel>)inArg {
  ADXLinearLayoutManager_SavedState_initWithADParcel_(self, inArg);
  return self;
}

- (instancetype)initWithADXLinearLayoutManager_SavedState:(ADXLinearLayoutManager_SavedState *)other {
  ADXLinearLayoutManager_SavedState_initWithADXLinearLayoutManager_SavedState_(self, other);
  return self;
}

- (jboolean)hasValidAnchor {
  return mAnchorPosition_ >= 0;
}

- (void)invalidateAnchor {
  mAnchorPosition_ = ADXRecyclerView_NO_POSITION;
}

- (jint)describeContents {
  return 0;
}

- (void)writeToParcelWithADParcel:(id<ADParcel>)dest
                          withInt:(jint)flags {
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithADParcel:);
  methods[2].selector = @selector(initWithADXLinearLayoutManager_SavedState:);
  methods[3].selector = @selector(hasValidAnchor);
  methods[4].selector = @selector(invalidateAnchor);
  methods[5].selector = @selector(describeContents);
  methods[6].selector = @selector(writeToParcelWithADParcel:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mAnchorPosition_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mAnchorOffset_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mAnchorLayoutFromEnd_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADParcel;", "LADXLinearLayoutManager_SavedState;", "writeToParcel", "LADParcel;I", "LADXLinearLayoutManager;" };
  static const J2ObjcClassInfo _ADXLinearLayoutManager_SavedState = { "SavedState", "androidx.recyclerview.widget", ptrTable, methods, fields, 7, 0x9, 7, 3, 4, -1, -1, -1, -1 };
  return &_ADXLinearLayoutManager_SavedState;
}

@end

void ADXLinearLayoutManager_SavedState_init(ADXLinearLayoutManager_SavedState *self) {
  NSObject_init(self);
}

ADXLinearLayoutManager_SavedState *new_ADXLinearLayoutManager_SavedState_init() {
  J2OBJC_NEW_IMPL(ADXLinearLayoutManager_SavedState, init)
}

ADXLinearLayoutManager_SavedState *create_ADXLinearLayoutManager_SavedState_init() {
  J2OBJC_CREATE_IMPL(ADXLinearLayoutManager_SavedState, init)
}

void ADXLinearLayoutManager_SavedState_initWithADParcel_(ADXLinearLayoutManager_SavedState *self, id<ADParcel> inArg) {
  NSObject_init(self);
  self->mAnchorPosition_ = 0;
  self->mAnchorOffset_ = 0;
  self->mAnchorLayoutFromEnd_ = (0 == 1);
}

ADXLinearLayoutManager_SavedState *new_ADXLinearLayoutManager_SavedState_initWithADParcel_(id<ADParcel> inArg) {
  J2OBJC_NEW_IMPL(ADXLinearLayoutManager_SavedState, initWithADParcel_, inArg)
}

ADXLinearLayoutManager_SavedState *create_ADXLinearLayoutManager_SavedState_initWithADParcel_(id<ADParcel> inArg) {
  J2OBJC_CREATE_IMPL(ADXLinearLayoutManager_SavedState, initWithADParcel_, inArg)
}

void ADXLinearLayoutManager_SavedState_initWithADXLinearLayoutManager_SavedState_(ADXLinearLayoutManager_SavedState *self, ADXLinearLayoutManager_SavedState *other) {
  NSObject_init(self);
  self->mAnchorPosition_ = ((ADXLinearLayoutManager_SavedState *) nil_chk(other))->mAnchorPosition_;
  self->mAnchorOffset_ = other->mAnchorOffset_;
  self->mAnchorLayoutFromEnd_ = other->mAnchorLayoutFromEnd_;
}

ADXLinearLayoutManager_SavedState *new_ADXLinearLayoutManager_SavedState_initWithADXLinearLayoutManager_SavedState_(ADXLinearLayoutManager_SavedState *other) {
  J2OBJC_NEW_IMPL(ADXLinearLayoutManager_SavedState, initWithADXLinearLayoutManager_SavedState_, other)
}

ADXLinearLayoutManager_SavedState *create_ADXLinearLayoutManager_SavedState_initWithADXLinearLayoutManager_SavedState_(ADXLinearLayoutManager_SavedState *other) {
  J2OBJC_CREATE_IMPL(ADXLinearLayoutManager_SavedState, initWithADXLinearLayoutManager_SavedState_, other)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXLinearLayoutManager_SavedState)

@implementation ADXLinearLayoutManager_AnchorInfo

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXLinearLayoutManager_AnchorInfo_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)reset {
  mPosition_ = ADXRecyclerView_NO_POSITION;
  mCoordinate_ = ADXLinearLayoutManager_INVALID_OFFSET;
  mLayoutFromEnd_ = false;
  mValid_ = false;
}

- (void)assignCoordinateFromPadding {
  mCoordinate_ = mLayoutFromEnd_ ? [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] : [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getStartAfterPadding];
}

- (NSString *)description {
  return JreStrcat("$I$I$Z$ZC", @"AnchorInfo{mPosition=", mPosition_, @", mCoordinate=", mCoordinate_, @", mLayoutFromEnd=", mLayoutFromEnd_, @", mValid=", mValid_, '}');
}

- (jboolean)isViewValidAsAnchorWithADView:(ADView *)child
                withADXRecyclerView_State:(ADXRecyclerView_State *)state {
  ADXRecyclerView_LayoutParams *lp = (ADXRecyclerView_LayoutParams *) cast_chk([((ADView *) nil_chk(child)) getLayoutParams], [ADXRecyclerView_LayoutParams class]);
  return ![((ADXRecyclerView_LayoutParams *) nil_chk(lp)) isItemRemoved] && [lp getViewLayoutPosition] >= 0 && [lp getViewLayoutPosition] < [((ADXRecyclerView_State *) nil_chk(state)) getItemCount];
}

- (void)assignFromViewAndKeepVisibleRectWithADView:(ADView *)child
                                           withInt:(jint)position {
  jint spaceChange = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getTotalSpaceChange];
  if (spaceChange >= 0) {
    [self assignFromViewWithADView:child withInt:position];
    return;
  }
  mPosition_ = position;
  if (mLayoutFromEnd_) {
    jint prevLayoutEnd = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] - spaceChange;
    jint childEnd = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedEndWithADView:child];
    jint previousEndMargin = prevLayoutEnd - childEnd;
    mCoordinate_ = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] - previousEndMargin;
    if (previousEndMargin > 0) {
      jint childSize = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedMeasurementWithADView:child];
      jint estimatedChildStart = mCoordinate_ - childSize;
      jint layoutStart = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getStartAfterPadding];
      jint previousStartMargin = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:child] - layoutStart;
      jint startReference = layoutStart + JavaLangMath_minWithInt_withInt_(previousStartMargin, 0);
      jint startMargin = estimatedChildStart - startReference;
      if (startMargin < 0) {
        mCoordinate_ += JavaLangMath_minWithInt_withInt_(previousEndMargin, -startMargin);
      }
    }
  }
  else {
    jint childStart = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:child];
    jint startMargin = childStart - [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getStartAfterPadding];
    mCoordinate_ = childStart;
    if (startMargin > 0) {
      jint estimatedEnd = childStart + [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedMeasurementWithADView:child];
      jint previousLayoutEnd = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] - spaceChange;
      jint previousEndMargin = previousLayoutEnd - [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedEndWithADView:child];
      jint endReference = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getEndAfterPadding] - JavaLangMath_minWithInt_withInt_(0, previousEndMargin);
      jint endMargin = endReference - estimatedEnd;
      if (endMargin < 0) {
        mCoordinate_ -= JavaLangMath_minWithInt_withInt_(startMargin, -endMargin);
      }
    }
  }
}

- (void)assignFromViewWithADView:(ADView *)child
                         withInt:(jint)position {
  if (mLayoutFromEnd_) {
    mCoordinate_ = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedEndWithADView:child] + [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getTotalSpaceChange];
  }
  else {
    mCoordinate_ = [((ADXOrientationHelper *) nil_chk(mOrientationHelper_)) getDecoratedStartWithADView:child];
  }
  mPosition_ = position;
}

- (void)dealloc {
  RELEASE_(mOrientationHelper_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 0, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 5, 4, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(reset);
  methods[2].selector = @selector(assignCoordinateFromPadding);
  methods[3].selector = @selector(description);
  methods[4].selector = @selector(isViewValidAsAnchorWithADView:withADXRecyclerView_State:);
  methods[5].selector = @selector(assignFromViewAndKeepVisibleRectWithADView:withInt:);
  methods[6].selector = @selector(assignFromViewWithADView:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mOrientationHelper_", "LADXOrientationHelper;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mPosition_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCoordinate_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mLayoutFromEnd_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mValid_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "toString", "isViewValidAsAnchor", "LADView;LADXRecyclerView_State;", "assignFromViewAndKeepVisibleRect", "LADView;I", "assignFromView", "LADXLinearLayoutManager;" };
  static const J2ObjcClassInfo _ADXLinearLayoutManager_AnchorInfo = { "AnchorInfo", "androidx.recyclerview.widget", ptrTable, methods, fields, 7, 0x8, 7, 5, 6, -1, -1, -1, -1 };
  return &_ADXLinearLayoutManager_AnchorInfo;
}

@end

void ADXLinearLayoutManager_AnchorInfo_init(ADXLinearLayoutManager_AnchorInfo *self) {
  NSObject_init(self);
  [self reset];
}

ADXLinearLayoutManager_AnchorInfo *new_ADXLinearLayoutManager_AnchorInfo_init() {
  J2OBJC_NEW_IMPL(ADXLinearLayoutManager_AnchorInfo, init)
}

ADXLinearLayoutManager_AnchorInfo *create_ADXLinearLayoutManager_AnchorInfo_init() {
  J2OBJC_CREATE_IMPL(ADXLinearLayoutManager_AnchorInfo, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXLinearLayoutManager_AnchorInfo)

@implementation ADXLinearLayoutManager_LayoutChunkResult

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXLinearLayoutManager_LayoutChunkResult_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)resetInternal {
  mConsumed_ = 0;
  mFinished_ = false;
  mIgnoreConsumed_ = false;
  mFocusable_ = false;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(resetInternal);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mConsumed_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mFinished_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mIgnoreConsumed_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mFocusable_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADXLinearLayoutManager;" };
  static const J2ObjcClassInfo _ADXLinearLayoutManager_LayoutChunkResult = { "LayoutChunkResult", "androidx.recyclerview.widget", ptrTable, methods, fields, 7, 0xc, 2, 4, 0, -1, -1, -1, -1 };
  return &_ADXLinearLayoutManager_LayoutChunkResult;
}

@end

void ADXLinearLayoutManager_LayoutChunkResult_init(ADXLinearLayoutManager_LayoutChunkResult *self) {
  NSObject_init(self);
}

ADXLinearLayoutManager_LayoutChunkResult *new_ADXLinearLayoutManager_LayoutChunkResult_init() {
  J2OBJC_NEW_IMPL(ADXLinearLayoutManager_LayoutChunkResult, init)
}

ADXLinearLayoutManager_LayoutChunkResult *create_ADXLinearLayoutManager_LayoutChunkResult_init() {
  J2OBJC_CREATE_IMPL(ADXLinearLayoutManager_LayoutChunkResult, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXLinearLayoutManager_LayoutChunkResult)
