//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXRecyclerView\src\main\java\androidx\collection\SimpleArrayMap.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "RVContainerHelpers.h"
#include "SimpleArrayMap.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/ClassCastException.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/ConcurrentModificationException.h"
#include "java/util/Map.h"


@interface ADXSimpleArrayMap ()

+ (jint)binarySearchHashesWithIntArray:(IOSIntArray *)hashes
                               withInt:(jint)N
                               withInt:(jint)hash_;

- (void)allocArraysWithInt:(jint)size OBJC_METHOD_FAMILY_NONE;

+ (void)freeArraysWithIntArray:(IOSIntArray *)hashes
             withNSObjectArray:(IOSObjectArray *)array
                       withInt:(jint)size;

@end

inline jboolean ADXSimpleArrayMap_get_DEBUG(void);
#define ADXSimpleArrayMap_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADXSimpleArrayMap, DEBUG, jboolean)

inline NSString *ADXSimpleArrayMap_get_TAG(void);
static NSString *ADXSimpleArrayMap_TAG = @"ArrayMap";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADXSimpleArrayMap, TAG, NSString *)

/*!
 @brief Attempt to spot concurrent modifications to this data structure.
 It's best-effort, but any time we can throw something more diagnostic than an
  ArrayIndexOutOfBoundsException deep in the ArrayMap internals it's going to
  save a lot of development time.
  Good times to look for CME include after any allocArrays() call and at the end of
  functions that change mSize (put/remove/clear).
 */
inline jboolean ADXSimpleArrayMap_get_CONCURRENT_MODIFICATION_EXCEPTIONS(void);
#define ADXSimpleArrayMap_CONCURRENT_MODIFICATION_EXCEPTIONS true
J2OBJC_STATIC_FIELD_CONSTANT(ADXSimpleArrayMap, CONCURRENT_MODIFICATION_EXCEPTIONS, jboolean)

/*!
 @brief The minimum amount by which the capacity of a ArrayMap will increase.
 This is tuned to be relatively space-efficient.
 */
inline jint ADXSimpleArrayMap_get_BASE_SIZE(void);
#define ADXSimpleArrayMap_BASE_SIZE 4
J2OBJC_STATIC_FIELD_CONSTANT(ADXSimpleArrayMap, BASE_SIZE, jint)

/*!
 @brief Maximum number of entries to have in array caches.
 */
inline jint ADXSimpleArrayMap_get_CACHE_SIZE(void);
#define ADXSimpleArrayMap_CACHE_SIZE 10
J2OBJC_STATIC_FIELD_CONSTANT(ADXSimpleArrayMap, CACHE_SIZE, jint)

__attribute__((unused)) static jint ADXSimpleArrayMap_binarySearchHashesWithIntArray_withInt_withInt_(IOSIntArray *hashes, jint N, jint hash_);

__attribute__((unused)) static void ADXSimpleArrayMap_allocArraysWithInt_(ADXSimpleArrayMap *self, jint size);

__attribute__((unused)) static void ADXSimpleArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(IOSIntArray *hashes, IOSObjectArray *array, jint size);

IOSObjectArray *ADXSimpleArrayMap_mBaseCache;
jint ADXSimpleArrayMap_mBaseCacheSize;
IOSObjectArray *ADXSimpleArrayMap_mTwiceBaseCache;
jint ADXSimpleArrayMap_mTwiceBaseCacheSize;

@implementation ADXSimpleArrayMap

+ (jint)binarySearchHashesWithIntArray:(IOSIntArray *)hashes
                               withInt:(jint)N
                               withInt:(jint)hash_ {
  return ADXSimpleArrayMap_binarySearchHashesWithIntArray_withInt_withInt_(hashes, N, hash_);
}

- (jint)indexOfWithId:(id)key
              withInt:(jint)hash_ {
  jint N = mSize_;
  if (N == 0) {
    return ~0;
  }
  jint index = ADXSimpleArrayMap_binarySearchHashesWithIntArray_withInt_withInt_(mHashes_, N, hash_);
  if (index < 0) {
    return index;
  }
  if ([nil_chk(key) isEqual:IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(index, 1))]) {
    return index;
  }
  jint end;
  for (end = index + 1; end < N && IOSIntArray_Get(nil_chk(mHashes_), end) == hash_; end++) {
    if ([key isEqual:IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(end, 1))]) return end;
  }
  for (jint i = index - 1; i >= 0 && IOSIntArray_Get(nil_chk(mHashes_), i) == hash_; i--) {
    if ([key isEqual:IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(i, 1))]) return i;
  }
  return ~end;
}

- (jint)indexOfNull {
  jint N = mSize_;
  if (N == 0) {
    return ~0;
  }
  jint index = ADXSimpleArrayMap_binarySearchHashesWithIntArray_withInt_withInt_(mHashes_, N, 0);
  if (index < 0) {
    return index;
  }
  if (nil == IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(index, 1))) {
    return index;
  }
  jint end;
  for (end = index + 1; end < N && IOSIntArray_Get(nil_chk(mHashes_), end) == 0; end++) {
    if (nil == IOSObjectArray_Get(mArray_, JreLShift32(end, 1))) return end;
  }
  for (jint i = index - 1; i >= 0 && IOSIntArray_Get(nil_chk(mHashes_), i) == 0; i--) {
    if (nil == IOSObjectArray_Get(mArray_, JreLShift32(i, 1))) return i;
  }
  return ~end;
}

- (void)allocArraysWithInt:(jint)size {
  ADXSimpleArrayMap_allocArraysWithInt_(self, size);
}

+ (void)freeArraysWithIntArray:(IOSIntArray *)hashes
             withNSObjectArray:(IOSObjectArray *)array
                       withInt:(jint)size {
  ADXSimpleArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(hashes, array, size);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXSimpleArrayMap_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithInt:(jint)capacity {
  ADXSimpleArrayMap_initWithInt_(self, capacity);
  return self;
}

- (instancetype)initWithADXSimpleArrayMap:(ADXSimpleArrayMap *)map {
  ADXSimpleArrayMap_initWithADXSimpleArrayMap_(self, map);
  return self;
}

- (void)clear {
  if (mSize_ > 0) {
    IOSIntArray *ohashes = mHashes_;
    IOSObjectArray *oarray = mArray_;
    jint osize = mSize_;
    JreStrongAssign(&mHashes_, JreLoadStatic(ADXRVContainerHelpers, EMPTY_INTS));
    JreStrongAssign(&mArray_, JreLoadStatic(ADXRVContainerHelpers, EMPTY_OBJECTS));
    mSize_ = 0;
    ADXSimpleArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(ohashes, oarray, osize);
  }
  if (mSize_ > 0) {
    @throw create_JavaUtilConcurrentModificationException_init();
  }
}

- (void)ensureCapacityWithInt:(jint)minimumCapacity {
  jint osize = mSize_;
  if (((IOSIntArray *) nil_chk(mHashes_))->size_ < minimumCapacity) {
    IOSIntArray *ohashes = mHashes_;
    IOSObjectArray *oarray = mArray_;
    ADXSimpleArrayMap_allocArraysWithInt_(self, minimumCapacity);
    if (mSize_ > 0) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ohashes, 0, mHashes_, 0, osize);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(oarray, 0, mArray_, 0, JreLShift32(osize, 1));
    }
    ADXSimpleArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(ohashes, oarray, osize);
  }
  if (mSize_ != osize) {
    @throw create_JavaUtilConcurrentModificationException_init();
  }
}

- (jboolean)containsKeyWithId:(id)key {
  return [self indexOfKeyWithId:key] >= 0;
}

- (jint)indexOfKeyWithId:(id)key {
  return key == nil ? [self indexOfNull] : [self indexOfWithId:key withInt:((jint) [key hash])];
}

- (jint)indexOfValueWithId:(id)value {
  jint N = mSize_ * 2;
  IOSObjectArray *array = mArray_;
  if (value == nil) {
    for (jint i = 1; i < N; i += 2) {
      if (IOSObjectArray_Get(nil_chk(array), i) == nil) {
        return JreRShift32(i, 1);
      }
    }
  }
  else {
    for (jint i = 1; i < N; i += 2) {
      if ([value isEqual:IOSObjectArray_Get(nil_chk(array), i)]) {
        return JreRShift32(i, 1);
      }
    }
  }
  return -1;
}

- (jboolean)containsValueWithId:(id)value {
  return [self indexOfValueWithId:value] >= 0;
}

- (id)getWithId:(id)key {
  return [self getOrDefaultWithId:key withId:nil];
}

- (id)getOrDefaultWithId:(id)key
                  withId:(id)defaultValue {
  jint index = [self indexOfKeyWithId:key];
  return index >= 0 ? IOSObjectArray_Get(nil_chk(mArray_), (JreLShift32(index, 1)) + 1) : defaultValue;
}

- (id)keyAtWithInt:(jint)index {
  return IOSObjectArray_Get(nil_chk(mArray_), JreLShift32(index, 1));
}

- (id)valueAtWithInt:(jint)index {
  return IOSObjectArray_Get(nil_chk(mArray_), (JreLShift32(index, 1)) + 1);
}

- (id)setValueAtWithInt:(jint)index
                 withId:(id)value {
  index = (JreLShift32(index, 1)) + 1;
  id old = IOSObjectArray_Get(nil_chk(mArray_), index);
  IOSObjectArray_Set(mArray_, index, value);
  return old;
}

- (jboolean)isEmpty {
  return mSize_ <= 0;
}

- (id)putWithId:(id)key
         withId:(id)value {
  jint osize = mSize_;
  jint hash_;
  jint index;
  if (key == nil) {
    hash_ = 0;
    index = [self indexOfNull];
  }
  else {
    hash_ = ((jint) [key hash]);
    index = [self indexOfWithId:key withInt:hash_];
  }
  if (index >= 0) {
    index = (JreLShift32(index, 1)) + 1;
    id old = IOSObjectArray_Get(nil_chk(mArray_), index);
    IOSObjectArray_Set(mArray_, index, value);
    return old;
  }
  index = ~index;
  if (osize >= ((IOSIntArray *) nil_chk(mHashes_))->size_) {
    jint n = osize >= (ADXSimpleArrayMap_BASE_SIZE * 2) ? (osize + (JreRShift32(osize, 1))) : (osize >= ADXSimpleArrayMap_BASE_SIZE ? (ADXSimpleArrayMap_BASE_SIZE * 2) : ADXSimpleArrayMap_BASE_SIZE);
    IOSIntArray *ohashes = mHashes_;
    IOSObjectArray *oarray = mArray_;
    ADXSimpleArrayMap_allocArraysWithInt_(self, n);
    if (osize != mSize_) {
      @throw create_JavaUtilConcurrentModificationException_init();
    }
    if (((IOSIntArray *) nil_chk(mHashes_))->size_ > 0) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ohashes, 0, mHashes_, 0, ohashes->size_);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(oarray, 0, mArray_, 0, ((IOSObjectArray *) nil_chk(oarray))->size_);
    }
    ADXSimpleArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(ohashes, oarray, osize);
  }
  if (index < osize) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mHashes_, index, mHashes_, index + 1, osize - index);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mArray_, JreLShift32(index, 1), mArray_, JreLShift32((index + 1), 1), JreLShift32((mSize_ - index), 1));
  }
  {
    if (osize != mSize_ || index >= ((IOSIntArray *) nil_chk(mHashes_))->size_) {
      @throw create_JavaUtilConcurrentModificationException_init();
    }
  }
  *IOSIntArray_GetRef(nil_chk(mHashes_), index) = hash_;
  IOSObjectArray_Set(nil_chk(mArray_), JreLShift32(index, 1), key);
  IOSObjectArray_Set(mArray_, (JreLShift32(index, 1)) + 1, value);
  mSize_++;
  return nil;
}

- (void)putAllWithADXSimpleArrayMap:(ADXSimpleArrayMap *)array {
  jint N = ((ADXSimpleArrayMap *) nil_chk(array))->mSize_;
  [self ensureCapacityWithInt:mSize_ + N];
  if (mSize_ == 0) {
    if (N > 0) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(array->mHashes_, 0, mHashes_, 0, N);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(array->mArray_, 0, mArray_, 0, JreLShift32(N, 1));
      mSize_ = N;
    }
  }
  else {
    for (jint i = 0; i < N; i++) {
      [self putWithId:[array keyAtWithInt:i] withId:[array valueAtWithInt:i]];
    }
  }
}

- (id)putIfAbsentWithId:(id)key
                 withId:(id)value {
  id mapValue = JreRetainedLocalValue([self getWithId:key]);
  if (mapValue == nil) {
    mapValue = [self putWithId:key withId:value];
  }
  return mapValue;
}

- (id)removeWithId:(id)key {
  jint index = [self indexOfKeyWithId:key];
  if (index >= 0) {
    return [self removeAtWithInt:index];
  }
  return nil;
}

- (jboolean)removeWithId:(id)key
                  withId:(id)value {
  jint index = [self indexOfKeyWithId:key];
  if (index >= 0) {
    id mapValue = JreRetainedLocalValue([self valueAtWithInt:index]);
    if (value == mapValue || (value != nil && [value isEqual:mapValue])) {
      [self removeAtWithInt:index];
      return true;
    }
  }
  return false;
}

- (id)removeAtWithInt:(jint)index {
  id old = IOSObjectArray_Get(nil_chk(mArray_), (JreLShift32(index, 1)) + 1);
  jint osize = mSize_;
  if (osize <= 1) {
    [self clear];
  }
  else {
    jint nsize = osize - 1;
    if (((IOSIntArray *) nil_chk(mHashes_))->size_ > (ADXSimpleArrayMap_BASE_SIZE * 2) && osize < JreIntDiv(mHashes_->size_, 3)) {
      jint n = osize > (ADXSimpleArrayMap_BASE_SIZE * 2) ? (osize + (JreRShift32(osize, 1))) : (ADXSimpleArrayMap_BASE_SIZE * 2);
      IOSIntArray *ohashes = mHashes_;
      IOSObjectArray *oarray = mArray_;
      ADXSimpleArrayMap_allocArraysWithInt_(self, n);
      if (osize != mSize_) {
        @throw create_JavaUtilConcurrentModificationException_init();
      }
      if (index > 0) {
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ohashes, 0, mHashes_, 0, index);
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(oarray, 0, mArray_, 0, JreLShift32(index, 1));
      }
      if (index < nsize) {
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ohashes, index + 1, mHashes_, index, nsize - index);
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(oarray, JreLShift32((index + 1), 1), mArray_, JreLShift32(index, 1), JreLShift32((nsize - index), 1));
      }
    }
    else {
      if (index < nsize) {
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mHashes_, index + 1, mHashes_, index, nsize - index);
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mArray_, JreLShift32((index + 1), 1), mArray_, JreLShift32(index, 1), JreLShift32((nsize - index), 1));
      }
      IOSObjectArray_Set(nil_chk(mArray_), JreLShift32(nsize, 1), nil);
      IOSObjectArray_Set(mArray_, (JreLShift32(nsize, 1)) + 1, nil);
    }
    if (osize != mSize_) {
      @throw create_JavaUtilConcurrentModificationException_init();
    }
    mSize_ = nsize;
  }
  return old;
}

- (id)replaceWithId:(id)key
             withId:(id)value {
  jint index = [self indexOfKeyWithId:key];
  if (index >= 0) {
    return [self setValueAtWithInt:index withId:value];
  }
  return nil;
}

- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue {
  jint index = [self indexOfKeyWithId:key];
  if (index >= 0) {
    id mapValue = JreRetainedLocalValue([self valueAtWithInt:index]);
    if (mapValue == oldValue || (oldValue != nil && [oldValue isEqual:mapValue])) {
      [self setValueAtWithInt:index withId:newValue];
      return true;
    }
  }
  return false;
}

- (jint)size {
  return mSize_;
}

- (jboolean)isEqual:(id)object {
  if (self == object) {
    return true;
  }
  @try {
    if ([object isKindOfClass:[ADXSimpleArrayMap class]]) {
      ADXSimpleArrayMap *map = (ADXSimpleArrayMap *) object;
      if ([self size] != [((ADXSimpleArrayMap *) nil_chk(map)) size]) {
        return false;
      }
      for (jint i = 0; i < mSize_; i++) {
        id key = JreRetainedLocalValue([self keyAtWithInt:i]);
        id mine = JreRetainedLocalValue([self valueAtWithInt:i]);
        id theirs = JreRetainedLocalValue([map getWithId:key]);
        if (mine == nil) {
          if (theirs != nil || ![map containsKeyWithId:key]) {
            return false;
          }
        }
        else if (![mine isEqual:theirs]) {
          return false;
        }
      }
      return true;
    }
    else if ([JavaUtilMap_class_() isInstance:object]) {
      id<JavaUtilMap> map = (id<JavaUtilMap>) cast_check(object, JavaUtilMap_class_());
      if ([self size] != [((id<JavaUtilMap>) nil_chk(map)) size]) {
        return false;
      }
      for (jint i = 0; i < mSize_; i++) {
        id key = JreRetainedLocalValue([self keyAtWithInt:i]);
        id mine = JreRetainedLocalValue([self valueAtWithInt:i]);
        id theirs = JreRetainedLocalValue([map getWithId:key]);
        if (mine == nil) {
          if (theirs != nil || ![map containsKeyWithId:key]) {
            return false;
          }
        }
        else if (![mine isEqual:theirs]) {
          return false;
        }
      }
      return true;
    }
  }
  @catch (JavaLangNullPointerException *ignored) {
  }
  @catch (JavaLangClassCastException *ignored) {
  }
  return false;
}

- (NSUInteger)hash {
  IOSIntArray *hashes = mHashes_;
  IOSObjectArray *array = mArray_;
  jint result = 0;
  for (jint i = 0, v = 1, s = mSize_; i < s; i++, v += 2) {
    id value = IOSObjectArray_Get(nil_chk(array), v);
    result += IOSIntArray_Get(nil_chk(hashes), i) ^ (value == nil ? 0 : ((jint) [value hash]));
  }
  return result;
}

- (NSString *)description {
  if ([self isEmpty]) {
    return @"{}";
  }
  JavaLangStringBuilder *buffer = create_JavaLangStringBuilder_initWithInt_(mSize_ * 28);
  [buffer appendWithChar:'{'];
  for (jint i = 0; i < mSize_; i++) {
    if (i > 0) {
      [buffer appendWithNSString:@", "];
    }
    id key = JreRetainedLocalValue([self keyAtWithInt:i]);
    if (key != self) {
      [buffer appendWithId:key];
    }
    else {
      [buffer appendWithNSString:@"(this Map)"];
    }
    [buffer appendWithChar:'='];
    id value = JreRetainedLocalValue([self valueAtWithInt:i]);
    if (value != self) {
      [buffer appendWithId:value];
    }
    else {
      [buffer appendWithNSString:@"(this Map)"];
    }
  }
  [buffer appendWithChar:'}'];
  return [buffer description];
}

- (void)dealloc {
  RELEASE_(mHashes_);
  RELEASE_(mArray_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "I", 0xa, 0, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 2, 3, -1, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 6, 7, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 5, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 8, -1, 9, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 11, 12, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 13, 12, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 14, 12, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 12, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 16, 12, -1, 17, -1, -1 },
    { NULL, "LNSObject;", 0x1, 18, 19, -1, 20, -1, -1 },
    { NULL, "LNSObject;", 0x1, 21, 5, -1, 22, -1, -1 },
    { NULL, "LNSObject;", 0x1, 23, 5, -1, 24, -1, -1 },
    { NULL, "LNSObject;", 0x1, 25, 26, -1, 27, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 28, 19, -1, 29, -1, -1 },
    { NULL, "V", 0x1, 30, 8, -1, 31, -1, -1 },
    { NULL, "LNSObject;", 0x1, 32, 19, -1, 29, -1, -1 },
    { NULL, "LNSObject;", 0x1, 33, 12, -1, 17, -1, -1 },
    { NULL, "Z", 0x1, 33, 19, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 34, 5, -1, 24, -1, -1 },
    { NULL, "LNSObject;", 0x1, 35, 19, -1, 29, -1, -1 },
    { NULL, "Z", 0x1, 35, 36, -1, 37, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 38, 12, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 39, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 40, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(binarySearchHashesWithIntArray:withInt:withInt:);
  methods[1].selector = @selector(indexOfWithId:withInt:);
  methods[2].selector = @selector(indexOfNull);
  methods[3].selector = @selector(allocArraysWithInt:);
  methods[4].selector = @selector(freeArraysWithIntArray:withNSObjectArray:withInt:);
  methods[5].selector = @selector(init);
  methods[6].selector = @selector(initWithInt:);
  methods[7].selector = @selector(initWithADXSimpleArrayMap:);
  methods[8].selector = @selector(clear);
  methods[9].selector = @selector(ensureCapacityWithInt:);
  methods[10].selector = @selector(containsKeyWithId:);
  methods[11].selector = @selector(indexOfKeyWithId:);
  methods[12].selector = @selector(indexOfValueWithId:);
  methods[13].selector = @selector(containsValueWithId:);
  methods[14].selector = @selector(getWithId:);
  methods[15].selector = @selector(getOrDefaultWithId:withId:);
  methods[16].selector = @selector(keyAtWithInt:);
  methods[17].selector = @selector(valueAtWithInt:);
  methods[18].selector = @selector(setValueAtWithInt:withId:);
  methods[19].selector = @selector(isEmpty);
  methods[20].selector = @selector(putWithId:withId:);
  methods[21].selector = @selector(putAllWithADXSimpleArrayMap:);
  methods[22].selector = @selector(putIfAbsentWithId:withId:);
  methods[23].selector = @selector(removeWithId:);
  methods[24].selector = @selector(removeWithId:withId:);
  methods[25].selector = @selector(removeAtWithInt:);
  methods[26].selector = @selector(replaceWithId:withId:);
  methods[27].selector = @selector(replaceWithId:withId:withId:);
  methods[28].selector = @selector(size);
  methods[29].selector = @selector(isEqual:);
  methods[30].selector = @selector(hash);
  methods[31].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEBUG", "Z", .constantValue.asBOOL = ADXSimpleArrayMap_DEBUG, 0x1a, -1, -1, -1, -1 },
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 41, -1, -1 },
    { "CONCURRENT_MODIFICATION_EXCEPTIONS", "Z", .constantValue.asBOOL = ADXSimpleArrayMap_CONCURRENT_MODIFICATION_EXCEPTIONS, 0x1a, -1, -1, -1, -1 },
    { "BASE_SIZE", "I", .constantValue.asInt = ADXSimpleArrayMap_BASE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "CACHE_SIZE", "I", .constantValue.asInt = ADXSimpleArrayMap_CACHE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "mBaseCache", "[LNSObject;", .constantValue.asLong = 0, 0x8, -1, 42, -1, -1 },
    { "mBaseCacheSize", "I", .constantValue.asLong = 0, 0x8, -1, 43, -1, -1 },
    { "mTwiceBaseCache", "[LNSObject;", .constantValue.asLong = 0, 0x8, -1, 44, -1, -1 },
    { "mTwiceBaseCacheSize", "I", .constantValue.asLong = 0, 0x8, -1, 45, -1, -1 },
    { "mHashes_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mArray_", "[LNSObject;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mSize_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "binarySearchHashes", "[III", "indexOf", "LNSObject;I", "allocArrays", "I", "freeArrays", "[I[LNSObject;I", "LADXSimpleArrayMap;", "(Landroidx/collection/SimpleArrayMap<TK;TV;>;)V", "ensureCapacity", "containsKey", "LNSObject;", "indexOfKey", "indexOfValue", "containsValue", "get", "(Ljava/lang/Object;)TV;", "getOrDefault", "LNSObject;LNSObject;", "(Ljava/lang/Object;TV;)TV;", "keyAt", "(I)TK;", "valueAt", "(I)TV;", "setValueAt", "ILNSObject;", "(ITV;)TV;", "put", "(TK;TV;)TV;", "putAll", "(Landroidx/collection/SimpleArrayMap<+TK;+TV;>;)V", "putIfAbsent", "remove", "removeAt", "replace", "LNSObject;LNSObject;LNSObject;", "(TK;TV;TV;)Z", "equals", "hashCode", "toString", &ADXSimpleArrayMap_TAG, &ADXSimpleArrayMap_mBaseCache, &ADXSimpleArrayMap_mBaseCacheSize, &ADXSimpleArrayMap_mTwiceBaseCache, &ADXSimpleArrayMap_mTwiceBaseCacheSize, "<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;" };
  static const J2ObjcClassInfo _ADXSimpleArrayMap = { "SimpleArrayMap", "androidx.collection", ptrTable, methods, fields, 7, 0x1, 32, 12, -1, -1, -1, 46, -1 };
  return &_ADXSimpleArrayMap;
}

@end

jint ADXSimpleArrayMap_binarySearchHashesWithIntArray_withInt_withInt_(IOSIntArray *hashes, jint N, jint hash_) {
  ADXSimpleArrayMap_initialize();
  @try {
    return ADXRVContainerHelpers_binarySearchWithIntArray_withInt_withInt_(hashes, N, hash_);
  }
  @catch (JavaLangArrayIndexOutOfBoundsException *e) {
    {
      @throw create_JavaUtilConcurrentModificationException_init();
    }
  }
}

void ADXSimpleArrayMap_allocArraysWithInt_(ADXSimpleArrayMap *self, jint size) {
  if (size == (ADXSimpleArrayMap_BASE_SIZE * 2)) {
    @synchronized(ADXSimpleArrayMap_class_()) {
      if (ADXSimpleArrayMap_mTwiceBaseCache != nil) {
        IOSObjectArray *array = ADXSimpleArrayMap_mTwiceBaseCache;
        JreStrongAssign(&self->mArray_, array);
        JreStrongAssign(&ADXSimpleArrayMap_mTwiceBaseCache, (IOSObjectArray *) cast_check(IOSObjectArray_Get(array, 0), IOSClass_arrayType(NSObject_class_(), 1)));
        JreStrongAssign(&self->mHashes_, (IOSIntArray *) cast_chk(IOSObjectArray_Get(array, 1), [IOSIntArray class]));
        IOSObjectArray_Set(array, 0, IOSObjectArray_Set(array, 1, nil));
        ADXSimpleArrayMap_mTwiceBaseCacheSize--;
        return;
      }
    }
  }
  else if (size == ADXSimpleArrayMap_BASE_SIZE) {
    @synchronized(ADXSimpleArrayMap_class_()) {
      if (ADXSimpleArrayMap_mBaseCache != nil) {
        IOSObjectArray *array = ADXSimpleArrayMap_mBaseCache;
        JreStrongAssign(&self->mArray_, array);
        JreStrongAssign(&ADXSimpleArrayMap_mBaseCache, (IOSObjectArray *) cast_check(IOSObjectArray_Get(array, 0), IOSClass_arrayType(NSObject_class_(), 1)));
        JreStrongAssign(&self->mHashes_, (IOSIntArray *) cast_chk(IOSObjectArray_Get(array, 1), [IOSIntArray class]));
        IOSObjectArray_Set(array, 0, IOSObjectArray_Set(array, 1, nil));
        ADXSimpleArrayMap_mBaseCacheSize--;
        return;
      }
    }
  }
  JreStrongAssignAndConsume(&self->mHashes_, [IOSIntArray newArrayWithLength:size]);
  JreStrongAssignAndConsume(&self->mArray_, [IOSObjectArray newArrayWithLength:JreLShift32(size, 1) type:NSObject_class_()]);
}

void ADXSimpleArrayMap_freeArraysWithIntArray_withNSObjectArray_withInt_(IOSIntArray *hashes, IOSObjectArray *array, jint size) {
  ADXSimpleArrayMap_initialize();
  if (((IOSIntArray *) nil_chk(hashes))->size_ == (ADXSimpleArrayMap_BASE_SIZE * 2)) {
    @synchronized(ADXSimpleArrayMap_class_()) {
      if (ADXSimpleArrayMap_mTwiceBaseCacheSize < ADXSimpleArrayMap_CACHE_SIZE) {
        IOSObjectArray_Set(nil_chk(array), 0, ADXSimpleArrayMap_mTwiceBaseCache);
        IOSObjectArray_Set(array, 1, hashes);
        for (jint i = (JreLShift32(size, 1)) - 1; i >= 2; i--) {
          IOSObjectArray_Set(array, i, nil);
        }
        JreStrongAssign(&ADXSimpleArrayMap_mTwiceBaseCache, array);
        ADXSimpleArrayMap_mTwiceBaseCacheSize++;
      }
    }
  }
  else if (hashes->size_ == ADXSimpleArrayMap_BASE_SIZE) {
    @synchronized(ADXSimpleArrayMap_class_()) {
      if (ADXSimpleArrayMap_mBaseCacheSize < ADXSimpleArrayMap_CACHE_SIZE) {
        IOSObjectArray_Set(nil_chk(array), 0, ADXSimpleArrayMap_mBaseCache);
        IOSObjectArray_Set(array, 1, hashes);
        for (jint i = (JreLShift32(size, 1)) - 1; i >= 2; i--) {
          IOSObjectArray_Set(array, i, nil);
        }
        JreStrongAssign(&ADXSimpleArrayMap_mBaseCache, array);
        ADXSimpleArrayMap_mBaseCacheSize++;
      }
    }
  }
}

void ADXSimpleArrayMap_init(ADXSimpleArrayMap *self) {
  NSObject_init(self);
  JreStrongAssign(&self->mHashes_, JreLoadStatic(ADXRVContainerHelpers, EMPTY_INTS));
  JreStrongAssign(&self->mArray_, JreLoadStatic(ADXRVContainerHelpers, EMPTY_OBJECTS));
  self->mSize_ = 0;
}

ADXSimpleArrayMap *new_ADXSimpleArrayMap_init() {
  J2OBJC_NEW_IMPL(ADXSimpleArrayMap, init)
}

ADXSimpleArrayMap *create_ADXSimpleArrayMap_init() {
  J2OBJC_CREATE_IMPL(ADXSimpleArrayMap, init)
}

void ADXSimpleArrayMap_initWithInt_(ADXSimpleArrayMap *self, jint capacity) {
  NSObject_init(self);
  if (capacity == 0) {
    JreStrongAssign(&self->mHashes_, JreLoadStatic(ADXRVContainerHelpers, EMPTY_INTS));
    JreStrongAssign(&self->mArray_, JreLoadStatic(ADXRVContainerHelpers, EMPTY_OBJECTS));
  }
  else {
    ADXSimpleArrayMap_allocArraysWithInt_(self, capacity);
  }
  self->mSize_ = 0;
}

ADXSimpleArrayMap *new_ADXSimpleArrayMap_initWithInt_(jint capacity) {
  J2OBJC_NEW_IMPL(ADXSimpleArrayMap, initWithInt_, capacity)
}

ADXSimpleArrayMap *create_ADXSimpleArrayMap_initWithInt_(jint capacity) {
  J2OBJC_CREATE_IMPL(ADXSimpleArrayMap, initWithInt_, capacity)
}

void ADXSimpleArrayMap_initWithADXSimpleArrayMap_(ADXSimpleArrayMap *self, ADXSimpleArrayMap *map) {
  ADXSimpleArrayMap_init(self);
  if (map != nil) {
    [self putAllWithADXSimpleArrayMap:map];
  }
}

ADXSimpleArrayMap *new_ADXSimpleArrayMap_initWithADXSimpleArrayMap_(ADXSimpleArrayMap *map) {
  J2OBJC_NEW_IMPL(ADXSimpleArrayMap, initWithADXSimpleArrayMap_, map)
}

ADXSimpleArrayMap *create_ADXSimpleArrayMap_initWithADXSimpleArrayMap_(ADXSimpleArrayMap *map) {
  J2OBJC_CREATE_IMPL(ADXSimpleArrayMap, initWithADXSimpleArrayMap_, map)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXSimpleArrayMap)
